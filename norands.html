<!DOCTYPE html>
<html lang="en" dir="ltr">

  <head>
    <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden; /* optional: prevents scrollbars */
    }
    body {
      cursor: none;
    }
    canvas {
      display: block; /* removes inline spacing */
      position: absolute;
      top: 0;
      left: 0;
    }
    </style>
  </head>
<div>

  <ul>
    <button hidden id="play">Play Sound</button>
  <div  id="dog-image-container" class="canvas">

    <canvas id="canvas" width="1200" height="1200" class="canvas"></canvas>

    <script type="module">
      import * as Tone from "https://cdn.skypack.dev/tone@14.8.49"; 
    
      
      const synth = new Tone.PolySynth(Tone.Synth, {
        maxPolyphony: 400, // only 4 notes can play simultaneously
        envelope: {
          attack: 0.02,  // short but not zero
          decay: 0.99,
          sustain: 0.5,
          release: 0.5
      }
      }).toDestination(); 


      await Tone.start();

      let macrodupe = 0

      let rellock = 0




      
    // window.addEventListener('DOMContentLoaded', (event) => {
    const squaretable = {} // this section of code is an optimization for use of the hypotenuse function on Line and LineOP objects
    for (let t = 0; t < 10000000; t++) {
        squaretable[`${t}`] = Math.sqrt(t)
        if (t > 999) {
            t += 9
        }
    }
    let cyclock = 0
    
    
    let randomcounter = Math.floor(Math.random() * 1000000)
    let noseCost = .02
    let earCost = .02
    
    let soundFlip = -1
    // ////////////////console.log(rands.length)
    
    let freeEnergyOn = 1 //makes freec freen not go
    let smellScaler = 10
    let cycler = 0
    
    let timerresize = 0
    let dumbdoton = -1
    let zoom = 1
    let globsounds = []
    let globuckets =[]
    let worldsave = {}
    worldsave.guys = []
    let dorecon = 0
    let reconflag = {}
    let reconflagz = {}
    let agesuckrat = 1
    let suckratio = 50
    let gillconstant = .9 //.5 //.4 //1 //.95 
    let relationView = false
    let globlock = 0
    let magratmax = 2.5
    let rota = 0
    let rotaspeed = 200
    let magnetonly = -1
    let magnetzoom = -1
    let rotatick = 0
    let rotaclickover = 7
    let rotacounter = 0
    let viewrota = ["r", "g", "b", 'm', 'p', 'q', 'z']
    let magmax = 1
    let magnetism = 1
    let magnetradius = 12
    let magdisplay = 1
    let magmindisp = 0
    let magnetcolors = ["#00fffa", "#888888", "#FFFa00"]
    let loutmin = 10
    let ringon = 0
    let makeline = 0
    let worldscale = 12
    
    let bucketsize = worldscale*2 //2.5 //1.5 too small //2.5 is slow at big
    let iconsview = -1
    // let runcount = 10 
    let eartick = 0
    let earsnap = 1//3 //slows consolidateSound
    let tempon = 1
    let particletoggle = 1
    let temperatureInvert = 100
    let temperature = 0
    let genelength = 7
    // let codonconstant = Math.min((Math.sqrt(genelength)*1),9)
    let codonconstant = 2 //Math.min((Math.sqrt(genelength)*1),9) //2
    let sensoryConstant = 5 //10 too high //Math.min((Math.sqrt(genelength)*1),9) //2
    let runcount = 2// 1// 6 //12
    let runsnap = 0
    let ld = 0
    let nodin1 = -1
    let nodin2 = -1
    let start = 0
    let speciesdistance = 112 //70 //75 // 32 was for 3 dimensional color 32 //48 is half
    let breedingdistance = 448
    let signal = 0
    let codonusage = 1
    let repconstant = 125
    let slide = -1
    let smellTime = 0
    let smellMax = 10000000000
    let viewStyle = 0
    let headout = 0
    let edgeLoop = 1
    let audioPing = -1
    let lasfgl = 0
    let bodc = 0
    let lsstbodc = 0
    let fded = 0
    let fded2 = 0
    let timesLength = 10 //12
    let mindead = 0 
    let driftconstant = 2000 //never set to 0 to get 0 drift set it to like 9999999999999999
    let mutationrate = .01
    let maxage = 1200
    let generationConstant = .6 //(2/3) //.64 precost shift ///.4 works //.59,.6 before codon cost
    let minage = 50 
    let fertilityratio = 1.011 //bumped up with freec addition
    let fertilitycost = .25
    let longevitycost = .25 //nice guess
    let globlinker = {}
    if (ringon == 1) {
        minage = 1
    }
    
    let makegreen = 0
    let makeall = 0
    let greens = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
    // let greens = [4]
    let nodecap = 25000
    
    
    let freen = 125 * 5000 //nodecap
    let freec = freen
    
    
    
    let video_recorder
    let recording = 0
    let globduper = []
    let predatorIncentive = 0
    let diffdist = -1
    let nodetypes = 23
    let totalKill = 1
    let movementCost = .05 //.5
    let baseCostOfNode = .01 //.01
    let worldtime = 0
    let mouthCost = .04 //.04
    let suckCost = .02
    let rotationCost = .02 //.02
    let linkcost = .001 // .002
    let linkcostdistance = .0001
    let genelengthcost = .0001 //.0001
    let magnetcost = .01
    let dragcost = .05
    let pistoncost = .02 //.02
    let anchorcost = .02
    let timemin = 13
    let smellFlip = -1
    
    let worldscaler = worldscale / 8
    // function CanvasCaptureToWEBM(canvas, bitrate) {
    //     // the video_recorder is set to  '= new CanvasCaptureToWEBM(canvas, 4500000);' in the setup, 
    //     // it uses the same canvas as the rest of the file.
    //     // to start a recording call .record() on video_recorder
    //     /*
    //     for example, 
    //     if(keysPressed['-'] && recording == 0){
    //         recording = 1
    //         video_recorder.record()
    //     }
    //     if(keysPressed['='] && recording == 1){
    //         recording = 0
    //         video_recorder.stop()
    //         video_recorder.download('File Name As A String.webm')
    //     }
    //     */
    //     this.record = Record
    //     this.stop = Stop
    //     this.download = saveToDownloads
    //     let blobCaptures = []
    //     let outputFormat = {}
    //     let recorder = {}
    //     let canvasInput = canvas.captureStream()
    //     if (typeof canvasInput == undefined || !canvasInput) {
    //         return
    //     }
    //     const video = document.createElement('video')
    //     video.style.display = 'none'
    
    //     function Record() {
    //         let formats = [
    //             'video/vp8',
    //             "video/webm",
    //             'video/webm,codecs=vp9',
    //             "video/webm\;codecs=vp8",
    //             "video/webm\;codecs=daala",
    //             "video/webm\;codecs=h264",
    //             "video/mpeg"
    //         ];
    
    //         for (let t = 0;t<formats.length;t++) {
    //             if (MediaRecorder.isTypeSupported(formats[t])) {
    //                 outputFormat = formats[t]
    //                 break
    //             }
    //         }
    //         if (typeof outputFormat != "string") {
    //             return
    //         }else{
    //             let videoSettings = {
    //                 mimeType: outputFormat,
    //                 videoBitsPerSecond: bitrate || 2000000 // 2Mbps
    //             };
    //             blobCaptures = []
    //             try {
    //                 recorder = new MediaRecorder(canvasInput, videoSettings)
    //             } catch (error) {
    //                 return;
    //             }
    //             recorder.onstop = handleStop
    //             recorder.ondataavailable = handleAvailableData
    //             recorder.start(100)
    //         } 
    //     }
    //     function handleAvailableData(event) {
    //         if (event.data && event.data.size > 0) {
    //             blobCaptures.push(event.data)
    //         }
    //     }
    //     function handleStop() {
    //         const superBuffer = new Blob(blobCaptures, { type: outputFormat })
    //         video.src = window.URL.createObjectURL(superBuffer)
    //     }
    //     function Stop() {
    //         recorder.stop()
    //         video.controls = true
    //     }
    //     function saveToDownloads(input) { // specifying a file name for the output
    //         const name = input || 'video_out.webm'
    //         const blob = new Blob(blobCaptures, { type: outputFormat })
    //         const url = window.URL.createObjectURL(blob)
    //         const storageElement = document.createElement('a')
    //         storageElement.style.display = 'none'
    //         storageElement.href = url
    //         storageElement.download = name
    //         document.body.appendChild(storageElement)
    //         storageElement.click()
    //         setTimeout(() => {
    //             document.body.removeChild(storageElement)
    //             window.URL.revokeObjectURL(url)
    //         }, 100)
    //     }
    // }
    const gamepadAPI = {
        controller: {},
        turbo: true,
        connect: function(evt) {
            if (navigator.getGamepads()[0] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            } else if (navigator.getGamepads()[1] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            } else if (navigator.getGamepads()[2] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            } else if (navigator.getGamepads()[3] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            }
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i] === null) {
                    continue;
                }
                if (!gamepads[i].connected) {
                    continue;
                }
            }
        },
        disconnect: function(evt) {
            gamepadAPI.turbo = false;
            delete gamepadAPI.controller;
        },
        update: function() {
            gamepadAPI.controller = navigator.getGamepads()[0]
            gamepadAPI.buttonsCache = []; // clear the buttons cache
            for (var k = 0; k < gamepadAPI.buttonsStatus.length; k++) { // move the buttons status from the previous frame to the cache
                gamepadAPI.buttonsCache[k] = gamepadAPI.buttonsStatus[k];
            }
            gamepadAPI.buttonsStatus = []; // clear the buttons status
            var c = gamepadAPI.controller || {}; // get the gamepad object
            var pressed = [];
            if (c.buttons) {
                for (var b = 0, t = c.buttons.length; b < t; b++) { // loop through buttons and push the pressed ones to the array
                    if (c.buttons[b].pressed) {
                        pressed.push(gamepadAPI.buttons[b]);
                    }
                }
            }
            var axes = [];
            if (c.axes) {
                for (var a = 0, x = c.axes.length; a < x; a++) { // loop through axes and push their values to the array
                    axes.push(c.axes[a].toFixed(2));
                }
            }
            gamepadAPI.axesStatus = axes; // assign received values
            gamepadAPI.buttonsStatus = pressed;
            // //////////////////////////////////////////console.log(pressed); // return buttons for debugging purposes
            return pressed;
        },
        buttonPressed: function(button, hold) {
            var newPress = false;
            for (var i = 0, s = gamepadAPI.buttonsStatus.length; i < s; i++) { // loop through pressed buttons
                if (gamepadAPI.buttonsStatus[i] == button) { // if we found the button we're looking for...
                    newPress = true; // set the boolean variable to true
                    if (!hold) { // if we want to check the single press
                        for (var j = 0, p = gamepadAPI.buttonsCache.length; j < p; j++) { // loop through the cached states from the previous frame
                            if (gamepadAPI.buttonsCache[j] == button) { // if the button was already pressed, ignore new press
                                newPress = false;
                            }
                        }
                    }
                }
            }
            return newPress;
        },
        buttons: [
            'A', 'B', 'X', 'Y', 'LB', 'RB', 'Left-Trigger', 'Right-Trigger', 'Back', 'Start', 'Axis-Left', 'Axis-Right', 'DPad-Up', 'DPad-Down', 'DPad-Left', 'DPad-Right', "Power"
        ],
        buttonsCache: [],
        buttonsStatus: [],
        axesStatus: []
    };
    let canvas
    let canvas_context
    let keysPressed = {}
    let FLEX_engine
    let TIP_engine = {}
    let XS_engine
    let YS_engine
    //(2).valueOf() 
    //2
    class Point {
        constructor(x, y) {
            this.x = x
            this.y = y
            this.radius = 0
        }
        pointDistance(point) {
            return (new LineOP(this, point, "transparent", 0)).hypotenuse()
        }
    }
    
    class Vector { // vector math and physics if you prefer this over vector components on circles
        constructor(object = (new Point(0, 0)), xmom = 0, ymom = 0) {
            this.xmom = xmom
            this.ymom = ymom
            this.object = object
        }
        isToward(point) {
            let link = new LineOP(this.object, point)
            let dis1 = link.squareDistance()
            let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
            let link2 = new LineOP(dummy, point)
            let dis2 = link2.squareDistance()
            if (dis2 < dis1) {
                return true
            } else {
                return false
            }
        }
        rotate(angleGoal) {
            let link = new Line(this.xmom, this.ymom, 0, 0)
            let length = link.hypotenuse()
            let x = (length * Math.cos(angleGoal))
            let y = (length * Math.sin(angleGoal))
            this.xmom = x
            this.ymom = y
        }
        magnitude() {
            return (new Line(this.xmom, this.ymom, 0, 0)).hypotenuse()
        }
        normalize(size = 1) {
            let magnitude = this.magnitude()
            this.xmom /= magnitude
            this.ymom /= magnitude
            this.xmom *= size
            this.ymom *= size
        }
        multiply(vect) {
            let point = new Point(0, 0)
            let end = new Point(this.xmom + vect.xmom, this.ymom + vect.ymom)
            return point.pointDistance(end)
        }
        add(vect) {
            return new Vector(this.object, this.xmom + vect.xmom, this.ymom + vect.ymom)
        }
        subtract(vect) {
            return new Vector(this.object, this.xmom - vect.xmom, this.ymom - vect.ymom)
        }
        divide(vect) {
            return new Vector(this.object, this.xmom / vect.xmom, this.ymom / vect.ymom) //be careful with this, I don't think this is right
        }
        draw() {
            let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
            let link = new LineOP(this.object, dummy, "#FFFFFF", 1)
            link.draw()
        }
    }
    class Line {
        constructor(x, y, x2, y2, color, width) {
            this.x1 = x
            this.y1 = y
            this.x2 = x2
            this.y2 = y2
            this.color = color
            this.width = width
        }
        angle() {
            return Math.atan2(this.y1 - this.y2, this.x1 - this.x2)
        }
        squareDistance() {
            let xdif = this.x1 - this.x2
            let ydif = this.y1 - this.y2
            let squareDistance = (xdif * xdif) + (ydif * ydif)
            return squareDistance
        }
        hypotenuse() {
            let xdif = this.x1 - this.x2
            let ydif = this.y1 - this.y2
            let hypotenuse = (xdif * xdif) + (ydif * ydif)
            if (hypotenuse < 10000000 - 1) {
                if (hypotenuse > 1000) {
                    return squaretable[`${Math.round(10 * Math.round((hypotenuse * .1)))}`]
                } else {
                    return squaretable[`${Math.round(hypotenuse)}`]
                }
            } else {
                return Math.sqrt(hypotenuse)
            }
        }
        draw() {
            let lineWidthstorage = canvas_context.lineWidth
            canvas_context.strokeStyle = this.color
            canvas_context.lineWidth = this.width
            canvas_context.beginPath()
            canvas_context.moveTo(this.x1, this.y1)
            canvas_context.lineTo(this.x2, this.y2)
            canvas_context.stroke()
            canvas_context.lineWidth = lineWidthstorage
        }
    }
    class LineOP {
        constructor(object, target, color, width) {
            this.object = object
            this.target = target
            this.color = color
            this.width = width
        }
        squareDistance() {
            let xdif = this.object.x - this.target.x
            let ydif = this.object.y - this.target.y
            let squareDistance = (xdif * xdif) + (ydif * ydif)
            return squareDistance
        }
        hypotenuse() {
            if (this.target.dead == 1 || this.object.dead == 1) {
                return 999999999999
            }
            let xdif = this.object.x - this.target.x
            let ydif = this.object.y - this.target.y
            let hypotenuse = (xdif * xdif) + (ydif * ydif)
            if (hypotenuse < 10000000 - 1) {
                if (hypotenuse > 1000) {
                    return squaretable[`${Math.round(10 * Math.round((hypotenuse * .1)))}`]
                } else {
                    return squaretable[`${Math.round(hypotenuse)}`]
                }
            } else {
                return Math.sqrt(hypotenuse)
            }
        }
        angle() {
            return Math.atan2(this.object.y - this.target.y, this.object.x - this.target.x)
        }
    
        draw(context = canvas_context) {
            let worldscaler = (worldscale / 8)
            if (viewStyle == 3) {
                return
            }
            ld++
            let lineWidthstorage = context.lineWidth
            context.strokeStyle = this.color
    
            context.lineWidth = this.width
            if (viewStyle == 1) {
    
                context.lineWidth = 8 * (worldscaler)
                let grad = context.createRadialGradient(this.object.x, this.object.y, 0, this.object.x, this.object.y, this.hypotenuse() * 1);
                grad.addColorStop(0, nodecolors[this.object.type])
                grad.addColorStop(.10, nodecolors[this.object.type])
                grad.addColorStop(.90, nodecolors[this.target.type])
                grad.addColorStop(1, nodecolors[this.target.type])
                context.strokeStyle = grad
            }
            if (viewStyle == 2) {
    
                context.lineWidth = 1 * (worldscaler)
                let grad = context.createRadialGradient(this.object.x, this.object.y, 0, this.object.x, this.object.y, this.hypotenuse() * 1);
                grad.addColorStop(0, nodecolors[this.object.type] + "88")
                grad.addColorStop(.10, nodecolors[this.object.type] + "88")
                grad.addColorStop(.90, nodecolors[this.target.type] + "88")
                grad.addColorStop(1, nodecolors[this.target.type] + "88")
                context.strokeStyle = grad
            }
            if (viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
    
                context.lineWidth = 8 * (worldscaler)
                // let grad = context.createRadialGradient(this.object.x, this.object.y, 0, this.object.x, this.object.y, this.hypotenuse() * 1);
                // grad.addColorStop(0, this.object.parent.subcolor)
                // grad.addColorStop(1, this.target.parent.subcolor)
                context.strokeStyle = this.target.parent.subcolor
            }
            context.beginPath()
            context.moveTo(this.object.x, this.object.y)
            context.lineTo(this.target.x, this.target.y)
            context.stroke()
            context.lineWidth = lineWidthstorage
        }
    }
    class LineOPR {
        constructor(object, target, color, width) {
            this.object = object
            this.target = target
            this.color = color
            this.width = width
        }
        squareDistance() {
            let xdif = this.object.x - this.target.xavg
            let ydif = this.object.y - this.target.yavg
            let squareDistance = (xdif * xdif) + (ydif * ydif)
            return squareDistance
        }
        hypotenuse() {
            if (this.target.dead == 1 || this.object.dead == 1) {
                return 999999999999
            }
            let xdif = this.object.x - this.target.xavg
            let ydif = this.object.y - this.target.yavg
            let hypotenuse = (xdif * xdif) + (ydif * ydif)
            if (hypotenuse < 10000000 - 1) {
                if (hypotenuse > 1000) {
                    return squaretable[`${Math.round(10 * Math.round((hypotenuse * .1)))}`]
                } else {
                    return squaretable[`${Math.round(hypotenuse)}`]
                }
            } else {
                return Math.sqrt(hypotenuse)
            }
        }
        angle() {
            return Math.atan2(this.object.y - this.target.yavg, this.object.x - this.target.xavg)
        }
    
        draw(context = canvas_context) {
            let worldscaler = (worldscale / 8)
            if (viewStyle == 3) {
                return
            }
            ld++
            let lineWidthstorage = context.lineWidth
            context.strokeStyle = this.color
    
            context.lineWidth = this.width
            if (this.truewidth == 1) {
                context.lineWidth = 1
            }
            if (viewStyle == 1) {
    
                context.lineWidth = 8 * (worldscaler)
    
                if (this.truewidth == 1) {
                    context.lineWidth = 1
                }
                let grad = context.createRadialGradient(this.object.x, this.object.y, 0, this.object.x, this.object.y, this.hypotenuse() * 1);
                grad.addColorStop(0, nodecolors[this.object.type])
                grad.addColorStop(.10, nodecolors[this.object.type])
                grad.addColorStop(.90, nodecolors[this.target.type])
                grad.addColorStop(1, nodecolors[this.target.type])
                context.strokeStyle = grad
            }
            if (viewStyle == 2) {
    
                context.lineWidth = 1 * (worldscaler)
    
                if (this.truewidth == 1) {
                    context.lineWidth = 1
                }
                let grad = context.createRadialGradient(this.object.x, this.object.y, 0, this.object.x, this.object.y, this.hypotenuse() * 1);
                grad.addColorStop(0, nodecolors[this.object.type] + "88")
                grad.addColorStop(.10, nodecolors[this.object.type] + "88")
                grad.addColorStop(.90, nodecolors[this.target.type] + "88")
                grad.addColorStop(1, nodecolors[this.target.type] + "88")
                context.strokeStyle = grad
            }
            if (viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
    
                context.lineWidth = 8 * (worldscaler)
    
                if (this.truewidth == 1) {
                    context.lineWidth = 1
                }
                let grad = context.createRadialGradient(this.object.x, this.object.y, 0, this.object.x, this.object.y, this.hypotenuse() * 1);
                grad.addColorStop(0, this.object.parent.subcolor)
                grad.addColorStop(1, this.target.parent.subcolor)
                context.strokeStyle = grad
            }
            context.beginPath()
            context.moveTo(this.object.x, this.object.y)
            context.lineTo(this.target.xavg, this.target.yavg)
            context.stroke()
            context.lineWidth = lineWidthstorage
        }
    }
    class Triangle {
        constructor(x, y, color, length, fill = 0, strokeWidth = 0, leg1Ratio = 1, leg2Ratio = 1, heightRatio = 1) {
            this.x = x
            this.y = y
            this.color = color
            this.length = length
            this.x1 = this.x + this.length * leg1Ratio
            this.x2 = this.x - this.length * leg2Ratio
            this.tip = this.y - this.length * heightRatio
            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
            this.fill = fill
            this.stroke = strokeWidth
        }
        draw() {
            canvas_context.strokeStyle = this.color
            canvas_context.stokeWidth = this.stroke
            canvas_context.beginPath()
            canvas_context.moveTo(this.x, this.y)
            canvas_context.lineTo(this.x1, this.y)
            canvas_context.lineTo(this.x, this.tip)
            canvas_context.lineTo(this.x2, this.y)
            canvas_context.lineTo(this.x, this.y)
            if (this.fill == 1) {
                canvas_context.fill()
            }
            canvas_context.stroke()
            canvas_context.closePath()
        }
        isPointInside(point) {
            if (point.x <= this.x1) {
                if (point.y >= this.tip) {
                    if (point.y <= this.y) {
                        if (point.x >= this.x2) {
                            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                            this.basey = point.y - this.tip
                            this.basex = point.x - this.x
                            if (this.basex == 0) {
                                return true
                            }
                            this.slope = this.basey / this.basex
                            if (this.slope >= this.accept1) {
                                return true
                            } else if (this.slope <= this.accept2) {
                                return true
                            }
                        }
                    }
                }
            }
            return false
        }
    }
    class Rectangle {
        constructor(x, y, width, height, color, fill = 1, stroke = 0, strokeWidth = 1) {
            this.x = x
            this.y = y
            this.height = height
            this.width = width
            this.color = color
            this.xmom = 0
            this.ymom = 0
            this.stroke = stroke
            this.strokeWidth = strokeWidth
            this.fill = fill
        }
        draw() {
            canvas_context.fillStyle = this.color
            canvas_context.strokeStyle = this.color
            canvas_context.lineWidth = 1
            canvas_context.fillRect(this.x, this.y, this.width, this.height)
        }
        fill() {
            canvas_context.fillStyle = this.color
            canvas_context.lineWidth = 1
            canvas_context.fillRect(this.x, this.y, this.width, this.height)
        }
        move() {
            this.x += this.xmom
            this.y += this.ymom
        }
        isPointInside(point) {
            if (point.x >= this.x) {
                if (point.y >= this.y) {
                    if (point.x <= this.x + this.width) {
                        if (point.y <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
        doesPerimeterTouch(point) {
            if (point.x + point.radius >= this.x) {
                if (point.y + point.radius >= this.y) {
                    if (point.x - point.radius <= this.x + this.width) {
                        if (point.y - point.radius <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
    }
    class Circle {
        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
            this.x = x
            this.y = y
            this.radius = radius
            this.color = color
            this.body = {}
            this.body.x = this.x
            this.body.y = this.y
            this.xmom = xmom
            this.ymom = ymom
            this.friction = friction
            this.reflect = reflect
            this.strokeWidth = strokeWidth
            this.strokeColor = strokeColor
        }
    
        draw(context = canvas_context) {
            let worldscaler = worldscale / 8
            if (viewStyle == 3) {
                return
            }
            context.lineWidth = 2 * worldscaler
            context.strokeStyle = this.color
            context.beginPath();
            if (this.radius > 0) {
                if (viewStyle == 2) {
    
                    if (this.shrink != 1) {
    
                        this.radius = Math.max(worldscale - 1, 1)
    
                    }
                    let grad = context.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
                    grad.addColorStop(0, nodecolors[this.type])
                    grad.addColorStop(1, nodecolors[this.type] + "00")
                    context.fillStyle = grad
                    context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                    // context.fillStyle = this.color
                    context.fill()
    
    
    
                } else {
    
                    if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
    
                        if (this.shrink != 1) {
                            this.radius = 4 * (worldscaler)
                        }
                    }
                    context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                    context.fillStyle = this.color
                    if (viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
                        context.fillStyle = this.subcolor
                    }
                    if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
                        context.fill()
    
                    } else {
    
                        context.stroke();
                    }
                }
            } else {
                //////////////console.l\og("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
            }
        }
        move() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
        }
        unmove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x -= this.xmom
            this.y -= this.ymom
        }
        frictiveMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
            this.xmom *= this.friction
            this.ymom *= this.friction
        }
        frictiveunMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.xmom /= this.friction
            this.ymom /= this.friction
            this.x -= this.xmom
            this.y -= this.ymom
        }
        isPointInside(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                return true
            }
            return false
        }
        doesPerimeterTouch(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                return true
            }
            return false
        }
    }
    class CircleFill {
        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
            this.x = x
            this.y = y
            this.radius = radius
            this.color = color
            this.xmom = xmom
            this.ymom = ymom
            this.body = {}
            this.body.x = this.x
            this.body.y = this.y
            this.friction = friction
            this.reflect = reflect
            this.strokeWidth = strokeWidth
            this.strokeColor = strokeColor
        }
    
        draw(context = canvas_context) {
            context.lineWidth = 2
            context.strokeStyle = this.color
            context.beginPath();
            if (this.radius > 0) {
                context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
    
                let grad = context.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 1);
    
                grad.addColorStop(0, this.color + "90")
                grad.addColorStop(1, this.color + "00")
                context.fillStyle = grad
                // context.stroke();
                context.fill();
    
    
            } else {
                //////////////console.l\og("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
            }
        }
        move() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
        }
        unmove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x -= this.xmom
            this.y -= this.ymom
        }
        frictiveMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
            this.xmom *= this.friction
            this.ymom *= this.friction
        }
        frictiveunMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.xmom /= this.friction
            this.ymom /= this.friction
            this.x -= this.xmom
            this.y -= this.ymom
        }
        isPointInside(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                return true
            }
            return false
        }
        doesPerimeterTouch(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                return true
            }
            return false
        }
    }
    class CircleCap {
        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
            this.x = x
            this.y = y
            this.radius = radius
            this.color = color
            this.xmom = xmom
            this.ymom = ymom
            this.friction = friction
            this.reflect = reflect
            this.strokeWidth = strokeWidth
            this.strokeColor = strokeColor
        }
    
        draw(context = canvas_context) {
            context.lineWidth = 2
            context.strokeStyle = this.color
            context.beginPath();
            if (this.radius > 0) {
                context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
    
                // let grad = context.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius*1.5);
    
                // grad.addColorStop(0, this.color)
                // grad.addColorStop(1, "#00000000")
                context.fillStyle = this.color
                // context.stroke();
                context.fill();
    
    
            } else {
                //////////////console.l\og("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
            }
        }
        move() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
        }
        unmove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x -= this.xmom
            this.y -= this.ymom
        }
        frictiveMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
            this.xmom *= this.friction
            this.ymom *= this.friction
        }
        frictiveunMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.xmom /= this.friction
            this.ymom /= this.friction
            this.x -= this.xmom
            this.y -= this.ymom
        }
        isPointInside(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                return true
            }
            return false
        }
        doesPerimeterTouch(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                return true
            }
            return false
        }
    }
    class Polygon {
        constructor(x, y, size, color, sides = 3, xmom = 0, ymom = 0, angle = 0, reflect = 0) {
            // if (sides < 2) {
            //     sides = 2
            // }
            this.reflect = reflect
            this.xmom = xmom
            this.ymom = ymom
            this.body = new Circle(x, y, size - (size * .293), "transparent")
            this.nodes = []
            this.angle = angle
            this.size = size
            this.color = color
            this.angleIncrement = (Math.PI * 2) / sides
            this.sides = sides
            for (let t = 0; t < sides; t++) {
                let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                this.nodes.push(node)
                this.angle += this.angleIncrement
            }
        }
        isPointInside(point) { // rough approximation
            this.body.radius = this.size - (this.size * .293)
            if (this.sides <= 2) {
                return false
            }
            this.areaY = point.y - this.body.y
            this.areaX = point.x - this.body.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.body.radius * this.body.radius)) {
                return true
            }
            return false
        }
        move() {
            if (this.reflect == 1) {
                if (this.body.x > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.body.y > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.body.x < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.body.y < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.body.x += this.xmom
            this.body.y += this.ymom
        }
    
        draw(context = canvas_context) {
            if (viewStyle == 3) {
                return
            }
    
            if (viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
                this.body.subcolor = this.parent.subcolor
                this.body.radius = 2 * (worldscaler)
                this.body.type = this.type
                this.body.draw(context)
                return
            }
    
            if (viewStyle == 1 || viewStyle == 2) {
                this.body.color = nodecolors[this.type]
                this.body.radius = 2 * (worldscaler)
                this.body.type = this.type
                this.body.draw(context)
                return
            }
            this.angleIncrement = (Math.PI * 2) / this.sides
            this.body.radius = this.size - (this.size * .293)
            if (this.first != 1) {
                if (this.sides == 2) {
                    this.angleIncrement * .5
                    this.nodes = []
                    for (let t = 0; t < this.sides * 2; t++) {
                        let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                        this.nodes.push(node)
                        this.angle += this.angleIncrement
                    }
                    this.first = 1
                } else {
    
                    this.nodes = []
                    for (let t = 0; t < this.sides; t++) {
                        let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                        this.nodes.push(node)
                        this.angle += this.angleIncrement
                    }
                    this.first = 1
                }
    
            } else {
    
                if (this.sides == 2) {
    
                } else {
    
                    for (let t = 0; t < this.sides; t++) {
                        this.nodes[t].x = this.body.x + (this.size * (Math.cos(this.angle)))
                        this.nodes[t].y = this.body.y + (this.size * (Math.sin(this.angle)))
                        this.angle += this.angleIncrement
                    }
                }
    
            }
    
            if (this.sides == 1) {
                if (this.done != 1) {
    
                    let d = new SX(this.body.x, this.body.y, this.color, this.size, this.angle)
                    let r = new SX(this.body.x, this.body.y, this.color, this.size, this.angle + (Math.PI / 4))
                    this.xd = d
                    this.xr = r
                    this.done = 1
                    this.xd.draw(this.angle, context)
                    this.xr.draw(this.angle + (Math.PI / 4), context)
                } else {
    
                    this.xd.x = this.body.x
                    this.xd.y = this.body.y
                    this.xr.x = this.body.x
                    this.xr.y = this.body.y
                    this.xd.draw(this.angle, context)
                    this.xr.draw(this.angle + (Math.PI / 4), context)
                }
    
            } else if (this.sides == 2) {
    
                if (this.done != 1) {
    
                    let d = new X(this.body.x, this.body.y, this.color, this.size, this.angle)
                    this.xd = d
                    this.done = 1
                    this.xd.draw(this.angle, context)
                } else {
    
                    this.xd.x = this.body.x
                    this.xd.y = this.body.y
                    this.xd.draw(this.angle, context)
                }
            } else {
    
                context.beginPath()
                context.moveTo(this.nodes[0].x, this.nodes[0].y)
                for (let t = 1; t < this.nodes.length; t++) {
                    context.lineTo(this.nodes[t].x, this.nodes[t].y)
                }
                context.closePath()
            }
            // canvas_context.lineTo(this.nodes[0].x, this.nodes[0].y)
            // canvas_context.fill()
            context.strokeStyle = this.color
            context.fillStyle = this.color
            context.lineWidth = Math.max(2 * worldscaler, 1)
            context.stroke()
        }
    }
    class Shape {
        constructor(shapes) {
            this.shapes = shapes
        }
        draw() {
            for (let t = 0; t < this.shapes.length; t++) {
                this.shapes[t].draw()
            }
        }
        isPointInside(point) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (this.shapes[t].isPointInside(point)) {
                    return true
                }
            }
            return false
        }
        doesPerimeterTouch(point) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (this.shapes[t].doesPerimeterTouch(point)) {
                    return true
                }
            }
            return false
        }
        innerShape(point) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (this.shapes[t].doesPerimeterTouch(point)) {
                    return this.shapes[t]
                }
            }
            return false
        }
        isInsideOf(box) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (box.isPointInside(this.shapes[t])) {
                    return true
                }
            }
            return false
        }
        adjustByFromDisplacement(x, y) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (typeof this.shapes[t].fromRatio == "number") {
                    this.shapes[t].x += x * this.shapes[t].fromRatio
                    this.shapes[t].y += y * this.shapes[t].fromRatio
                }
            }
        }
        adjustByToDisplacement(x, y) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (typeof this.shapes[t].toRatio == "number") {
                    this.shapes[t].x += x * this.shapes[t].toRatio
                    this.shapes[t].y += y * this.shapes[t].toRatio
                }
            }
        }
        mixIn(arr) {
            for (let t = 0; t < arr.length; t++) {
                for (let k = 0; k < arr[t].shapes.length; k++) {
                    this.shapes.push(arr[t].shapes[k])
                }
            }
        }
        push(object) {
            this.shapes.push(object)
        }
    }
    
    class Spring {
        constructor(x, y, radius, color, body = 0, length = 1, gravity = 0, width = 1) {
            if (body == 0) {
                this.body = new Circle(x, y, radius, color)
                this.anchor = new Circle(x, y, radius, color)
                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                this.length = length
            } else {
                this.body = body
                this.anchor = new Circle(x, y, radius, color)
                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                this.length = length
            }
            this.gravity = gravity
            this.width = width
        }
        balance() {
            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
            if (this.beam.hypotenuse() < this.length) {
                this.body.xmom += (this.body.x - this.anchor.x) / this.length
                this.body.ymom += (this.body.y - this.anchor.y) / this.length
                this.anchor.xmom -= (this.body.x - this.anchor.x) / this.length
                this.anchor.ymom -= (this.body.y - this.anchor.y) / this.length
            } else {
                this.body.xmom -= (this.body.x - this.anchor.x) / this.length
                this.body.ymom -= (this.body.y - this.anchor.y) / this.length
                this.anchor.xmom += (this.body.x - this.anchor.x) / this.length
                this.anchor.ymom += (this.body.y - this.anchor.y) / this.length
            }
            let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
            let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
            this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
            this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
            this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
            this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
        }
        draw() {
            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
            this.beam.draw()
            this.body.draw()
            this.anchor.draw()
        }
        move() {
            this.anchor.ymom += this.gravity
            this.anchor.move()
        }
    
    }
    class SpringOP {
        constructor(body, anchor, length, width = 3, color = body.color) {
            this.body = body
            this.anchor = anchor
            this.beam = new LineOP(body, anchor, color, width)
            this.length = length
        }
        balance() {
            if (this.beam.hypotenuse() < this.length) {
                this.body.xmom += ((this.body.x - this.anchor.x) / this.length)
                this.body.ymom += ((this.body.y - this.anchor.y) / this.length)
                this.anchor.xmom -= ((this.body.x - this.anchor.x) / this.length)
                this.anchor.ymom -= ((this.body.y - this.anchor.y) / this.length)
            } else if (this.beam.hypotenuse() > this.length) {
                this.body.xmom -= (this.body.x - this.anchor.x) / (this.length)
                this.body.ymom -= (this.body.y - this.anchor.y) / (this.length)
                this.anchor.xmom += (this.body.x - this.anchor.x) / (this.length)
                this.anchor.ymom += (this.body.y - this.anchor.y) / (this.length)
            }
    
            let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
            let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
            this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
            this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
            this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
            this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
        }
        draw() {
            this.beam.draw()
        }
        move() {
            //movement of SpringOP objects should be handled separate from their linkage, to allow for many connections, balance here with this object, move nodes independently
        }
    }
    
    class Color {
        constructor(baseColor, red = -1, green = -1, blue = -1, alpha = 1) {
            this.hue = baseColor
            if (red != -1 && green != -1 && blue != -1) {
                this.r = red
                this.g = green
                this.b = blue
                if (alpha != 1) {
                    if (alpha < 1) {
                        this.alpha = alpha
                    } else {
                        this.alpha = alpha / 255
                        if (this.alpha > 1) {
                            this.alpha = 1
                        }
                    }
                }
                if (this.r > 255) {
                    this.r = 255
                }
                if (this.g > 255) {
                    this.g = 255
                }
                if (this.b > 255) {
                    this.b = 255
                }
                if (this.r < 0) {
                    this.r = 0
                }
                if (this.g < 0) {
                    this.g = 0
                }
                if (this.b < 0) {
                    this.b = 0
                }
            } else {
                this.r = 0
                this.g = 0
                this.b = 0
            }
        }
        normalize() {
            if (this.r > 255) {
                this.r = 255
            }
            if (this.g > 255) {
                this.g = 255
            }
            if (this.b > 255) {
                this.b = 255
            }
            if (this.r < 0) {
                this.r = 0
            }
            if (this.g < 0) {
                this.g = 0
            }
            if (this.b < 0) {
                this.b = 0
            }
        }
        randomLight() {
            var letters = '0123456789ABCDEF';
            var hash = '#';
            for (var i = 0; i < 6; i++) {
                hash += letters[(Math.floor(seedRandom() * 12) + 4)];
            }
            var color = new Color(hash, 55 + seedRandom() * 200, 55 + seedRandom() * 200, 55 + seedRandom() * 200)
            return color;
        }
        randomDark() {
            var letters = '0123456789ABCDEF';
            var hash = '#';
            for (var i = 0; i < 6; i++) {
                hash += letters[(Math.floor(seedRandom() * 12))];
            }
            var color = new Color(hash, seedRandom() * 200, seedRandom() * 200, seedRandom() * 200)
            return color;
        }
        random() {
            var letters = '0123456789ABCDEF';
            var hash = '#';
            for (var i = 0; i < 6; i++) {
                hash += letters[(Math.floor(seedRandom() * 16))];
            }
            var color = new Color(hash, seedRandom() * 255, seedRandom() * 255, seedRandom() * 255)
            return color;
        }
    }
    class Softbody { //buggy, spins in place
        constructor(x, y, radius, color, members = 10, memberLength = 5, force = 10, gravity = 0) {
            this.springs = []
            this.pin = new Circle(x, y, radius, color)
            this.spring = new Spring(x, y, radius, color, this.pin, memberLength, gravity)
            this.springs.push(this.spring)
            for (let k = 0; k < members; k++) {
                this.spring = new Spring(x, y, radius, color, this.spring.anchor, memberLength, gravity)
                if (k < members - 1) {
                    this.springs.push(this.spring)
                } else {
                    this.spring.anchor = this.pin
                    this.springs.push(this.spring)
                }
            }
            this.forceConstant = force
            this.centroid = new Point(0, 0)
        }
        circularize() {
            this.xpoint = 0
            this.ypoint = 0
            for (let s = 0; s < this.springs.length; s++) {
                this.xpoint += (this.springs[s].anchor.x / this.springs.length)
                this.ypoint += (this.springs[s].anchor.y / this.springs.length)
            }
            this.centroid.x = this.xpoint
            this.centroid.y = this.ypoint
            this.angle = 0
            this.angleIncrement = (Math.PI * 2) / this.springs.length
            for (let t = 0; t < this.springs.length; t++) {
                this.springs[t].body.x = this.centroid.x + (Math.cos(this.angle) * this.forceConstant)
                this.springs[t].body.y = this.centroid.y + (Math.sin(this.angle) * this.forceConstant)
                this.angle += this.angleIncrement
            }
        }
        balance() {
            for (let s = this.springs.length - 1; s >= 0; s--) {
                this.springs[s].balance()
            }
            this.xpoint = 0
            this.ypoint = 0
            for (let s = 0; s < this.springs.length; s++) {
                this.xpoint += (this.springs[s].anchor.x / this.springs.length)
                this.ypoint += (this.springs[s].anchor.y / this.springs.length)
            }
            this.centroid.x = this.xpoint
            this.centroid.y = this.ypoint
            for (let s = 0; s < this.springs.length; s++) {
                this.link = new Line(this.centroid.x, this.centroid.y, this.springs[s].anchor.x, this.springs[s].anchor.y, 0, "transparent")
                if (this.link.hypotenuse() != 0) {
                    this.springs[s].anchor.xmom += (((this.springs[s].anchor.x - this.centroid.x) / (this.link.hypotenuse()))) * this.forceConstant
                    this.springs[s].anchor.ymom += (((this.springs[s].anchor.y - this.centroid.y) / (this.link.hypotenuse()))) * this.forceConstant
                }
            }
            for (let s = 0; s < this.springs.length; s++) {
                this.springs[s].move()
            }
            for (let s = 0; s < this.springs.length; s++) {
                this.springs[s].draw()
            }
        }
    }
    class Observer {
        constructor(x, y, radius, color, range = 100, rays = 10, angle = (Math.PI * .125)) {
            this.body = new Circle(x, y, radius, color)
            this.color = color
            this.ray = []
            this.rayrange = range
            this.globalangle = Math.PI
            this.gapangle = angle
            this.currentangle = 0
            this.obstacles = []
            this.raymake = rays
        }
        beam() {
            this.currentangle = this.gapangle / 2
            for (let k = 0; k < this.raymake; k++) {
                this.currentangle += (this.gapangle / Math.ceil(this.raymake / 2))
                let ray = new Circle(this.body.x, this.body.y, 1, "white", (((Math.cos(this.globalangle + this.currentangle)))), (((Math.sin(this.globalangle + this.currentangle)))))
                ray.collided = 0
                ray.lifespan = this.rayrange - 1
                this.ray.push(ray)
            }
            for (let f = 0; f < this.rayrange; f++) {
                for (let t = 0; t < this.ray.length; t++) {
                    if (this.ray[t].collided < 1) {
                        this.ray[t].move()
                        for (let q = 0; q < this.obstacles.length; q++) {
                            if (this.obstacles[q].isPointInside(this.ray[t])) {
                                this.ray[t].collided = 1
                            }
                        }
                    }
                }
            }
        }
        draw() {
            this.beam()
            this.body.draw()
            canvas_context.lineWidth = 1
            canvas_context.fillStyle = this.color
            canvas_context.strokeStyle = this.color
            canvas_context.beginPath()
            canvas_context.moveTo(this.body.x, this.body.y)
            for (let y = 0; y < this.ray.length; y++) {
                canvas_context.lineTo(this.ray[y].x, this.ray[y].y)
                canvas_context.lineTo(this.body.x, this.body.y)
            }
            canvas_context.stroke()
            canvas_context.fill()
            this.ray = []
        }
    }
    
    function loop() {
        runsnap++;
    
        // if (keysPressed['m']) {
        //     magdisplay *= -1;
        //     keysPressed['m'] = false;
        // }
    
        if (keysPressed['o']) {
            runcount--;
            if (runcount <= 1) {
                runcount = 1;
            }
        }
    
        if (keysPressed['i']) {
            runcount = 10;
        }
    
        if (keysPressed[' ']) {
            // Do something if needed
        }
    
        if (runsnap % runcount === 0) {
            if (keysPressed['p']) {
                runcount++;
                if (runcount >= 1000) {
                    runcount = 1000;
                }
            }
            worldtime++
            main();
        }
    
        requestAnimationFrame(loop);
    }
    
    // Start the loop
    function setUp(canvas_pass, style = "#000000") {
        canvas = canvas_pass
        // video_recorder = new CanvasCaptureToWEBM(canvas, 4500000);
        canvas_context = canvas.getContext("2d", { willReadFrequently: true })
        canvas.style.background = style
    
        requestAnimationFrame(loop);
    
        // window.setInterval(function() {
        //     runsnap++
        //     if(keysPressed['m']){
        //         magdisplay *= -1
    
        //     keysPressed['m'] = false
        //     }
        //     if(keysPressed['o']){
        //         runcount--
        //         if(runcount <= 1){
        //             runcount = 1
        //         }
        //     }
        //     if(keysPressed['i']){
    
        //         runcount = 10
        //     }
        //     if(keysPressed[' ']){
        //     }
        //     if(runsnap%runcount == 0){
        //         if(keysPressed['p']){
        //             runcount++
        //             if(runcount >= 1000){
        //                 runcount = 1000
        //             }
        //         }
        //         main()
        //     }
        // }, 1)
        document.addEventListener('keydown', (event) => {
            keysPressed[event.key] = true;
        });
        document.addEventListener('keyup', (event) => {
            delete keysPressed[event.key];
        });
        window.addEventListener('pointerdown', e => {
            FLEX_engine = canvas.getBoundingClientRect();
            XS_engine = e.clientX - FLEX_engine.left;
            YS_engine = e.clientY - FLEX_engine.top;
            TIP_engine.x = XS_engine
            TIP_engine.y = YS_engine
            TIP_engine.body = TIP_engine
            // organeo.genes[0].body.x += 10
            if (start == 0) {
                UI.check(TIP_engine)
            }else{
              pu.check(TIP_engine)
            }
            // example usage: if(object.isPointInside(TIP_engine)){ take action }
            window.addEventListener('pointermove', stupidcontinued_stimuli);
        });
    
        window.addEventListener('pointermove', continued_stimuli);
        window.addEventListener('pointerup', e => {
            window.removeEventListener("pointermove", stupidcontinued_stimuli);
        })
    
        function continued_stimuli(e) {
            FLEX_engine = canvas.getBoundingClientRect();
            XS_engine = e.clientX - FLEX_engine.left;
            YS_engine = e.clientY - FLEX_engine.top;
            TIP_engine.x = XS_engine
            TIP_engine.y = YS_engine
            TIP_engine.body = TIP_engine
    
    
        }
    
        function stupidcontinued_stimuli(e) {
            FLEX_engine = canvas.getBoundingClientRect();
            XS_engine = e.clientX - FLEX_engine.left;
            YS_engine = e.clientY - FLEX_engine.top;
            TIP_engine.x = XS_engine
            TIP_engine.y = YS_engine
            TIP_engine.body = TIP_engine
            if (start == 0) {
                UI.stupidCheck(TIP_engine)
            }
        }
    }
    
    function gamepad_control(object, speed = 1) { // basic control for objects using the controler
        //         //////////////console.l\og(gamepadAPI.axesStatus[1]*gamepadAPI.axesStatus[0]) //debugging
        if (typeof object.body != 'undefined') {
            if (typeof(gamepadAPI.axesStatus[1]) != 'undefined') {
                if (typeof(gamepadAPI.axesStatus[0]) != 'undefined') {
                    object.body.x += (gamepadAPI.axesStatus[0] * speed)
                    object.body.y += (gamepadAPI.axesStatus[1] * speed)
                }
            }
        } else if (typeof object != 'undefined') {
            if (typeof(gamepadAPI.axesStatus[1]) != 'undefined') {
                if (typeof(gamepadAPI.axesStatus[0]) != 'undefined') {
                    object.x += (gamepadAPI.axesStatus[0] * speed)
                    object.y += (gamepadAPI.axesStatus[1] * speed)
                }
            }
        }
    }
    
    function control(object, speed = 1) { // basic control for objects
        if (typeof object.body != 'undefined') {
            if (keysPressed['w']) {
                object.body.y -= speed
            }
            if (keysPressed['d']) {
                object.body.x += speed
            }
            if (keysPressed['s']) {
                object.body.y += speed
            }
            if (keysPressed['a']) {
                object.body.x -= speed
            }
        } else if (typeof object != 'undefined') {
            if (keysPressed['w']) {
                object.y -= speed
            }
            if (keysPressed['d']) {
                object.x += speed
            }
            if (keysPressed['s']) {
                object.y += speed
            }
            if (keysPressed['a']) {
                object.x -= speed
            }
        }
    }
    
    function getRandomLightColor() { // random color that will be visible on  black background
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[(Math.floor(Math.random() * 12) + 4)];
        }
        return color;
    }
    
    function getRandomColor() { // random color
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[(Math.floor(Math.random() * 16) + 0)];
        }
        return color;
    }
    
    function getRandomDarkColor() { // color that will be visible on a black background
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[(Math.floor(Math.random() * 12))];
        }
        return color;
    }
    
    function castBetween(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
        let limit = granularity
        let shape_array = []
        for (let t = 0; t < limit; t++) {
            let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
            circ.toRatio = t / limit
            circ.fromRatio = (limit - t) / limit
            shape_array.push(circ)
        }
        return (new Shape(shape_array))
    }
    
    function castBetweenPoints(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
        let limit = granularity
        let shape_array = []
        for (let t = 0; t < limit; t++) {
            let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
            circ.toRatio = t / limit
            circ.fromRatio = (limit - t) / limit
            shape_array.push(circ)
        }
        return shape_array
    }
    
    class Disang {
        constructor(dis, ang) {
            this.dis = dis
            this.angle = ang
        }
    }
    
    class BezierHitbox {
        constructor(x, y, cx, cy, ex, ey, color = "red") { // this function takes a starting x,y, a control point x,y, and a end point x,y
            this.color = color
            this.x = x
            this.y = y
            this.cx = cx
            this.cy = cy
            this.ex = ex
            this.ey = ey
            this.metapoint = new Circle((x + cx + ex) / 3, (y + cy + ey) / 3, 3, "#FFFFFF")
            this.granularity = 100
            this.body = [...castBetweenPoints((new Point(this.x, this.y)), (new Point(this.ex, this.ey)), this.granularity, 0)]
    
            let angle = (new Line(this.x, this.y, this.ex, this.ey)).angle()
    
            this.angles = []
            for (let t = 0; t < this.granularity; t++) {
                this.angles.push(angle)
            }
            for (let t = 0; t <= 1; t += 1 / this.granularity) {
                this.body.push(this.getQuadraticXY(t))
                this.angles.push(this.getQuadraticAngle(t))
            }
            this.hitbox = []
            for (let t = 0; t < this.body.length; t++) {
                let link = new LineOP(this.body[t], this.metapoint)
                let disang = new Disang(link.hypotenuse(), link.angle() + (Math.PI * 2))
                this.hitbox.push(disang)
            }
            this.constructed = 1
        }
        isPointInside(point) {
            let link = new LineOP(point, this.metapoint)
            let angle = (link.angle() + (Math.PI * 2))
            let dis = link.hypotenuse()
            for (let t = 1; t < this.hitbox.length; t++) {
                if (Math.abs(this.hitbox[t].angle - this.hitbox[t - 1].angle) > 1) {
                    continue
                }
                if (angle.between(this.hitbox[t].angle, this.hitbox[t - 1].angle)) {
                    if (dis < (this.hitbox[t].dis + this.hitbox[t - 1].dis) * .5) {
                        return true
                    }
                }
            }
            return false
        }
        doesPerimeterTouch(point) {
            let link = new LineOP(point, this.metapoint)
            let angle = (link.angle() + (Math.PI * 2))
            let dis = link.hypotenuse()
            for (let t = 1; t < this.hitbox.length; t++) {
                if (Math.abs(this.hitbox[t].angle - this.hitbox[t - 1].angle) > 1) {
                    continue
                }
                if (angle.between(this.hitbox[t].angle, this.hitbox[t - 1].angle)) {
                    if (dis < ((this.hitbox[t].dis + this.hitbox[t - 1].dis) * .5) + point.radius) {
                        return this.angles[t]
                    }
                }
            }
            return false
        }
        draw() {
            this.metapoint.draw()
            let tline = new Line(this.x, this.y, this.ex, this.ey, this.color, 3)
            tline.draw()
            canvas_context.beginPath()
            this.median = new Point((this.x + this.ex) * .5, (this.y + this.ey) * .5)
            let angle = (new LineOP(this.median, this.metapoint)).angle()
            let dis = (new LineOP(this.median, this.metapoint)).hypotenuse()
            canvas_context.bezierCurveTo(this.x, this.y, this.cx - (Math.cos(angle) * dis * .38), this.cy - (Math.sin(angle) * dis * .38), this.ex, this.ey)
    
            canvas_context.fillStyle = this.color
            canvas_context.strokeStyle = this.color
            canvas_context.lineWidth = 1
            canvas_context.stroke()
        }
        getQuadraticXY(t) {
            return new Point((((1 - t) * (1 - t)) * this.x) + (2 * (1 - t) * t * this.cx) + (t * t * this.ex), (((1 - t) * (1 - t)) * this.y) + (2 * (1 - t) * t * this.cy) + (t * t * this.ey))
        }
        getQuadraticAngle(t) {
            var dx = 2 * (1 - t) * (this.cx - this.x) + 2 * t * (this.ex - this.cx);
            var dy = 2 * (1 - t) * (this.cy - this.y) + 2 * t * (this.ey - this.cy);
            return -Math.atan2(dx, dy) + 0.5 * Math.PI;
        }
    }
    
    Number.prototype.between = function(a, b, inclusive) {
        var min = Math.min(a, b),
            max = Math.max(a, b);
        return inclusive ? this >= min && this <= max : this > min && this < max;
    }
    
    // if( n < 3 && n > 1){
    
    // }
    // if((n).between(1,3)){
    
    // }
    
    
    let setup_canvas = document.getElementById('canvas') //getting canvas from document
    
    // let secretcanvas = document.getElementById('secretcanvas') //getting canvas from document
    
    // secretcanvas_context = secretcanvas.getContext("2d", { willReadFrequently: true }) 
    setUp(setup_canvas) // setting up canvas refrences, starting timer. 
    
    // object instantiation and creation happens here 
    // class PolygonSorter {
    //     constructor(points) {
    //         this.points = points;
    //         this.hull = this.computeConcavePolygon();
    //     }
    
    //     computeConcavePolygon() {
    //         // Ensure we work on a copy of the points
    //         const points = this.points.slice();
    
    //         // Sort points by their position (you may want a specific order)
    //         points.sort((a, b) => a.x - b.x || a.y - b.y);
    
    //         // Start with the first point
    //         const polygon = [points[0]];
    
    //         // Iterate through the points to create a non-crossing concave shape
    //         for (let i = 1; i < points.length; i++) {
    //             const point = points[i];
    
    //             // Check for intersection and add the point
    //             while (polygon.length > 1 && this.doesIntersect(polygon[polygon.length - 2], polygon[polygon.length - 1], polygon[polygon.length - 1], point)) {
    //                 polygon.pop(); // Remove last point if it causes intersection
    //             }
    //             polygon.push(point);
    //         }
    
    //         // Optionally, close the polygon by connecting back to the starting point
    //         if (polygon.length > 2 && !this.doesIntersect(polygon[polygon.length - 1], polygon[0], polygon[polygon.length - 1], polygon[0])) {
    //             polygon.push(polygon[0]); // Close the polygon if it doesn't cause an intersection
    //         }
    
    //         return polygon;
    //     }
    
    //     doesIntersect(p1, q1, p2, q2) {
    //         // Helper function to check if two segments intersect
    //         return this.orientation(p1, q1, p2) !== this.orientation(p1, q1, q2) &&
    //                this.orientation(p2, q2, p1) !== this.orientation(p2, q2, q1);
    //     }
    
    //     orientation(p, q, r) {
    //         const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    //         return val === 0 ? 0 : (val > 0 ? 1 : 2); // collinear, clockwise, counterclockwise
    //     }
    
    //     minimizeArea(polygon) {
    //         // Implement a strategy to minimize the area of the polygon
    //         // This can involve a more complex triangulation method if needed
    //         return polygon; // Placeholder: Return the input polygon for now
    //     }
    
    //     getSortedPoints() {
    //         return this.minimizeArea(this.hull);
    //     }
    // }
    class PolygonSorter {
        constructor(points) {
            this.points = points;
            this.hull = this.points
        }
    
        // Function to calculate the centroid of the points
        calculateCentroid() {
            const numPoints = this.points.length;
            const sum = this.points.reduce((acc, point) => {
                acc.x += point.x;
                acc.y += point.y;
                return acc;
            }, {
                x: 0,
                y: 0
            });
    
            return {
                x: sum.x / numPoints,
                y: sum.y / numPoints
            };
        }
    
        // Function to calculate the angle between the point and the centroid
        calculateAngle(point, centroid) {
            return Math.atan2(point.y - centroid.y, point.x - centroid.x);
        }
    
        // Function to sort points based on their angle relative to the centroid
        sortPointsByAngle() {
            const centroid = this.calculateCentroid();
            this.points.sort((a, b) => {
                const angleA = this.calculateAngle(a, centroid);
                const angleB = this.calculateAngle(b, centroid);
                return angleA - angleB; // Sort by angle in ascending order
            });
            return this.points; // Return the sorted array
        }
    }
    
    
    
    class PolygonDrawer {
        constructor(points, color = '#000000', width = 3) {
            this.points = points; // Array of Point objects
            //////////////console.l\og(points)
            this.color = color;
            this.width = width;
            this.hull = this.points
        }
    
    
        // Function to calculate the centroid of the points
        calculateCentroid() {
            const numPoints = this.points.length;
            const sum = this.points.reduce((acc, point) => {
                acc.x += point.x;
                acc.y += point.y;
                return acc;
            }, {
                x: 0,
                y: 0
            });
    
            return {
                x: sum.x / numPoints,
                y: sum.y / numPoints
            };
        }
    
        // Function to calculate the angle between the point and the centroid
        calculateAngle(point, centroid) {
            return Math.atan2(point.y - centroid.y, point.x - centroid.x);
        }
    
        // Function to sort points based on their angle relative to the centroid
        sortPointsByAngle() {
            const centroid = this.calculateCentroid();
            this.points.sort((a, b) => {
                const angleA = this.calculateAngle(a, centroid);
                const angleB = this.calculateAngle(b, centroid);
                return angleA - angleB; // Sort by angle in ascending order
            });
            return this.points; // Return the sorted array
        }
        drawHull() {
            if (this.liner != 1) {
    
                this.links = []
                for (let i = 0; i < this.hull.length; i++) {
                    const start = this.hull[i];
                    const end = this.hull[(i + 1) % this.hull.length]; // Wrap around to the first point
                    const lineOp = new LineOP(start, end, this.color, this.width);
                    lineOp.draw();
                    this.links.push(lineOp)
                }
            }
            this.liner = 1
    
            this.sums = [0, 0, 0, 0]
            let f = 0
    
            for (let t = 0; t < people.length; t++) {
                if (isPointInPolygon(this.hull, people[t].body)) {
                    this.sums[people[t].type]++
                    f++
                }
            }
    
            // Determine the color based on which sum is maximum
            let calccolor;
            //////////////console.l\og(this.sums)
            const maxSum = Math.max(...this.sums);
            const maxIndex = this.sums.indexOf(maxSum);
    
            if (f != groups[groupi]) {
                calccolor = '#88888888'
                this.t = -1
            } else {
    
                if (maxIndex === 0) {
                    calccolor = '#ff000040';
                    this.t = 0
                } else if (maxIndex === 1) {
                    this.t = 1
                    calccolor = '#00ff0040';
                } else if (maxIndex === 2) {
                    this.t = 2
                    calccolor = '#0000ff40';
                } else if (maxIndex === 3) {
                    this.t = 3
                    calccolor = '#ffCc0040';
                } else {
                    this.t = -1
                    calccolor = 'white'; // Replace with a color for index 2 and 3 if needed
                }
    
            }
    
            const maxCount = this.sums.filter(sum => sum === maxSum).length;
    
            if (maxCount > 1) {
                calccolor = '#88888888'; // Set to gray if there are ties
            }
    
    
            fillPolygon(canvas_context, this.hull, calccolor)
        }
    }
    
    function fillPolygon(ctx, points, color) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
    
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
    
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
    }
    
    class People {
        constructor(x, y, colorValue) {
            this.type = colorValue
            this.body = new Circle(x, y, 50, "white");
            this.colors = ['red', '#00ff00', 'blue', 'yellow'];
    
            this.body.color = this.colors[colorValue % 4];
        }
    
        // Check if the circle is on the line
        isCircleOnLine(link) {
            this.body.radius = 50
            const x = this.body.x;
            const y = this.body.y;
            const radius = this.body.radius;
    
            // Line is defined by two points (x1, y1) and (x2, y2)
            // const [x1, y1, x2, y2] = link;
            const x1 = link.object.x
            const x2 = link.target.x
            const y1 = link.object.y
            const y2 = link.target.y
    
            // Line equation: Ax + By + C = 0
            const A = y2 - y1;
            const B = x1 - x2;
            const C = x2 * y1 - x1 * y2;
    
            // Distance from circle center to the line
            const distance = Math.abs(A * x + B * y + C) / Math.sqrt(A * A + B * B);
    
            // Check if the distance is less than or equal to the radius
            return distance <= radius;
        }
        draw() {
            this.body.radius = 10
            this.body.draw()
        }
    }
    let hulls = []
    let hull = []
    let people = []
    let peo = []
    
    let groups = [3, 4, 5, 6, 10, 12]
    
    let diff = 2
    let groupi = 3
    for (let t = 0; t < 60; t++) {
        peo.push(t % diff)
    }
    
    for (let t = 0; t < 60; t++) {
        let per = new People(100 + (100 * (t % 10)), 100 + (100 * Math.floor(t / 10)), peo[t])
    
        people.push(per)
    }
    
    
    
    
    let h1 = {}
    let sure = {}
    
    function isPointInPolygon(points, testPoint) {
        const x = testPoint.x;
        const y = testPoint.y;
        let inside = false;
    
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
            const xi = points[i].x;
            const yi = points[i].y;
            const xj = points[j].x;
            const yj = points[j].y;
    
            const intersect = ((yi > y) !== (yj > y)) &&
                (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    
            if (intersect) {
                inside = !inside;
            }
        }
    
        return inside;
    }
    
    function arePointsOverlapping(a, b, c, d, e, f, g, h) {
        // Create an array of points from the provided coordinates
        const points = [{
                x: a,
                y: b
            }, // First point
            {
                x: c,
                y: d
            }, // Second point
            {
                x: e,
                y: f
            }, // Third point
            {
                x: g,
                y: h
            } // Fourth point
        ];
    
        ////////////////////////////////////////console.log(points)
        // Use a Set to track unique positions
        const uniquePositions = new Set();
    
        for (const point of points) {
            // Create a unique key for each point based on its x and y values
            const key = `${point.x},${point.y}`;
    
            // If the key is already in the Set, return true (overlapping point found)
            if (uniquePositions.has(key)) {
                return true;
            }
    
            // Add the key to the Set
            uniquePositions.add(key);
        }
    
        // No overlapping points found
        return false;
    }
    // returns true if the line from (a,b)->(c,d) intersects with (p,q)->(r,s)
    function intersects(a, b, c, d, p, q, r, s) {
        var det, gamma, lambda;
        a = Math.round(a)
        b = Math.round(b)
        c = Math.round(c)
        d = Math.round(d)
        p = Math.round(p)
        q = Math.round(q)
        r = Math.round(r)
        s = Math.round(s)
        ////////////////////////////////////////console.log(arePointsOverlapping(a, b, c, d, p, q, r, s))
        if (arePointsOverlapping(a, b, c, d, p, q, r, s)) {
            return false
        }
    
    
        det = (c - a) * (s - q) - (r - p) * (d - b);
        if (det === 0) {
            return false;
        } else {
            lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
            gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
            return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
        }
    };
    
    
    
    
    // Example usage
    // const polygon1 = [{x: 1, y: 1}, {x: 3, y: 3}, {x: 1, y: 3}, {x: 3, y: 1}]; // Self-intersecting
    // const polygon2 = [{x: 1, y: 1}, {x: 1, y: 5}, {x: 5, y: 5}, {x: 5, y: 1}]; // Not self-intersecting
    
    // //////////////console.l\og(isPolygonSelfIntersecting(polygon1)); // true
    // //////////////console.l\og(isPolygonSelfIntersecting(polygon2)); // false
    
    
    
    
    class Puppeteer {
        constructor(points, personSpawnID, targetRoom, footing, targetID) {
            this.points = points //points is a list of x,y objects like {"x":10,"y":12}, they will be in an array like [point1, point2, point3] etc.
            this.targetRoom = targetRoom //Target room is where the new character will spawn
            this.personSpawnID = personSpawnID //this is the ID of who will spawn in the room (at the footing)
            this.footing = footing //this is an  x,y object, just one, not a list, like point =  {"x":10,"y":12}, and it's where the npc will spawn
            this.targetID = targetID //this is the ID of who will be moved in the room to a new position, and will tag their people object to animate a walk animation(which exist)
    
    
            //animation variables, these control the puppeting 
            this.count = 0 //what "frame" of the interpolation between the points selected
            this.pointer1 = 0; //this is the starting point in the array for where to interopolate from
            this.ponter2 = 1 // this is the number that is the index of the point to interpolate to 
            this.distances = [] //arraay this holds the distances in pixels from A to B as they traverse
            this.lengths = [] //the lengths in frames of how long they will be walking from a to b
            this.link = new LineOP(this.points[0].this.points[1]) //dummy line object for geometry
            for (let t = 1; t < this.points.length; t++) { //loop for calculating the distances and lengths
                this.link.target = this.points[t] //this sets the line geometry to measure from the point at index t
                this.link.object = this.points[t - 1] //this sets the line geometry to measure to the point at index t-1,,this with the array starting loop at 1 means it won't overflow, regardless of the points, as long as there are two or more
                let h = this.link.hypotenuse() //h is the hypotenuse of the line that connects the points in question, and makes for a measure of their euclidian distance
                this.distances.push(h) //then we store that distance
                this.lengths.push(Math.ceil(h / 6)) //and also store the length in frames they will be animated for
            }
    
    
    
            this.active = 1 // sets up to run automatically on formation of trigger
    
        }
        interpolate(point1, point2, time, length) {
            let x = point1.x + ((point2.x - point1.x) * (time / length)) //averaging from x to x on a time slider
            let y = point1.y + ((point2.y - point1.y) * (time / length)) //averaging from y to y on a time slider
            return {
                "x": x,
                "y": y
            }
        }
        play() { //this will be on all triggerd puppet objects, in a loop of their array, in main probably at the top, and there will need to be a cleanup function
            if (this.active == 1) {
    
                //lookup people data and convert them to a class variable called target person
                this.targetPerson = {} //lookup
    
                let interpoint = this.interpolate(this.points[this.pointer1], this.points[this.ponter2], this.count, this.lengths[this.ponter2]) //call for the creation of a point that is where the npc should be drawn
                this.targetPerson.x = interpoint.x
                this.targetPerson.y = interpoint.y
    
    
                this.count++
                if (this.count > this.lengths[this.ponter2]) {
                    this.count = 0
                    this.pointer1++ //increment to the next point
                    this.pointer2++ //increment to the next point
                    if (this.pointer2 > this.lengths.length) { //if it's the ned, tun the swap
    
                        this.targetPerson.kill = 1 //code to remove target person from the array of people
    
                        let newDude = new Person(this.personSpawnID, this.footing.x, this.footing.y) //code to add people to other room 
                        people[this.targetRoom].push(newDude)
                        this.cleanup()
                    }
                }
            }
    
        }
        cleanup() {
            this.active = 0
        }
    
    }
    
    
    class GeneTable {
        constructor() {
            this.pairs = []
            this.alphabet = ("PO").split('')
            for (let t = 0; t < this.alphabet.length; t++) {
                for (let k = 0; k < this.alphabet.length; k++) {
                    let p = ''
                    p += this.alphabet[t]
                    p += this.alphabet[k]
                    this.pairs.push(p)
                }
            }
            this.hash = {}
    
    
            // 3
            // +
            // -
            // 0
    
            this.lester = []
            for (let t = 0; t < this.pairs.length; t++) {
                this.lester.push(t % 9)
            }
    
            for (let t = 0; t < this.pairs.length; t++) {
                this.hash[this.pairs[t]] = this.lester[t]
            }
            ////////////////////////////////////////console.log(this)
        }
    }
    
    
    let colors = ["REd", "orange", "yellow", "#00ff00", 'cyan', "blue", "indigo", "violet", "magenta"]
    class Amine {
        constructor(i, t) {
            this.body = new Circle(180 + (i * 10), 360 + (seedRandom() * 10), 5, colors[t])
            this.link = new LineOP(this.body, this.body)
            this.type = t
            this.friction = 1 - (this.type * .001)
        }
        draw() {
            this.body.draw()
        }
        move() {
            this.body.frictiveMove()
        }
    }
    
    
    //all my worst injuries are self inflicted
    //asked how I feel about failing I say I'm addicted 
    
    class Organism {
        constructor() {
            this.genes = []
            this.alphabet = ("PO").split('')
            this.geneslist = []
            for (let t = 0; t < 40; t++) {
                this.geneslist.push(this.alphabet[Math.floor(seedRandom() * this.alphabet.length)] + this.alphabet[Math.floor(seedRandom() * this.alphabet.length)])
            }
    
            this.spr = []
            for (let t = 0; t < 40; t++) {
                let ami = new Amine(t, genetable.hash[this.geneslist[t]])
    
                this.genes.push(ami)
    
                if (t > 0) {
                    let spring = new SpringOP(this.genes[t - 1].body, ami.body, 11, 1, 'transparent')
                    this.spr.push(spring)
                }
    
            }
        }
        draw() {
            for (let t = 0; t < this.genes.length; t++) {
                this.genes[t].draw()
                this.genes[t].move()
    
                for (let k = 0; k < this.genes.length; k++) {
                    if (k != t) {
    
    
                        this.genes[t].link.target = this.genes[k].body
                        if (this.genes[t].link.hypotenuse() < 10) {
    
                            this.genes[t].body.x += Math.cos(this.genes[t].link.angle()) / 3
                            this.genes[t].body.y += Math.sin(this.genes[t].link.angle()) / 3
                        }
                        if (this.genes[t].link.hypotenuse() < 20) {
                            this.genes[t].body.x += Math.cos(this.genes[t].link.angle()) / 40
                            this.genes[t].body.y += Math.sin(this.genes[t].link.angle()) / 40
                        }
                    }
                }
    
                for (let k = 0; k < this.genes.length; k++) {
                    if (this.genes[t].type == this.genes[k].type) {
                        if (k != t) {
                            this.genes[t].link.target = this.genes[k].body
                            if (this.genes[t].link.hypotenuse() < 20) {
                                this.genes[t].body.x -= Math.cos(this.genes[t].link.angle()) / 40
                                this.genes[t].body.y -= Math.sin(this.genes[t].link.angle()) / 40
                            }
                        }
                    }
                }
    
    
            }
            for (let t = 0; t < this.spr.length; t++) {
                this.spr[t].balance()
            }
        }
    }
    
    let genetable = new GeneTable()
    
    
    
    let organeo = new Organism()
    
    
    ////////////////////////////////////////console.log(organeo)
    
    let rmod = Math.floor(seedRandom() * 25) + 5
    let gmod = Math.floor(seedRandom() * 25) + 5
    let bmod = Math.floor(seedRandom() * 25) + 5
    
    rmod = 1
    bmod = 1
    gmod = 1
    
    
    function getIndex(x, y, width) {
        return (y * width + x) * 4;
    }
    
    
    class Counter {
        constructor() {
    
        }
    }
    
    let seenToday = {}
    let superclick = 0
    let startedinit = 0
    let markCon = 0
    let contextList = []
    let canvasList = []
    let mappingArt = []
    
    
    class Mapper {
        constructor() {
            this.x = 9999999
            this.y = 9999999
            this.width = 0
            this.height = 0
        }
    }
    class Node {
        constructor(x, y, t, genes, nope = 0) {
            this.earRadius = 1
            this.bet = 0
            this.eartick = Math.floor(Math.random()*100)
            this.earrate = 11
            this.nose = 0
            // this.contextMarker = markCon
            markCon++
            this.heard = {}
            this.noseThresh = 1
            this.metatick = 0
            this.soundCD = 0
    
            this.w = 1
            this.stinkRate = 255 + Math.round(seedRandom() * 10)
    
    
            this.nosePref = []
            this.noseAvoid = []
    
            let smellpref = 0
            let smellav = 0
            while (smellpref == 0) {
                if (seedRandom() < .25) {
                    this.nosePref.push(Math.floor(seedRandom() * nodetypes))
                } else if (seedRandom() < .05) {
                    smellpref = 1
                }
            }
            while (smellav == 0) {
                if (seedRandom() < .25) {
                    this.noseAvoid.push(Math.floor(seedRandom() * nodetypes))
                } else if (seedRandom() < .05) {
                    smellav = 1
                }
            }
    
    
            this.soundPref = []
            this.soundAvoid = [] 
    
            let hearpref = 0
            let hearav = 0
            let j = 0
            while (hearpref == 0) {
                j++
                if(j>nodetypes){
                    break
                }
                // if (seedRandom() < .5) {
                    this.soundPref[primes[Math.floor(seedRandom() * primes.length)] * primes[Math.floor(seedRandom() * primes.length)]] = 1
                    // //////console.log(primes[Math.floor(seedRandom() * primes.length)] * primes[Math.floor(seedRandom() * primes.length)])
                // } else if (seedRandom() < .01) {
                //     hearpref = 1
                // }
            }
            j = 0
            while (hearpref == 0) {
                j++
                if(j>nodetypes){
                    break
                }
                // if (seedRandom() < .5) { 
                    this.soundAvoid[primes[Math.floor(seedRandom() * primes.length)] * primes[Math.floor(seedRandom() * primes.length)]] = 1
                // } else if (seedRandom() < .01) {
                //     hearav = 1
                // }
            }

            // this.soundPref[83*83] = 1 //doesn't seem to set?
     

            // this.soundAvoid[59*3] = 1
            // this.soundAvoid[3*3] = 1
            // this.soundAvoid[59*59] = 1
    
            // ////////////////console.log(this.nosePref, this.noseAvoid)
    
    
            this.noseStrengths = []
            for (let t = 0; t < nodetypes; t++) {
                this.noseStrengths.push((seedRandom() * .05))
            }
    
            // let canvasz = document.createElement('canvas');
            // let context = canvasz.getContext("2d", { willReadFrequently: true })
    
    
    
            //relationview '7' "7"
            // contextList.push(context)
            // canvasList.push(canvasz)
            // mappingArt.push(new Mapper())
    
    
    
    
            //    document.body.appendChild(canvasz)
    
    
            this.energyOrgCost = 0
            this.nodeEnergyCost = 0
            this.linkApha = 1
    
            this.relative = -1
            this.xavg = 0
            this.yavg = 0
            this.charge = 0
            this.magratio = 1
            // if(seedRandom() < .66){
            //     this.charge = Math.sign(seedRandom()-.5)
            // }
            this.genestring = genes
            this.genebucket = []
            this.magbucket = [1]
            this.chargebucket = [0]
            this.trueage = 0
            this.pistonpush = 0
            this.pistonpushes = []
            this.pistontime = 0
            this.pistonstep = (seedRandom() + .5) / 10
            this.shead = 0
            this.birthx = seedRandom() - .5
            this.birthy = seedRandom() - .5
            this.r = seedRandom() * 255
            this.g = seedRandom() * 255
            this.b = seedRandom() * 255
            this.p = seedRandom() * 255
            this.m = seedRandom() * 255
            this.z = seedRandom() * 255
            this.q = seedRandom() * 255
            this.linkup = []
            this.prime = 0
            this.connected = 0
            this.head = 0
            this.ll = 0
            this.dcon = []
            if (t == 5) {
                this.mouth = 1
            }
            this.caught = 0
            this.age = 0
            this.xleap = 0
            this.yleap = 0
            this.immune = []
            this.stupidimmune = []
            this.neighbors = []
            this.stupidneighbors = []
            this.type = t
            this.id = superclick
            superclick++
            this.x = x
            this.y = y
    
            this.lastx = this.x
            this.lasty = this.y
            if (nope == 0) {
                this.link = new LineOP(this, this, "#808080")
                this.link.list = []
            }
            this.lout = ((loutmin * worldscaler) + 2) - (((seedRandom() - .5) * 4) * worldscaler)
            this.loutin = this.lout
            this.las = []
            this.happy = true
            for (let t = 0; t < timesLength; t++) {
                this.las.push(seedRandom() * 6.283)
            }
            this.rigs = []
            this.times = []
            this.subticks = []
            for (let t = 0; t < timesLength; t++) {
                this.subticks.push(((seedRandom() - .5) / 16))
            }
            this.ticks = []
    
            this.pistonstarts = []
            this.pistontimes = []
            this.pistonticks = []
            for (let t = 0; t < timesLength; t++) {
                this.times.push(seedRandom()*Math.PI*2)
                this.pistontimes.push(seedRandom()*Math.PI*2)
                this.pistonstarts.push(seedRandom() * 10000)
                this.pistonpushes.push((seedRandom() * (loutmin * worldscaler) * 3.5) - ((loutmin * worldscaler) * .5))
                this.ticks.push(((seedRandom() - .5) / 16))
                this.pistonticks.push(((((seedRandom() - .5))) * 2) / 10)
            }
            this.subrots = []
            for (let t = 0; t < timesLength; t++) {
                this.subrots.push(((seedRandom() - .5) / 6))
            }
            for (let t = 0; t < timesLength; t++) {
                this.rigs.push(1 - ((seedRandom() / 10) + .90))
            }
            this.pushout = seedRandom() * 6.283
            this.pushoutsto = this.pushout
            // ////////////////////////////////////////console.log(this.id)
            if (nope == 0) {
                globalnodes.push(this)
            }
            this.energy = 0
            this.generate = 0
            if (this.type == 4 || this.type == 7 || this.type == 8 || this.type == 14 || this.type == 11 || this.type == 9) {
                this.generate = generationConstant
            }
            if (this.type == 20) {
                // this.generate = generationConstant - (.25*(.6/generationConstant))
            }
            this.gencap = 100000000 //holycrap this kills complexity sub 1000
            this.energy = 0
    
            this.hit = 0
            this.lt = new Point(this.x, this.y)
    
        }
        freeenergy() {
            this.link.object = this
            this.nodeEnergyCost = 0
        }
        map(k, f) {
            if (this.dead == 1) {
                return
            }
    
            let scare = {}
    
            for (let d = 0; d < f.length; d++) {
                scare[k[d]] = d
            }
            return scare
        }
        freakmap() {
            mappingArt[this.contextMarker].x = Math.min(this.x, mappingArt[this.contextMarker].x)
            mappingArt[this.contextMarker].y = Math.min(this.y, mappingArt[this.contextMarker].y)
            mappingArt[this.contextMarker].width = Math.max(Math.abs(mappingArt[this.contextMarker].x - (this.x)), mappingArt[this.contextMarker].width)
            mappingArt[this.contextMarker].height = Math.max(Math.abs(mappingArt[this.contextMarker].y - (this.y)), mappingArt[this.contextMarker].height)
        }
        stupe(num) {
            // //////////////////////////////////console.log(num)
            if (this.dead == 1) {
                // return false
            }
    
            let alldead = 0
            for (let t = 0; t < globalnodes.length; t++) {
                if (globalnodes[t].dead == 1) {
                    alldead++
                }
            }
    
            if ((globalnodes.length - alldead) >= nodecap - (this.immune.length * 2) || num == 0) {
                // return false
            }
            // let node = new Node(seedRandom()*360 ,seedRandom()*360, this.type)
            // if(this.age > minage){
            // this.age = minage
            let node
    
            if ((seedRandom() < 0 * 1) && this.head != 1) {
    
                //////////////////console.log("s")
                // return false
            } else {
                if ((seedRandom() < 0)) {
                    // node = new Node(this.x+((seedRandom()-.5)*20), this.y+((seedRandom()-.5)*20) , Math.floor(seedRandom()*nodetypes))
    
                    if (codonusage == 1) {
                        let g = mutateGenes(this.genestring)
                        node = new Snode(this.x + ((this.birthx + Math.cos(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.y + ((this.birthy + Math.sin(this.pushout)) * ((loutmin * worldscaler) * 1.5)), geneToType(g), g)
                        node.head = this.head
                        node.bet = this.bet
                        pu.potential += this.bet
                        headout = 1
                    } else {
                        let g = mutateGenes(this.genestring)
                        node = new Snode(this.x + ((this.birthx + Math.cos(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.y + ((this.birthy + Math.sin(this.pushout)) * ((loutmin * worldscaler) * 1.5)), Math.floor(seedRandom() * (nodetypes - 1)), g) //-1 because disease
                        node.head = this.head
                        node.bet = this.bet
                        pu.potential += this.bet
                        headout = 1
                    }
                } else {
                    if (codonusage == 1) {
                        let g = (this.genestring)
    
                        node = new Snode(this.x + ((this.birthx + Math.cos(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.y + ((this.birthy + Math.sin(this.pushout)) * ((loutmin * worldscaler) * 1.5)), geneToType(g), g)
                        node.head = this.head
                        node.bet = this.bet
                        pu.potential += this.bet
                        headout = 1
                    } else {
                        let g = this.genestring
                        node = new Snode(this.x + ((this.birthx + Math.cos(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.y + ((this.birthy + Math.sin(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.type, g)
                        node.head = this.head
                        node.bet = this.bet
                        pu.potential += this.bet
                        headout = 1
                    }
    
                }
    
            }
    
            //ticks rigs pushout sto time
    
            if (seedRandom() < 0) {
                node.charge = 0
                if (seedRandom() < .66) {
                    node.charge = Math.sign(seedRandom() - .5)
                }
            } else {
                node.charge = this.charge
            }
    
            node.magratio = this.magratio
    
            if (seedRandom() < 0) {
    
                node.magratio = this.magratio + ((seedRandom() - .5) / 4)
    
            }
    
            node.magratio = Math.min(Math.max(node.magratio, 0), magratmax)
    
    
            if (seedRandom() < 0) {
                node.birthx = this.birthx + ((seedRandom() - .5))
                node.birthx = Math.max(Math.min(node.birthx, .5), -.5)
            } else {
                node.birthx = this.birthx
            }
    
            if (seedRandom() < 0) {
                node.birthy = this.birthy + ((seedRandom() - .5))
                node.birthy = Math.max(Math.min(node.birthy, .5), -.5)
            } else {
                node.birthy = this.birthy
            }
    
    
    
            node.rigs = [...this.rigs]
            node.pistonstarts = [...this.pistonstarts]
            node.pistonpushes = [...this.pistonpushes]
            node.pistonticks = [...this.pistonticks]
            // node.pistontimes = [...this.pistontimes]
            node.ticks = [...this.ticks]
            node.pistonticks = [...this.pistonticks]
            node.subticks = [...this.subticks]
            node.subrots = [...this.subrots]
            node.noseStrengths = [...this.noseStrengths]
            node.noseThresh = this.noseThresh
            node.stinkRate = this.stinkRate
    
    
            if (seedRandom() < 0) {
                node.noseThresh += (Math.floor((seedRandom() - .5) * 24))
            }
            if (seedRandom() < 0) {
                node.stinkRate += (Math.floor((seedRandom() - .5) * 10))
            }
    
            node.stinkRate = Math.max(5, node.stinkRate)
    
            node.nosePref = [...this.nosePref]
            node.noseAvoid = [...this.noseAvoid]
            node.soundPref = []
    for(let t = 0;t<this.soundPref.length;t++){
        if(this.soundPref[t] ==1){
            node.soundPref[t] = this.soundPref[t]
        }
    }
            node.soundAvoid = []
    for(let t = 0;t<this.soundAvoid.length;t++){
        if(this.soundAvoid[t] ==1){
    node.soundAvoid[t] = this.soundAvoid[t]
        }
    }
    
            for (let t = 0; t < node.pistonticks.length; t++) {
                if ((seedRandom() < 0)) {
                    node.pistonticks[t] += ((seedRandom() - .5) / 10)
                }
                if ((seedRandom() < 0)) {
                    node.pistonticks[t] = ((((seedRandom() - .5))) * 2) / 10
                }
            }
    
            for (let t = 0; t < node.subticks.length; t++) {
                if ((seedRandom() < 0)) {
                    node.subticks[t] += ((seedRandom() - .5) / 32)
                }
                if ((seedRandom() < 0)) {
                    node.subticks[t] = ((seedRandom() - .5) / 16)
                }
            }
            for (let t = 0; t < node.subrots.length; t++) {
                if ((seedRandom() < 0)) {
                    node.subrots[t] += ((seedRandom() - .5) / 32)
                }
                if ((seedRandom() < 0)) {
                    node.subrots[t] = ((seedRandom() - .5) / 16)
                }
            }
    
    
            node.r = Math.max(Math.min(255, this.r + ((seedRandom() - .5) * 0)), 0)
            node.g = Math.max(Math.min(255, this.g + ((seedRandom() - .5) * 0)), 0)
            node.b = Math.max(Math.min(255, this.b + ((seedRandom() - .5) * 0)), 0)
            node.p = Math.max(Math.min(255, this.p + ((seedRandom() - .5) * 0)), 0)
            node.m = Math.max(Math.min(255, this.m + ((seedRandom() - .5) * 0)), 0)
            node.z = Math.max(Math.min(255, this.z + ((seedRandom() - .5) * 0)), 0)
            node.q = Math.max(Math.min(255, this.q + ((seedRandom() - .5) * 0)), 0)
    
            for (let t = 0; t < node.rigs.length; t++) {
                if ((seedRandom() < 0)) {
                    node.rigs[t] = (1 - ((seedRandom() / 10) + .90))
                }
            }
            for (let t = 0; t < node.pistonstarts.length; t++) {
                if ((seedRandom() < 0)) {
                    node.pistonstarts[t] = (seedRandom() * 100000)
                }
                if ((seedRandom() < 0)) {
                    node.pistonstarts[t] += ((seedRandom() - .5) * (Math.PI * 2))
                }
            }
    
            node.pushoutsto = this.pushoutsto
            node.pushout = this.pushout
    
            if ((seedRandom() < 0 * 1)) {
                node.pushout = seedRandom() * Math.PI * 2
            }
    
    
    
            node.lout = Math.max(this.lout + (((seedRandom() - .5) * 2) * worldscaler), (loutmin * worldscaler))
    
            node.linkApha = this.linkApha
            node.loutin = node.lout
            if ((seedRandom() < 0 * 1)) {
                node.pistonstep = this.pistonstep + ((((seedRandom() - .5) * 1)) / 10)
            } else {
                node.pistonstep = this.pistonstep
            }
            if ((seedRandom() < 0 * 1)) {
                // node.cut = 1
            } else {
    
                if (seedRandom() < 0) {
    
                    let superduper = {}
                    if (deadwash == deadmax - 1) {
    
                        //////////////////////console.log("W")
                        superduper.linkto = globalnodes.indexOf(node)
                    } else {
    
                        //////////////////////console.log("M")
                        superduper.linkto = globalnodes.indexOf(node)
                    }
                    superduper.x = node.x
                    superduper.y = node.y
                    superduper.type = Math.floor(seedRandom() * (nodetypes - 1)) //-1 because disease
                    let gr = this.genestring
                    let ch = this.charge
                    let mh = this.magratio
                    if (seedRandom() < .33) {
                        gr = ''
                        ch = 0
                        mh = 1
    
                        if (seedRandom() < 0) {
                            mh = mh + ((seedRandom() - .5))
                        }
                        mh = Math.min(Math.max(mh, 0), magratmax)
    
    
                        if (seedRandom() < .66) {
                            if (seedRandom() < .5) {
                                ch = 1
                            } else {
                                ch = -1
                            }
                        }
                        for (let r = 0; r < genelength; r++) {
                            gr += geneChars[Math.floor(seedRandom() * geneChars.length)]
                        }
                        ch = this.charge
                        mh = this.magratio
                    } else if (seedRandom() < .33) {
                        gr = this.genebucket[Math.floor(seedRandom() * this.genebucket.length)]
                        ch = this.chargebucket[Math.floor(seedRandom() * this.chargebucket.length)]
                        mh = this.magbucket[Math.floor(seedRandom() * this.magbucket.length)]
                        if(this.genebucket.length == 0){
                            gr = this.genestring
                        }
                    }
                    superduper.genestring = gr
                    superduper.linkApha = this.linkApha
                    if (seedRandom() < 0 * 3) { //2
                        superduper.radio = 1
                    } else {
                        superduper.radio = 0
                    }
                    if (seedRandom() < 0 * 3) { //2
                        superduper.extra = 1
                    } else {
                        superduper.extra = 0
                    }
    
                    superduper.charge = ch
                    globduper.push(superduper)
    
    
                }
    
    
            }
    
            return node
            // }
    
    
            // return false
        }
        dupe(num) {
            // //////////////////////////////////console.log(num)
            if (this.dead == 1) {
                return false
            }
    
            let alldead = 0
            for (let t = 0; t < globalnodes.length; t++) {
                if (globalnodes[t].dead == 1) {
                    alldead++
                }
            }
    
            if ((globalnodes.length - alldead) >= nodecap - (this.immune.length * 2) || num == 0) {
                return false
            }
            // let node = new Node(seedRandom()*360 ,seedRandom()*360, this.type)
            // if(this.age > minage){
            // this.age = minage
            let node
    
    
            if(keysPressed['e'] || pu.seeage == 1){
    
                let age = Math.round(this.age * 100) / 100
                canvas_context.strokeText(Math.round(100 * (age / ((((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)))) + "%", this.xavg, this.yavg)
                canvas_context.fillText(Math.round(100 * (age / ((((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)))) + "%", this.xavg, this.yavg)
                ////////console.log(age, ((((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)))
    
    
    
            }
    
            if ((seedRandom() < mutationrate * 1) && this.head != 1) {
    
                //////////////////console.log("s")
                return false
            } else {
                if ((seedRandom() < mutationrate)) {
                    // node = new Node(this.x+((seedRandom()-.5)*20), this.y+((seedRandom()-.5)*20) , Math.floor(seedRandom()*nodetypes))
    
                    if (codonusage == 1) {
                        let g = mutateGenes(this.genestring)
                        if (seedRandom() < mutationrate) {
                            let h = g
                            g = this.genebucket[Math.floor(seedRandom() * this.genebucket.length)] //add mating
                            if(this.genebucket.length == 0){
                                g = mutateGenes(this.genestring)
                            }
                            let fr = ((h).split('')).length
                            let gr = ((g).split('')).length
                            let indexer1 = Math.floor(seedRandom() * fr)
                            let indexer2 = Math.floor(seedRandom() * gr)
                            let ls = ''
                            let rs = ''
    
    
                            for (let t = 0; t < fr; t++) {
                                if (t < indexer1) {
                                    ls += ((h).split(''))[t]
                                } else {
                                    rs += ((h).split(''))[t]
                                }
                            }
                            for (let t = 0; t < gr; t++) {
                                if (t < indexer2) {
                                    ls += ((g).split(''))[t]
                                } else {
                                    rs += ((g).split(''))[t]
                                }
                            }
                            ////////////////console.log(rs, ls)
    
                            ////////////////console.log((rs.split('')).length)
                            ////////////////console.log((ls.split('')).length)
                            if (seedRandom() < .5) {
                                if ((ls.split('')).length == 0) {
    
                                    g = rs
                                } else {
    
                                    g = ls
                                }
                            } else {
                                if ((rs.split('')).length == 0) {
    
                                    g = ls
                                } else {
    
                                    g = rs
                                }
                            }
                        }
                        node = new Node(this.x + ((this.birthx + Math.cos(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.y + ((this.birthy + Math.sin(this.pushout)) * ((loutmin * worldscaler) * 1.5)), geneToType(g), g)
                        node.head = this.head
                        node.bet = this.bet * .5
                        pu.potential += this.bet
                        headout = 1
                    } else {
                        let g = mutateGenes(this.genestring)
                        node = new Node(this.x + ((this.birthx + Math.cos(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.y + ((this.birthy + Math.sin(this.pushout)) * ((loutmin * worldscaler) * 1.5)), Math.floor(seedRandom() * (nodetypes - 1)), g) //-1 because disease
                        node.head = this.head
                        node.bet = this.bet * .5
                        pu.potential += this.bet
                        headout = 1
                    }
                } else {
                    if (codonusage == 1) {
                        let g = mutateGenes(this.genestring)
                        if (seedRandom() < mutationrate) {
    
                            let h = g
                            g = this.genebucket[Math.floor(seedRandom() * this.genebucket.length)] //add mating
                            if(this.genebucket.length == 0){
                                g = mutateGenes(this.genestring)
                            }
                            let fr = ((h).split('')).length 
                            let gr = ((g).split('')).length
                            let indexer1 = Math.floor(seedRandom() * fr)
                            let indexer2 = Math.floor(seedRandom() * gr)
                            let ls = ''
                            let rs = ''
    
                            for (let t = 0; t < fr; t++) {
                                if (t < indexer1) {
                                    ls += ((h).split(''))[t]
                                } else {
                                    rs += ((h).split(''))[t]
                                }
                            }
                            for (let t = 0; t < gr; t++) {
                                if (t < indexer2) {
                                    ls += ((g).split(''))[t]
                                } else {
                                    rs += ((g).split(''))[t]
                                }
                            }
                            // ////////////////console.log(rs, ls)
                            // ////////////////console.log((rs.split('')).length)
                            // ////////////////console.log((ls.split('')).length)
                            if (seedRandom() < .5) {
                                if ((ls.split('')).length == 0) {
    
                                    g = rs
                                } else {
    
                                    g = ls
                                }
                            } else {
                                if ((rs.split('')).length == 0) {
    
                                    g = ls
                                } else {
    
                                    g = rs
                                }
                            }
                        }
                        node = new Node(this.x + ((this.birthx + Math.cos(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.y + ((this.birthy + Math.sin(this.pushout)) * ((loutmin * worldscaler) * 1.5)), geneToType(g), g)
                        node.head = this.head
                        node.bet = this.bet * .5
                        pu.potential += this.bet
                        headout = 1
                    } else {
                        let g = this.genestring
                        node = new Node(this.x + ((this.birthx + Math.cos(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.y + ((this.birthy + Math.sin(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.type, g)
                        node.head = this.head
                        node.bet = this.bet * .5
                        pu.potential += this.bet
                        headout = 1
                    }
    
                }
    
            }
    
            //ticks rigs pushout sto time
    
            if (seedRandom() < mutationrate) {
                node.charge = 0
                if (seedRandom() < .66) {
                    node.charge = Math.sign(seedRandom() - .5)
                }
            } else {
                node.charge = this.charge
            }
    
            node.magratio = this.magratio
    
            if (seedRandom() < mutationrate) {
    
                node.magratio = this.magratio + ((seedRandom() - .5) / 4)
    
            }
    
            node.magratio = Math.min(Math.max(node.magratio, 0), magratmax)
    
    
            if (seedRandom() < mutationrate) {
                node.birthx = this.birthx + ((seedRandom() - .5))
                node.birthx = Math.max(Math.min(node.birthx, .5), -.5)
            } else {
                node.birthx = this.birthx
            }
    
            if (seedRandom() < mutationrate) {
                node.birthy = this.birthy + ((seedRandom() - .5))
                node.birthy = Math.max(Math.min(node.birthy, .5), -.5)
            } else {
                node.birthy = this.birthy
            }
    
    
            node.ticks = [...this.ticks]
            node.pistonticks = [...this.pistonticks]
            node.subticks = [...this.subticks]
            node.subrots = [...this.subrots]
            node.noseStrengths = [...this.noseStrengths]
            node.noseThresh = this.noseThresh
            node.stinkRate = this.stinkRate
    
    
            if (seedRandom() < mutationrate) {
                node.noseThresh += (Math.floor((seedRandom() - .5) * 24))
            }
            if (seedRandom() < mutationrate) {
                node.stinkRate += (Math.floor((seedRandom() - .5) * 10))
            }
    
            node.stinkRate = Math.max(5, node.stinkRate)
    
            node.nosePref = [...this.nosePref]
            node.noseAvoid = [...this.noseAvoid]
            node.soundPref = []
    for(let t = 0;t<this.soundPref.length;t++){
        if(this.soundPref[t] ==1){
            node.soundPref[t] = this.soundPref[t]
        }
    }
            node.soundAvoid = []
    for(let t = 0;t<this.soundAvoid.length;t++){
        if(this.soundAvoid[t] ==1){
    node.soundAvoid[t] = this.soundAvoid[t]
        }
    }
    
    
            if (seedRandom() < mutationrate*sensoryConstant) {
                node.nosePref.push(Math.floor(seedRandom() * nodetypes))
            }
            if (seedRandom() < mutationrate*sensoryConstant) {
                node.noseAvoid.push(Math.floor(seedRandom() * nodetypes))
            }
    
            if (seedRandom() < mutationrate*sensoryConstant) {
                node.noseAvoid.splice(Math.floor(seedRandom() * node.noseAvoid.length), 1)
            }
            if (seedRandom() < mutationrate*sensoryConstant) {
                node.nosePref.splice(Math.floor(seedRandom() * node.nosePref.length), 1)
            }
    
    
    
            for(let k = 0;k<sensoryConstant;k++){

                if (seedRandom() < mutationrate*sensoryConstant) {
                    node.soundPref[primes[Math.floor(seedRandom() * primes.length)] * primes[Math.floor(seedRandom() * primes.length)]] = 1
                    }
                    if (seedRandom() < mutationrate*sensoryConstant) {
                    node.soundAvoid[primes[Math.floor(seedRandom() * primes.length)] * primes[Math.floor(seedRandom() * primes.length)]] = 1
                    }
                    
                    if (seedRandom() < mutationrate*sensoryConstant) {
                    let selector = []
                    for(let t = 0;t<node.soundAvoid.length;t++){
                        if(node.soundAvoid[t] == 1){
                            selector.push(t)
                        }
                    }
                    node.soundAvoid[selector[Math.floor(seedRandom() * selector.length)]] = 0
                    }
                    if (seedRandom() < mutationrate*sensoryConstant) {
                    let selector = []
                    for(let t = 0;t<node.soundPref.length;t++){
                        if(node.soundPref[t] == 1){
                            selector.push(t)
                        }
                    }
                    node.soundPref[selector[Math.floor(seedRandom() * selector.length)]] = 0
                    }
            }
    
    
    
    
    
            for (let t = 0; t < node.ticks.length; t++) {
                if ((seedRandom() < mutationrate)) {
                    node.noseStrengths[t] += ((seedRandom() - .5) / 32)
                }
                if ((seedRandom() < mutationrate)) {
                    node.noseStrengths[t] += ((seedRandom() - .5) / 16)
                }
                node.noseStrengths[t] = Math.max(node.noseStrengths[t], 0)
            }
            for (let t = 0; t < node.ticks.length; t++) {
                if ((seedRandom() < mutationrate)) {
                    node.ticks[t] += ((seedRandom() - .5) / 32)
                }
                if ((seedRandom() < mutationrate)) {
                    node.ticks[t] = ((seedRandom() - .5) / 16)
                }
            }
    
            for (let t = 0; t < node.pistonticks.length; t++) {
                if ((seedRandom() < mutationrate)) {
                    node.pistonticks[t] += ((seedRandom() - .5) / 10)
                }
                if ((seedRandom() < mutationrate)) {
                    node.pistonticks[t] = ((((seedRandom() - .5))) * 2) / 10
                }
            }
    
            for (let t = 0; t < node.subticks.length; t++) {
                if ((seedRandom() < mutationrate)) {
                    node.subticks[t] += ((seedRandom() - .5) / 32)
                }
                if ((seedRandom() < mutationrate)) {
                    node.subticks[t] = ((seedRandom() - .5) / 16)
                }
            }
            for (let t = 0; t < node.subrots.length; t++) {
                if ((seedRandom() < mutationrate)) {
                    node.subrots[t] += ((seedRandom() - .5) / 32)
                }
                if ((seedRandom() < mutationrate)) {
                    node.subrots[t] = ((seedRandom() - .5) / 16)
                }
            }
    
            node.rigs = [...this.rigs]
            node.pistonstarts = [...this.pistonstarts]
            node.pistonpushes = [...this.pistonpushes]
            node.pistonticks = [...this.pistonticks]
            // node.pistontimes = [...this.pistontimes]
    
            node.r = Math.max(Math.min(255, this.r + ((seedRandom() - .5) * 32)), 0)
            node.g = Math.max(Math.min(255, this.g + ((seedRandom() - .5) * 32)), 0)
            node.b = Math.max(Math.min(255, this.b + ((seedRandom() - .5) * 32)), 0)
            node.p = Math.max(Math.min(255, this.p + ((seedRandom() - .5) * 32)), 0)
            node.m = Math.max(Math.min(255, this.m + ((seedRandom() - .5) * 32)), 0)
            node.z = Math.max(Math.min(255, this.z + ((seedRandom() - .5) * 32)), 0)
            node.q = Math.max(Math.min(255, this.q + ((seedRandom() - .5) * 32)), 0)
    
            for (let t = 0; t < node.rigs.length; t++) {
                if ((seedRandom() < mutationrate)) {
                    node.rigs[t] = (1 - ((seedRandom() / 10) + .90))
                }
            }
            for (let t = 0; t < node.pistonstarts.length; t++) {
                if ((seedRandom() < mutationrate)) {
                    node.pistonstarts[t] = (seedRandom() * 100000)
                }
                if ((seedRandom() < mutationrate)) {
                    node.pistonstarts[t] += ((seedRandom() - .5) * (Math.PI * 2))
                }
            }
    
            node.pushoutsto = this.pushoutsto
            node.pushout = this.pushout
    
            if ((seedRandom() < mutationrate * 1)) {
                node.pushout = seedRandom() * Math.PI * 2
            }
    
    
    
            node.lout = Math.max(this.lout + (((seedRandom() - .5) * 2) * worldscaler), (loutmin * worldscaler))
    
            node.linkApha = this.linkApha
            node.loutin = node.lout
            if ((seedRandom() < mutationrate * 1)) {
                node.pistonstep = this.pistonstep + ((((seedRandom() - .5) * 1)) / 10)
            } else {
                node.pistonstep = this.pistonstep
            }
            if ((seedRandom() < mutationrate * 1)) {
                // node.cut = 1
            } else {
    
                if (seedRandom() < mutationrate) {
    
                    let superduper = {}
                    if (deadwash == deadmax - 1) {
    
                        //////////////////////console.log("W")
                        superduper.linkto = globalnodes.indexOf(node)
                    } else {
    
                        //////////////////////console.log("M")
                        superduper.linkto = globalnodes.indexOf(node)
                    }
                    superduper.x = node.x
                    superduper.y = node.y
                    superduper.head = 0
                    if (seedRandom() < .5) {
                        if (this.head == 1) {
                            ////////////////console.log("hit")
                            node.head = 0
                            superduper.head = 1
                        }
                    }
                    superduper.type = Math.floor(seedRandom() * (nodetypes - 1)) //-1 because disease
                    let gr = this.genestring
                    let ch = this.charge
                    let mh = this.magratio
                    if (seedRandom() < .33) {
                        gr = ''
                        ch = 0
                        mh = 1
    
                        if (seedRandom() < mutationrate) {
                            mh = mh + ((seedRandom() - .5))
                        }
                        mh = Math.min(Math.max(mh, 0), magratmax)
    
    
                        if (seedRandom() < .66) {
                            if (seedRandom() < .5) {
                                ch = 1
                            } else {
                                ch = -1
                            }
                        }
                        for (let r = 0; r < genelength; r++) {
                            gr += geneChars[Math.floor(seedRandom() * geneChars.length)]
                        }
                        ch = this.charge
                        mh = this.magratio
                    } else if (seedRandom() < .33) {
                        gr = this.genebucket[Math.floor(seedRandom() * this.genebucket.length)]
                        ch = this.chargebucket[Math.floor(seedRandom() * this.chargebucket.length)]
                        mh = this.magbucket[Math.floor(seedRandom() * this.magbucket.length)]
                        if(this.genebucket.length == 0){
                            gr = this.genestring
                        }
                    }
                    superduper.genestring = gr 
                    superduper.linkApha = this.linkApha
                    if (seedRandom() < mutationrate * 3) { //2
                        superduper.radio = 1
                    } else {
                        superduper.radio = 0
                    }
                    if (seedRandom() < mutationrate * 3) { //2
                        superduper.extra = 1
                    } else {
                        superduper.extra = 0
                    }
    
                    
                    superduper.charge = ch
                    superduper.magratio = mh
                    globduper.push(superduper) 
    
    
                }
    
    
            }
    
            return node
            // }
    
    
            return false
        }
    
    
        //a teleporting magnolia tree that goes on adventures but lives on one place
        tupe(macro, node) {
            let alldead = 0
            for (let t = 0; t < globalnodes.length; t++) {
                if (globalnodes[t].dead == 1) {
                    alldead++
                }
            }
    
            if ((globalnodes.length - alldead) >= nodecap - (this.immune.length * 2)) {
                return false
            }
            if (this.dead == 1) {
                return
            }
            let table = []
            // for(let t= 0 ;t<macro.f.length;t++){
            //     table[macro.f[t]] = t
            // }
            //  let  babble  = macro.match[me]
            //  ////////////////////////////////////console.log(macro.f, node.linkup)
            //  ////////////////////////////////////console.log(table)
            if (node.linkup.length > 1) {
                //////////////////console.log(node)
            }
            for (let t = 0; t < node.linkup.length; t++) {
                let offset = macro.f.indexOf(node.linkup[t])
                // //////////////////////////////////console.log(offset, macro.f, node.linkup) 
                if (offset + macro.start <= globalnodes.length) {
                    if (globalnodes[offset + macro.start].hitcon != 1) {
                        if (offset != -1) {
    
                            node.connected++
                            globalnodes[(offset + macro.start)].connected++
                            node.connect(globalnodes[(offset + macro.start)])
                            if (node.connected > 2) {
    
                                //////////////////console.log(node, globalnodes[(offset+macro.start)], macro)
                            }
                            if (globalnodes[(offset + macro.start)].connected > 2) {
                                //////////////////console.log(node, globalnodes[(offset+macro.start)], macro)
                            }
                        }
                        // ////////////////////////////////////console.log(globalnodes[(offset+macro.start)].type, globalnodes[node.linkup[t]].type)
                        // globalnodes[offset+macro.start].hitcon = 1
                        // node.hitcon = 1
                    }
                }
            }
        }
    
    
    
    
        // tupe(num, macro, me,node){
        //     if(globalnodes.length > nodecap || num == 0){
        //         return
        //     }
        //     let keys = Object.keys(macro.match)
        //     let arts = this.map(keys, macro.f)
    
        //     //////////////////////////////////////console.log( arts, me)
        //     let letters = macro.match[arts[me]] 
        //     for(let t = 0;t<letters.length;t++){
        //         if(globalnodes[letters[t]+macro.start]){
    
        //         node.connect(globalnodes[letters[t]+macro.start])
        //         }
        //     }
        // }
        energyBalance() {
            this.finalhead = 1
            this.balanced = 1
            if (this.head != 1) {
                return
            }
            if (this.hit == 1) {
                return
            }
            if (this.dead == 1) {
    
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
    
            if (this.caught == 1) {
                return
            }
    
    
    
            let glist = [this]
    
            let flist = [this]
    
            let runsum = this.prime
            let runprod = this.prime
            let f = [globalnodes.indexOf(this)]
            for (let t = 0; t < flist.length; t++) {
                if (flist[t]) {
                    for (let k = 0; k < flist[t].neighbors.length; k++) {
                        if (f.includes((flist[t].neighbors[k]))) { //|| globalnodes[flist[t].neighbors[k]].dead == 1
                        } else {
                            if (globalnodes[flist[t].neighbors[k]]) {
                                runprod *= globalnodes[flist[t].neighbors[k]].prime
                                runsum += globalnodes[flist[t].neighbors[k]].prime
                                f.push((flist[t].neighbors[k]))
                                // if(flist[t]){ 
                                flist.push(globalnodes[flist[t].neighbors[k]])
    
                            }
                            // }
                        }
                    }
    
                }
            }
    
    
    
    
            // ////////////////////////////////////console.log(flist)
            for (let t = 0; t < flist.length; t++) {
                for (let k = 0; k < flist[t].neighbors.length; k++) {
                    if (f.includes((flist[t].neighbors[k]))) {
    
    
                        // ////////////////////////////////////console.log(flist)
                        let screw = 0
                        let snapout = 0
                        for (let w = 0; w < glist.length; w++) {
                            if (snapout == 1) {
                                continue
                            }
                            if (glist[w].x > -10000) {
                                screw = -1
                            }
                            if (keysPressed['g']) {
                                ////////////////////////////////////console.log(globalnodes[flist[t].neighbors[k]].id)
                            }
                            if (glist[w].id == globalnodes[flist[t].neighbors[k]].id) {
                                screw = 1
                                snapout = 1
                                //  ////////////////////////////////////console.log('s')
                            }
                        }
    
    
                        if (screw == -1) {
                            glist.push(globalnodes[flist[t].neighbors[k]])
    
                        }
                    }
                }
            }
    
    
    
            for (let t = 0; t < glist.length; t++) {
                if (glist[t].radio == 1) {
                    let met = Math.floor(seedRandom() * glist.length)
                    if (met != t) {
                        glist[t].radio = 0
                        glist[t].connect(glist[met])
                    }
                }
    
            }
    
            for (let t = 0; t < glist.length; t++) {
                if (glist[t].extra == 1) {
                    let met = Math.floor(seedRandom() * glist.length)
                    let mek = Math.floor(seedRandom() * glist.length)
                    ////////////////////////////////console.log(met, mek) 
                    if (met != mek) {
                        glist[t].extra = 0
                        glist[mek].connect(glist[met])
                    }
                }
    
            }
    
    
            if (keysPressed['g']) {
                ////////////////////////////////////console.log(f,glist)
            }
            let g = 0
            let m = 0
            let ag = 0
            let ll = 0
            let p = 0
            let eoc = 0
            let bet = 0
    
            for (let t = 0; t < glist.length; t++) {
                glist[t].immune = []
                glist[t].stupidimmune = []
                glist[t].caught = 1
            }
    
            for (let t = 0; t < glist.length; t++) {
                for (let k = 0; k < glist.length; k++) {
                    glist[t].immune.push(globalnodes.indexOf(glist[k]))
                    glist[k].immune.push(globalnodes.indexOf(glist[t]))
                    glist[k].stupidimmune[glist[t].id] = 1
                    glist[t].stupidimmune[glist[k].id] = 1
    
    
                }
            }
    
    
    
            let angles = []
            let mags = []
            for (let t = 0; t < glist.length; t++) {
                // for(let k = 0;k<glist[t].link.list.length;k++){
                g += glist[t].energy
                p += glist[t].pushout
                ag += glist[t].age
                bet += glist[t].bet
                ll += (glist[t].immune.length + 1)
                eoc += glist[t].nodeEnergyCost 
                m++
                // }
                angles.push(glist[t].pushoutsto)
                mags.push(1)
            }
    
            if (keysPressed[' ']) {
                ////////////////////////////////////////console.log(glist)
            }
            g /= m
            p /= m 
            ag /= m
            ll /= m
    
            // //////////console.log(p)
            // //////////console.log(angles, mags)
            p = weightedAverageAngle(angles, mags)
            // //////////console.log(p)
            bet /= m
    
    
            // ////////////////////////////////////////console.log(g,m)
    
            let matmatch = {}
            let startin = globalnodes.length
            let macro = {}
            macro.match = matmatch
            macro.start = startin
            macro.f = f.sort((a, b) => a > b ? 1 : -1)
    
            this.w = Math.max(this.w, m)
            g = Math.min((repconstant * ((((m))))), g)
            if (g >= (repconstant * ((((m))))) && glist.length > 1 && macrodupe == 0 && deadwash < deadmax - 3 && deadwash > 3) { 
    
                //////////////////////////////////console.log((100*(Math.sqrt(Math.sqrt((m*30)-25)))) ,g)
                glist.sort((a, b) => globalnodes.indexOf(a) > globalnodes.indexOf(b) ? 1 : -1)
                // macrodupe = 1
    
                ////////////////////////////////////console.log(glist)
                for (let t = 0; t < glist.length; t++) {
                    matmatch[globalnodes.indexOf(glist[t])] = []
                    // let mv  = []
                    for (let k = 0; k < glist[t].link.list.length; k++) {
                        if (!matmatch[globalnodes.indexOf(glist[t])].includes(glist[t].link.list[k])) {
                            // mv.push(glist[t].link.list[k])
                            matmatch[globalnodes.indexOf(glist[t])].push(glist[t].link.list[k])
                        }
                    }
    
                }
    
    
    
                let nodds = []
                headout = 0
                let kills = []
                for (let t = 0; t < glist.length; t++) {
    
                    // //////////////////////////////////console.log(glist[t].neighbors.length)
                    let nodd = glist[t].dupe(glist[t].neighbors.length)
    
                    if (nodd != false) {
    
                        if (glist[t].neighbors.length > 1) {
                            ////////////////////console.log("W")
                        }
                        nodd.linkup = [...glist[t].neighbors]
                        if (seedRandom() < mutationrate) {
                            let pos = macro.f[Math.floor(seedRandom() * macro.f.length)]
                            if (nodd.linkup.includes(pos)) {} else {
                                nodd.linkup.push(pos)
                            }
                        }
                        nodd.t = globalnodes.indexOf(glist[t])
                        nodds.push(nodd)
                    } else {
                        kills.push(globalnodes.indexOf(glist[t]))
                        ////////////////////////////console.log(matmatch)
    
                        // glist[t].neighbors.splice(glist[t].neighbors.indexOf(globalnodes.indexOf(glist[t])),1)
                        ////////////////////console.log(macro.f)
    
                        macro.f.splice(macro.f.indexOf(globalnodes.indexOf(glist[t])), 1)
                        ////////////////////console.log(macro.f)
    
    
    
    
                        // let key = Object.keys(matmatch)
                        // for(let z = 0;z<key.length;z++){
                        //     if(key[z] == glist[t].id){
                        //         delete matmatch[key[z]]
                        //     }else{
                        //         for(let q = 0;q<matmatch[key[z]].length;q++){
                        //             ////////////////////////////console.log(matmatch[key[z]].indexOf(glist[t].id))
                        //             matmatch[key[z]].splice(matmatch[key[z]].indexOf(glist[t].id),1)
                        //         }
                        //     }
                        // }
    
    
    
    
                        // return
                    }
                }
    
    
    
    
                for (let t = 0; t < kills.length; t++) {
                    for (let ww = 0; ww < nodds.length; ww++) {
                        ////////////////////////////console.log(nodds[ww].linkup.indexOf(glist[t].id))
                        ////////////////////console.log(nodds[ww].linkup)
                        nodds[ww].linkup.splice(nodds[ww].linkup.indexOf(kills[t]), 1)
                        ////////////////////console.log(nodds[ww].linkup)
    
                    }
                }
                if (nodds.length > 0) {
    
                    g -= (repconstant * ((((m)))))
                }
                for (let t = 0; t < nodds.length; t++) {
                    nodds[t].tupe(macro, nodds[t])
                    for (let k = 0; k < nodds.length; k++) {
                        // nodds[k].hitcon = 0
                    }
                }
    
    
                for (let t = 0; t < nodds.length; t++) {
                    if (nodds[t].cut == 1) { //no
    
    
                        for (let w = 0; w < globalnodes.length; w++) {
    
                        }
                        for (let k = 0; k < nodds[t].neighbors.length; k++) {
                            globalnodes[nodds[t].neighbors[k]].disconnect(nodds[t])
                            // .disconnect() //
                        }
    
                        // nodds[t].dead = 1
                        // for(let k = 0;k<nodds.length;k++){
                        //     nodds[k].disconnect(nodds[t])
                        // }
                    }
                }
                for (let t = 0; t < nodds.length; t++) {
                    nodds[t].hitcon = 0
                }
    
    
                // ////////////////////////////////////////console.log(macro)
            }
    
            let x = 0
            let y = 0
            for (let t = 0; t < glist.length; t++) {
                if (glist[t].genebucket.length > 0) {
    
                } else {
                    glist[t].genebucket = []
                }
                glist[t].chargebucket = [0]
                glist[t].magbucket = [1]
    
            }
            for (let t = 0; t < glist.length; t++) {
                // for(let k = 0;k<glist[t].link.list.length;k++){
                glist[t].energy = g
                glist[t].pushout =  weightedAverageAngle([p, glist[t].pushout], [.0025, 1])
                glist[t].age = ag
                glist[t].bet = bet
                glist[t].ll = ll
                glist[t].hit = 1
                glist[t].head = 0
                glist[t].runsum = runsum
                glist[t].runprod = runprod
                glist[t].energyOrgCost = eoc
    
    
    
                glist[t].r = this.r
                glist[t].g = this.g
                glist[t].b = this.b
                glist[t].z = this.z
                glist[t].m = this.m
                glist[t].p = this.p
                glist[t].q = this.q
    
    
                x += glist[t].x
                y += glist[t].y
                for (let k = 0; k < glist.length; k++) {
                    if (glist[t].genebucket.includes(glist[k].genestring)) {
    
                    } else {
                        glist[t].genebucket.push(glist[k].genestring)
                    }
                    if(glist[k].charge != 1){
                        glist[t].chargebucket.push(glist[k].charge)
                        glist[t].magbucket.push(glist[k].magratio)
                    }else{
                        
                    }
    
                }
                // }
            }
    
            y /= m
            x /= m
    
            for (let t = 0; t < glist.length; t++) {
                glist[t].xavg = x
                glist[t].yavg = y
                glist[t].shead = globalnodes.indexOf(this)
            }
            if (edgeLoop == 1) {
    
                if (x < 0) {
    
                    ////////////////////////console.log(this.immune.length, glist.length)
                    for (let t = 0; t < glist.length; t++) {
                        glist[t].xleap = (canvas.width / zoom) - 0
                    }
                    // this.x += canvas.width/zoom
                }
                if (x > (canvas.width / zoom) + 3) {
    
                    for (let t = 0; t < glist.length; t++) {
                        glist[t].xleap = -((canvas.width / zoom) - 0)
                    }
                    // this.x -= canvas.width/zoom
                }
                if (y < 0) {
    
                    ////////////////////////console.log(this.immune.length, glist.length)
                    for (let t = 0; t < glist.length; t++) {
                        glist[t].yleap = (canvas.height / zoom) - 0
                    }
                    // this.y += canvas.width/zoom
                }
                if (y > (canvas.height / zoom) + 0) {
    
                    for (let t = 0; t < glist.length; t++) {
                        glist[t].yleap = -((canvas.height / zoom) - 0)
                    }
                    // this.y -= canvas.width/zoom
                }
            }
    
    
    
            this.energy = g
            this.pushoutsto = p
            this.age = ag
            this.ll = ll
            // this.pushout = p
    
            // ////////////////////////////////////////console.log(this)
            this.hit = 1
            for (let t = 0; t < this.immune.length; t++) {
                globalnodes[this.immune[t]].head = 0
                globalnodes[this.immune[t]].w = this.w
                globalnodes[this.immune[t]].contextMarker = this.contextMarker
                globalnodes[this.immune[t]].finalhead = 1
            }
    
    
    
            this.head = 1
    
    
        }
        disconnect(node) {
            if (this.superdead == 1) {
                return
            }
            if (this.dcon.includes(node.id)) {
                return
            }
    
            // //////////////////////////////////console.log(node, this)
            // if(node.neighbors.includes(globalnodes.indexOf(this))){
            let ni = node.id
            let nit = this.id
            this.neighbors.splice(this.neighbors.indexOf(ni), 1)
            node.neighbors.splice(node.neighbors.indexOf(nit), 1)
            this.stupidneighbors[ni] = 0
            node.stupidneighbors[nit] = 0
            // }
            // if(this.neighbors.includes(globalnodes.indexOf(node))){
            this.neighbors.splice(this.neighbors.indexOf(ni), 1)
            node.neighbors.splice(node.neighbors.indexOf(nit), 1)
            // }
    
            this.dcon.push(ni)
            node.dcon.push(nit)
            this.dmark = 1
            node.dmark = 1
    
            let supp = 0
            for (let t = 0; t < this.neighbors.length; t++) {
                if (this.neighbors[t] == this.id) {} else {
                    supp = 1
                }
            }
            if (supp == 0) {
                this.head = 1
            }
    
    
    
            let supph = 0
            for (let t = 0; t < node.neighbors.length; t++) {
                if (node.neighbors[t] == node.id) {} else {
                    supph = 1
                }
            }
            if (supph == 0) {
                node.head = 1
            }
    
    
        }
        connect(node) {
            if (this.dead == 1) {
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
    
            if (globalnodes.indexOf(node) == globalnodes.indexOf(this)) {
                return
            }
            if (this.neighbors.includes(globalnodes.indexOf(node)) || node.neighbors.includes(globalnodes.indexOf(this))) {
                return
            }
    
    
            this.neighbors.push(globalnodes.indexOf(node))
            node.neighbors.push(globalnodes.indexOf(this))
    
            this.stupidneighbors[globalnodes.indexOf(node)] = 1
            node.stupidneighbors[globalnodes.indexOf(this)] = 1
    
            if (this.neighbors.length > 2) {
                ////////////////////console.log(this)
            }
    
            return
    
            if (this.type == 6) {
                this.neighbors.push(globalnodes.indexOf(node))
                node.neighbors.push(globalnodes.indexOf(this))
            } else if (this.type == 0 || this.type == 3) {
                if (this.type == 3) {
                    if (node.type != 3 && node.type != 1) {
    
                        this.neighbors.push(globalnodes.indexOf(node))
                        node.neighbors.push(globalnodes.indexOf(this))
                    }
                } else {
    
                    this.neighbors.push(globalnodes.indexOf(node))
                    node.neighbors.push(globalnodes.indexOf(this))
                }
            } else {
                if (this.type == 1) {
                    if ((this.neighbors.length < 4 || node.type == 6)) {
                        if (node.type != 1 && node.type != 3) {
                            this.neighbors.push(globalnodes.indexOf(node))
                            node.neighbors.push(globalnodes.indexOf(this))
                        }
                    }
                }
                if (this.type == 2) {
                    if (this.neighbors.length < 3 || node.type == 6) {
                        if (node.type != 2) {
                            this.neighbors.push(globalnodes.indexOf(node))
                            node.neighbors.push(globalnodes.indexOf(this))
                        }
                    }
                }
                if (this.type == 4) {
                    if ((this.neighbors.length < 1 || node.type == 6) && node.type != 4 && node.type != 5) {
                        this.neighbors.push(globalnodes.indexOf(node))
                        node.neighbors.push(globalnodes.indexOf(this))
                    }
                }
                if (this.type == 5) {
                    if ((this.neighbors.length < 1 || node.type == 6) && node.type != 4) {
                        this.neighbors.push(globalnodes.indexOf(node))
                        node.neighbors.push(globalnodes.indexOf(this))
                    }
                }
    
    
            }
        }
        aged() {
    
    
    
            this.trueage++
    
            let len = this.genestring.split('').length
    
            if (this.energy > genelengthcost && codonusage == 1) {
                if(genelengthcost < 0){
                    this.energy -= genelengthcost * len * ((seedRandom()*2)*(freec / freen)) 
                }else{
                    this.energy -= genelengthcost * len
                }
            }
            if (codonusage == 1) {
                this.nodeEnergyCost += genelengthcost * len
    
    
            }
    
            if (this.drag == 1) {
                this.age += 1.25
                if (this.energy > dragcost) {
                    if(dragcost < 0){
                        this.energy -= dragcost * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= dragcost * 1
                    }
    
    
                }
                this.nodeEnergyCost += dragcost
            }
    
            if (this.life != 1) {
                this.age++
            } else {
                if (this.energy > longevitycost) {
                    if(longevitycost < 0){
                        this.energy -= longevitycost * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= longevitycost * 1   * ((seedRandom()*2)*(freec / freen))   //unique function, kinda needs freec  //  * ((seedRandom()*2)*(freec / freen))  is new
                    }
                    this.age += .25
                } else {
                    this.age++
                }
    
                this.nodeEnergyCost += longevitycost
            }

            if (this.energy < baseCostOfNode) {
                this.age+= 3 //10
            }


        }
        drive() {
    
    
            if (this.dead == 1) {
    
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
    
            this.hit = 0
            this.fed = 0
            if (this.produce == 1) {
                if (this.energy < this.gencap) {
                    this.energy += ((this.generate * 1)) * ((seedRandom()*2)*(freec / freen)) //same on a curve
                }
            }
    
    
            if (this.motor == 1) {
                if (this.energy >= movementCost) {
                    this.x += Math.cos(this.pushout) * 3 * worldscaler
                    this.y += Math.sin(this.pushout) * 3 * worldscaler
                    if(movementCost < 0){
                        this.energy -= movementCost * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= movementCost * 1
                    }
                }
                this.nodeEnergyCost += movementCost
            }
    
            if (this.pusher == 1) {
                if (this.energy >= movementCost) {
 
                    for(let t = 0;t<this.neighbors.length;t++){

                        // globalnodes[this.neighbors[t]].x += Math.cos(globalnodes[this.neighbors[t]].pushout) * (3/this.neighbors.length) * worldscaler
                        // globalnodes[this.neighbors[t]].y += Math.sin(globalnodes[this.neighbors[t]].pushout) * (3/this.neighbors.length) * worldscaler


                        if(globalnodes[this.neighbors[t]].anchor != 1){
                            globalnodes[this.neighbors[t]].x += Math.cos(this.pushout) * (3/this.neighbors.length) * worldscaler
                            globalnodes[this.neighbors[t]].y += Math.sin(this.pushout) * (3/this.neighbors.length) * worldscaler
    

                                if (edgeLoop != 1) {
                        
                                    if (globalnodes[this.neighbors[t]].x >= canvas.width / zoom) {
                                        this.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                                        // this.pushoutsto = this.pushout
                                    }
                                    if (globalnodes[this.neighbors[t]].y >= canvas.height / zoom) {
                                        this.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                                        // this.pushoutsto = this.pushout
                                    }
                                    if (globalnodes[this.neighbors[t]].x <= 0) {
                                        this.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                                        // this.pushoutsto = this.pushout
                                    }
                                    if (globalnodes[this.neighbors[t]].y <= 0) {
                                        this.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                                        // this.pushoutsto = this.pushout
                                    }
                        
                                }

                                if(globalnodes[this.neighbors[t]].touchey == 1){
                                    globalnodes[this.neighbors[t]].touchey = 0
                                    this.pushout += (Math.PI / (((seedRandom() - .5) * 4) + .01))/10
                                }


                                if (edgeLoop != 1) {
                            globalnodes[this.neighbors[t]].x = Math.max(0, globalnodes[this.neighbors[t]].x)
                            globalnodes[this.neighbors[t]].x = Math.min(canvas.width / zoom, globalnodes[this.neighbors[t]].x)
                            globalnodes[this.neighbors[t]].y = Math.max(0, globalnodes[this.neighbors[t]].y)
                            globalnodes[this.neighbors[t]].y = Math.min(canvas.height / zoom, globalnodes[this.neighbors[t]].y)
                                }
                            
                        }
                        
    
                    }
                    if(movementCost < 0){
                        this.energy -= movementCost * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= movementCost * 1
                    }
                }
                this.nodeEnergyCost += movementCost
            }
            if (edgeLoop != 1) {
    
                if (this.x >= canvas.width / zoom) {
                    this.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                    // this.pushoutsto = this.pushout
                }
                if (this.y >= canvas.height / zoom) {
                    this.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                    // this.pushoutsto = this.pushout
                }
                if (this.x <= 0) {
                    this.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                    // this.pushoutsto = this.pushout
                }
                if (this.y <= 0) {
                    this.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                    // this.pushoutsto = this.pushout
                }
    
            }
        }
        make(context = canvas_context) {
    
    
            if(edgeLoop == 1){
    
                if(keysPressed['d']){
                    this.lastx+=smellScaler
                    this.x+=smellScaler
                }
                if(keysPressed['a']){
                    this.x-=smellScaler
                    this.lastx-=smellScaler
                }
                if(keysPressed['s']){
                    this.y+=smellScaler
                    this.lasty+=smellScaler
                }
                if(keysPressed['w']){
                    this.y-=smellScaler
                    this.lasty-=smellScaler
                }
            }
    
            if (dumbdoton == 1) {
    
                dumbby.check(this)
            }
    
            if (edgeLoop != 1) {
    
                this.x = Math.max(0, this.x)
                this.x = Math.min(canvas.width / zoom, this.x)
                this.y = Math.max(0, this.y)
                this.y = Math.min(canvas.height / zoom, this.y)
    
            }
    
            let bukkt = Math.floor(this.x/bucketsize)
            let bukkk = Math.floor(this.y/bucketsize) 
    
    
    
            // bukkt += globuckets.length
            // bukkt%=globuckets.length
            // bukkk += globuckets[0].length
            // bukkk%=globuckets[0].length
    
    
    
            // //////////////console.log(bukkt, bukkk)
    
            bukkt = Math.min(Math.max(0, bukkt),globuckets.length-1)
            // // //////////////console.log(bukkk, bukkt, globuckets) 
            bukkk = Math.min(Math.max(0, bukkk),globuckets[bukkt].length-1)
            this.bucket = globuckets[bukkt][bukkk].id
            this.idk = globuckets[bukkt][bukkk].idk 
            this.idt = globuckets[bukkt][bukkk].idt
            globuckets[bukkt][bukkk].guys.push(globalnodes.indexOf(this))
            ////////////////console.log(bukkk, bukkt, globuckets)
            
            // if(this.type <3){
            //     // humanpix1.data[]
            //    let ter =  deindexer(Math.floor((this.x)/10), Math.floor(this.y/10), Math.floor(canvas.width/10))
            //    if(this.type == 0){
            //     humanpix1.data[ter]+=this.subr
            //     humanpix1.data[ter+1]+=this.subg
            //     humanpix1.data[ter+2]+=this.subb
            //    }else if(this.type == 1){
            //     humanpix1.data[ter]+=this.subr
            //     humanpix1.data[ter+1]+=this.subg
            //     humanpix1.data[ter+2]+=this.subb
            //    }else if(this.type == 2){
            //     humanpix1.data[ter]+=this.subr
            //     humanpix1.data[ter+1]+=this.subg
            //     humanpix1.data[ter+2]+=this.subb
            //    }
    
            // }else if(this.type <6){
            //     let ter =  deindexer(Math.floor((this.x)/10), Math.floor(this.y/10), Math.floor(canvas.width/10))
            //     let nup = this.type-3
            //     if(nup == 0){
            //         humanpix2.data[ter]+=this.subr
            //         humanpix2.data[ter+1]+=this.subg
            //         humanpix2.data[ter+2]+=this.subb
            //     }else if(nup == 1){
            //         humanpix2.data[ter]+=this.subr
            //         humanpix2.data[ter+1]+=this.subg
            //         humanpix2.data[ter+2]+=this.subb
            //     }else if(nup == 2){
            //         humanpix2.data[ter]+=this.subr
            //         humanpix2.data[ter+1]+=this.subg
            //         humanpix2.data[ter+2]+=this.subb
            //     }
    
            // }else if(this.type <9){
            //     let ter =  deindexer(Math.floor((this.x)/10), Math.floor(this.y/10), Math.floor(canvas.width/10))
            //     let nup = this.type-6
            //     if(nup == 0){
            //         humanpix3.data[ter]+=this.subr
            //         humanpix3.data[ter+1]+=this.subg
            //         humanpix3.data[ter+2]+=this.subb
            //     }else if(nup == 1){
            //         humanpix3.data[ter]+=this.subr
            //         humanpix3.data[ter+1]+=this.subg
            //         humanpix3.data[ter+2]+=this.subb
            //     }else if(nup == 2){
            //         humanpix3.data[ter]+=this.subr
            //         humanpix3.data[ter+1]+=this.subg
            //         humanpix3.data[ter+2]+=this.subb
            //     }
    
    
            // }else if(this.type <12){
    
            //     let ter =  deindexer(Math.floor((this.x)/10), Math.floor(this.y/10), Math.floor(canvas.width/10))
            //     let nup = this.type-9
            //     if(nup == 0){
            //         humanpix4.data[ter]+=this.subr
            //         humanpix4.data[ter+1]+=this.subg
            //         humanpix4.data[ter+2]+=this.subb
            //     }else if(nup == 1){
            //         humanpix4.data[ter]+=this.subr
            //         humanpix4.data[ter+1]+=this.subg
            //         humanpix4.data[ter+2]+=this.subb
            //     }else if(nup == 2){
            //         humanpix4.data[ter]+=this.subr
            //         humanpix4.data[ter+1]+=this.subg
            //         humanpix4.data[ter+2]+=this.subb
            //     }
    
            // }else if(this.type <15){
    
            //     let ter =  deindexer(Math.floor((this.x)/10), Math.floor(this.y/10), Math.floor(canvas.width/10))
            //     let nup = this.type-12
            //     if(nup == 0){
            //         humanpix5.data[ter]+=this.subr
            //         humanpix5.data[ter+1]+=this.subg
            //         humanpix5.data[ter+2]+=this.subb
            //     }else if(nup == 1){
            //         humanpix5.data[ter]+=this.subr
            //         humanpix5.data[ter+1]+=this.subg
            //         humanpix5.data[ter+2]+=this.subb
            //     }else if(nup == 2){
            //         humanpix5.data[ter]+=this.subr
            //         humanpix5.data[ter+1]+=this.subg
            //         humanpix5.data[ter+2]+=this.subb
            //     }
    
            // }else if(this.type <18){
    
            //     let ter =  deindexer(Math.floor((this.x)/10), Math.floor(this.y/10), Math.floor(canvas.width/10))
            //     let nup = this.type-15
            //     if(nup == 0){
            //         humanpix6.data[ter]+=this.subr
            //         humanpix6.data[ter+1]+=this.subg
            //         humanpix6.data[ter+2]+=this.subb
            //     }else if(nup == 1){
            //         humanpix6.data[ter]+=this.subr
            //         humanpix6.data[ter+1]+=this.subg
            //         humanpix6.data[ter+2]+=this.subb
            //     }else if(nup == 2){
            //         humanpix6.data[ter]+=this.subr
            //         humanpix6.data[ter+1]+=this.subg
            //         humanpix6.data[ter+2]+=this.subb
            //     }
            // }
    
    
    
            if (smellFlip == 1) {
    
                if (this.type < 3) {
                    let ter = deindexer(Math.floor((this.x) / smellScaler), Math.floor(this.y / smellScaler), Math.floor(canvas.width / smellScaler))
                    if (this.type == 0) {
                        pix1.data[ter] += this.stinkRate
                    } else if (this.type == 1) {
                        pix1.data[ter + 1] += this.stinkRate
                    } else if (this.type == 2) {
                        pix1.data[ter + 2] += this.stinkRate
                    }
    
                } else if (this.type < 6) {
                    let ter = deindexer(Math.floor((this.x) / smellScaler), Math.floor(this.y / smellScaler), Math.floor(canvas.width / smellScaler))
                    let nup = this.type - 3
                    if (nup == 0) {
                        pix2.data[ter] += this.stinkRate
                    } else if (nup == 1) {
                        pix2.data[ter + 1] += this.stinkRate
                    } else if (nup == 2) {
                        pix2.data[ter + 2] += this.stinkRate
                    }
    
                } else if (this.type < 9) {
                    let ter = deindexer(Math.floor((this.x) / smellScaler), Math.floor(this.y / smellScaler), Math.floor(canvas.width / smellScaler))
                    let nup = this.type - 6
                    if (nup == 0) {
                        pix3.data[ter] += this.stinkRate
                        //  
                    } else if (nup == 1) {
                        pix3.data[ter + 1] += this.stinkRate
                    } else if (nup == 2) {
                        pix3.data[ter + 2] += this.stinkRate
                    }
    
    
                } else if (this.type < 12) {
    
                    let ter = deindexer(Math.floor((this.x) / smellScaler), Math.floor(this.y / smellScaler), Math.floor(canvas.width / smellScaler))
                    let nup = this.type - 9
                    if (nup == 0) {
                        pix4.data[ter] += this.stinkRate
    
                    } else if (nup == 1) {
                        pix4.data[ter + 1] += this.stinkRate
                    } else if (nup == 2) {
                        pix4.data[ter + 2] += this.stinkRate
                    }
    
                } else if (this.type < 15 || this.type == 19) { //male node 
    
                    let ter = deindexer(Math.floor((this.x) / smellScaler), Math.floor(this.y / smellScaler), Math.floor(canvas.width / smellScaler))
                    let nup = this.type - 12
                    if (nup == 0) { //male node
                        pix5.data[ter] += this.stinkRate
    
                    } else if (nup == 1 || this.type == 19) {
                        pix5.data[ter + 1] += this.stinkRate
                    } else if (nup == 2) {
                        pix5.data[ter + 2] += this.stinkRate
                    }
    
                } else if (this.type < 210000) {
    
                    let ter = deindexer(Math.floor((this.x) / smellScaler), Math.floor(this.y / smellScaler), Math.floor(canvas.width / smellScaler))
                    let nup = this.type - 15
                    if (nup == 0) {
                        pix6.data[ter] += this.stinkRate
                    } else if (nup == 1) {
                        pix6.data[ter + 1] += this.stinkRate
                    } else if (nup == 5) {
                        pix3.data[ter + 0] += this.stinkRate
                    } else if (nup == 7) { //disease?
                        pix6.data[ter + 2] += this.stinkRate
                    }
    
    
    
                }
            }
    
            let worldscaler = (worldscale / 8)
            if (this.dead == 1) {
    
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                // this.x = 999999
                // this.y = 999999+(seedRandom()*100000)
                if (this.firsty != 1) {
                    this.inert = 1
                    this.firsty = 1
                    this.body = new Circle(this.x, this.y, 3 * (worldscaler), "#0044FF")
                }
                return
            }
    
    
            if (tempon == 1) {
                if (this.anchor != 1) {
                    this.x += ((seedRandom() - .5) / temperatureInvert) * temperature
                    this.y += ((seedRandom() - .5) / temperatureInvert) * temperature
                } else {
    
                    this.x += (((seedRandom() - .5) / temperatureInvert) * temperature) / 100
                    this.y += (((seedRandom() - .5) / temperatureInvert) * temperature) / 100
                }
            }
    
            //temperature proxy
            if (this.type == 15) {
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF8800")
                if (this.firsty != 1) {
    
                    this.subr = 255
                    this.subg = 200
                    this.subb = 16
                    this.prime = 59
                    this.gill = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 4 * (worldscaler), "#DDDD66", 5, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
    
    
            }
            if (this.gill == 1) {
                if(this.restrictgill == 1){
                    let xdif = Math.abs(this.lastx - this.x)
                    let ydif = Math.abs(this.lasty - this.y)
                    this.energy += ((((xdif + ydif) * gillconstant) / worldscaler)*(1/3))*(freec / freen) //1/2
                    this.lastx = this.x
                    this.lasty = this.y
                }else{

                    let xdif = Math.abs(this.lastx - this.x)
                    let ydif = Math.abs(this.lasty - this.y)
                    this.energy += (((xdif + ydif) * gillconstant) / worldscaler)*(freec / freen)
                    this.lastx = this.x
                    this.lasty = this.y
                }
            }
    
            if (this.type == 21) { 
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF8800")
                if (this.firsty != 1) {
    
                    this.subr = (16 * 11) + 11
                    this.subg = (16 * 8) + 8
                    this.subb = 255
                    this.prime = 83
                    this.ear = 1
                    this.motor = 1
                    this.gill = 1
                    this.restrictgill = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 6 * (worldscaler), "#AA88ff", 3, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
    
    
            }
    
            if (this.type == 22) {
    
                this.subr = (16 * 5) + 4
                this.subg = (16 * 3) + 2
                this.subb = 16
                this.prime = 53
                this.drag = 1
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 4 * (worldscaler), "#543210", 6, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
    
    
            }
    
            if (this.type == 19) {
    
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.subr = 255
                    this.subg = 200
                    this.subb = 200
                    this.prime = 73
                    this.male = 1
                    this.fertile = 1
                    this.inert = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 4 * (worldscaler), "#FFAAAA", 1, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
    
    
            }
    
    
    
            if (this.type == 0) {
                if (this.firsty != 1) {
                    this.prime = 2 //19
                    this.subr = 255
                    this.subg = 255
                    this.subb = 255
                    this.inert = 1
                    this.firsty = 1
                    this.body = new Circle(this.x, this.y, 3 * (worldscaler), "#ffffff")
                    if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
                        this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#ffffff", 3, 0, 0, (this.pushout) + Math.PI)
                    }
                }
                if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                } else {
    
                    this.body.x = this.x
                    this.body.y = this.y
                }
            }
            if (this.type == 1) {
                // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF00aa")
                // this.body = new Circle(this.x, this.y, 3, "#AA0055")
                if (this.firsty != 1) {
                    this.subr = 255
                    this.subg = 0
                    this.subb = 128
                    this.prime = 2
                    this.rotor = 1
                    this.armor = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 4 * (worldscaler), "#AA0055", 4, 0, 0, (this.pushout) + Math.PI)
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) + Math.PI
            }
            if (this.type == 2) {
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.subr = 255
                    this.subg = 255
                    this.subb = 0
                    this.prime = 3
                    this.armor = 1
                    this.motor = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#ffCc00", 3, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) 
            }
            if (this.type == 3) {
                if (this.firsty != 1) {
                    this.subr = 128
                    this.subg = 0
                    this.subb = 255
                    this.prime = 5
                    this.rotor = 1
                    this.motor = 1
                    this.firsty = 1
                    // this.body = new Circle(this.x, this.y, 3.5, "#8800ff")
    
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#8800ff", 3, 0, 0, (this.pushout) + Math.PI)
                    if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
                        this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#8800ff", 3, 0, 0, (this.pushout) + Math.PI)
                    }
                }
    
                if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                } else {
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                    // this.body.x = this.x
                    // this.body.y = this.y
                }
    
            }
            if (this.type == 4) {
                // this.body = new Circle(this.x, this.y, 4, "#00FF00")
                if (this.firsty != 1) {
                    this.subr = 0
                    this.subg = 255
                    this.subb = 0
                    this.prime = 7
                    this.produce = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#00FF00", 6, 0, 0, (this.pushout) + Math.PI)
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) + Math.PI
            }
            if (this.type == 5) {
                // this.body = new Circle(this.x, this.y, 5, "#FF0000")
                if (this.firsty != 1) {
                    this.subr = 255
                    this.subg = 0
                    this.subb = 0
                    this.prime = 23
                    this.armor = 1
                    this.mouth = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#FF0000", 5, 0, 0, (this.pushout) + Math.PI)
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) + Math.PI
            }
            if (this.type == 6) {
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.subr = 255
                    this.subg = 128
                    this.subb = 0
                    this.prime = 11
                    this.armor = 1
                    this.life = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#FF8800", 4, 0, 0, (this.pushout) + Math.PI)
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) + Math.PI
            }
            if (this.type == 20) {
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.subr = (9*16)+8
                    this.subg = (2*16)+7
                    this.subb = (5*16)+4
                    this.prime = 79 
                    this.pusher = 1
                    this.armor = 1
                    // this.produce = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#982754", 3, 0, 0, (this.pushout) + Math.PI)
                } 
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) + Math.PI
            }
            if (this.type == 7) {
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.subr = 0
                    this.subg = 255
                    this.subb = 255
                    this.prime = 13
                    this.produce = 1
                    this.motor = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#00FFFF", 3, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 8) {
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.subr = 0
                    this.subg = 255
                    this.subb = 64
                    this.prime = 17
                    this.produce = 1
                    this.rotor = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#228844", 1, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 9) {
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.subr = 64
                    this.subg = 64
                    this.subb = 255
                    this.prime = 29
                    this.anchor = 1
                    this.produce = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#4499FF", 5, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 10) {
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.subr = 176
                    this.subg = 100
                    this.subb = 140
                    this.prime = 31
                    this.anchor = 1
                    this.armor = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#AA5678", 4, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 11) {
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.subr = 176
                    this.subg = 176
                    this.subb = 176
                    this.prime = 37
                    this.piston = 1
                    this.produce = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 6 * (worldscaler), "#AAFFAA", 2, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 16) {
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.subr = 128
                    this.subg = 0
                    this.subb = 0 
                    this.prime = 61
                    this.suck = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 6 * (worldscaler), "#880000", 1, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
    
            if (this.type == 17) {
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.subr = 63
                    this.subg = 63
                    this.subb = 63
                    this.prime = 67
                    this.nose = 1
                    this.armor = 1 //this is because 1. the smell isnt always on, making this part useless, 2. the head turns already, this needs something more valuable to make up for stationary
                    this.noserotor = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 4 * (worldscaler), "#555555", 4, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 18) {
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.subr = 20
                    this.subg = 40
                    this.subb = 180
                    this.prime = 71
                    this.nose = 1
                    this.nosemotor = 1
                    this.motor = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 4 * (worldscaler), "#2233CC", 3, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 12) {
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.subr = 176
                    this.subg = 128
                    this.subb = 128
                    this.prime = 41
                    this.piston = 1
                    this.armor = 1
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 6 * (worldscaler), "#AA8888", 2, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
    
            if (this.type == 13) {
                if (this.firsty != 1) {
                    this.prime = 43
                    this.subr = 179
                    this.subg = 0
                    this.subb = 179
                    this.inert = 1
                    this.fertile = 1
                    this.firsty = 1
                    this.body = new Circle(this.x, this.y, 3.5 * (worldscaler), "#FF44bb")
                    if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
                        this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#FF44bb", 3, 0, 0, (this.pushout) + Math.PI)
                    }
                }
                if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                } else {
    
                    this.body.x = this.x
                    this.body.y = this.y
                }
            }
            if (this.type == 14) {
                if (this.firsty != 1) {
                    this.prime = 47
                    this.subr = 128
                    this.subg = 145
                    this.subb = 0
                    // this.inert = 1
                    this.life = 1
                    this.produce = 1
                    this.firsty = 1
                    // this.body = new Circle(this.x, this.y, 3, "#889900")
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#889900", 5, 0, 0, (this.pushout) + Math.PI)
                    if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
                        this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#889900", 5, 0, 0, (this.pushout) + Math.PI)
                    }
                }
                if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                } else {
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                    // this.body.x = this.x
                    // this.body.y = this.y
                }
            }
    
            // ////////////console.log(this)
            this.prime = primes[this.type]
            this.body.type = this.type 
    
            if (magnetism > 0) {
                if (this.maghit != 1) {
                    this.maghit = 1
                    if(typeof this.charge == "undefined"){
                        //////console.log("hit")
                        this.charge = 0
                    }
                    this.magnet = new CircleFill(this.x, this.y, magnetradius * this.magratio * worldscaler, magnetcolors[(this.charge + 1)])
                } else {
                    this.magnet.x = this.x
                    this.magnet.y = this.y
                }
                if (magdisplay == 1) {
                    if (this.charge != 0) { // change magnet cost for netural at request
                        // context.globalAlpha = this.linkApha
    
                        if (!keysPressed['7']) {
                            this.magnet.draw(context)
                        }
                        context.globalAlpha = 1
                        if (this.energy > magnetcost) {
                            if(magnetcost < 0){
                                this.energy -= magnetcost * 1 * ((seedRandom()*2)*(freec / freen)) 
                            }else{
                                this.energy -= magnetcost * 1
                            }
                        }
    
                        this.nodeEnergyCost += magnetcost
                    }else{

                        // this.energy -= magnetcost * 1
                        // this.nodeEnergyCost += magnetcost
                    }
                } else {
                    if (magmindisp == 1) {
    
                    }
                }
            }
    
            if (viewStyle == 4 || viewStyle == 6 || viewStyle == 6) {
                this.subcolor = `rgb(${(globalnodes[(this.shead)].r)},${(globalnodes[(this.shead)].g)},${ (globalnodes[(this.shead)].b)})`
                if (keysPressed['v']) {
                    this.subcolor = `rgb(${(globalnodes[(this.shead)].p)},${(globalnodes[(this.shead)].z)},${ (globalnodes[(this.shead)].q)})`
                }
                if (keysPressed['w']) {
                    this.subcolor = `rgb(${(globalnodes[(this.shead)].m)},${(globalnodes[(this.shead)].p)},${ (globalnodes[(this.shead)].z)})`
                }
                if (keysPressed['z']) {
                    this.subcolor = `rgb(${(globalnodes[(this.shead)].z)},${(globalnodes[(this.shead)].r)},${ (globalnodes[(this.shead)].m)})`
                }
    
                if (keysPressed['2']) {
                    this.subcolor = `rgb(${(globalnodes[(this.shead)].g)},${(globalnodes[(this.shead)].b)},${ (globalnodes[(this.shead)].q)})`
                }
    
    
                if (viewStyle == 6) {
                    this.subcolor = `rgb(${(globalnodes[(this.shead)][viewrota[rota%viewrota.length]])},${(globalnodes[(this.shead)][viewrota[(rota+1)%viewrota.length]])},${ (globalnodes[(this.shead)][viewrota[(rota+2)%viewrota.length]])})`
    
                }
    
    
                this.body.parent = this
                this.parent = this
            }
            if (viewStyle == 5 || viewStyle == 7) {
                this.subcolor = `rgb(${(((globalnodes[(this.shead)].r*3) + this.subr)/4)},${(((globalnodes[(this.shead)].g*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].b*3)+ this.subb)/4})`
                if (keysPressed['v']) {
                    this.subcolor = `rgb(${(((globalnodes[(this.shead)].p*3) + this.subr)/4)},${(((globalnodes[(this.shead)].z*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].q*3)+ this.subb)/4})`
                }
                if (keysPressed['w']) {
                    this.subcolor = `rgb(${(((globalnodes[(this.shead)].m*3) + this.subr)/4)},${(((globalnodes[(this.shead)].p*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].z*3)+ this.subb)/4})`
                }
    
    
                if (keysPressed['z']) {
                    this.subcolor = `rgb(${(((globalnodes[(this.shead)].z*3) + this.subr)/4)},${(((globalnodes[(this.shead)].r*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].m*3)+ this.subb)/4})`
                }
                if (keysPressed['2']) {
                    this.subcolor = `rgb(${(((globalnodes[(this.shead)].g*3) + this.subr)/4)},${(((globalnodes[(this.shead)].b*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].q*3)+ this.subb)/4})`
                }
    
    
                if (viewStyle == 7) {
                    this.subcolor = `rgb(${(((globalnodes[(this.shead)][viewrota[rota%viewrota.length]]*3) + this.subr)/4)},${(((globalnodes[(this.shead)][viewrota[(rota+1)%viewrota.length]]*3) + this.subg)/4)},${ ((globalnodes[(this.shead)][viewrota[(rota+2)%viewrota.length]]*3)+ this.subb)/4})`
    
                }
                this.body.parent = this
                this.parent = this
            }
    
    
    
    
            // if(tempon == 1){
            //     if(this.anchor != 1){
            //         this.x+=((seedRandom()-.5)/temperatureInvert)*temperature
            //         this.y+=((seedRandom()-.5)/temperatureInvert)*temperature
            //     }else{
    
            //         this.x+=(((seedRandom()-.5)/temperatureInvert)*temperature)/100
            //         this.y+=(((seedRandom()-.5)/temperatureInvert)*temperature)/100
            //     }
            // }
    
            //temperature proxy
            // if(this.age > maxage*.1){
            //     this.x+=(seedRandom()-.5)/100
            //     this.y+=(seedRandom()-.5)/100
            //     if(this.age > maxage*.5){
            //         this.x+=(seedRandom()-.5)/50
            //         this.y+=(seedRandom()-.5)/50
            //         if(this.age > maxage*.9){
            //             this.x+=(seedRandom()-.5)*.04
            //             this.y+=(seedRandom()-.5)*.04
            //         }
            //     }
            // }
    
            // if (edgeLoop != 1) { //redundant
    
            //     this.x = Math.max(0, this.x)
            //     this.x = Math.min(canvas.width / zoom, this.x)
            //     this.y = Math.max(0, this.y)
            //     this.y = Math.min(canvas.height / zoom, this.y)
    
            // }
            // if(this.x > canvas.width*.5){
            //     this.x = 0
            // }
            // if(this.x < 0){
            //     this.x =  canvas.width*.5
            // }
            // if(this.y > canvas.width*.5){
            //     this.y = 0
            // }
            // if(this.y < 0){
            //     this.y =  canvas.width*.5
            // }
    
        }
        drawBody(context = canvas_context) {
            if (this.anchor == 1) {
                if (this.energy >= anchorcost) {
    
                    if(anchorcost < 0){
                        this.energy -= anchorcost * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= anchorcost * 1
                    }
                }
                this.nodeEnergyCost += anchorcost
    
            }
            if (this.energy >= baseCostOfNode) {
                if (this.inert != 1) {
                    if(baseCostOfNode < 0){
                        this.energy -= baseCostOfNode * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= baseCostOfNode * 1
                    }
                }
            }
            if (this.fertile == 1) {
                if (this.energy >= fertilitycost) {
                    if(fertilitycost < 0){
                        this.energy -= fertilitycost * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= fertilitycost * 1 * ((seedRandom()*2)*(freec / freen))  //similar to longevity, may need this to function, here we go //  * ((seedRandom()*2)*(freec / freen)) is new
                    }
                    
                    this.energy *= ((fertilityratio-1)* 1 * ((freec / freen)) )+1
                }
            }
            if (this.fertile == 1) {
                this.nodeEnergyCost += fertilitycost
            }
    
            if (this.inert != 1) {
                this.nodeEnergyCost += baseCostOfNode
            }
            if (this.mouth == 1) {
                if (this.energy >= mouthCost) {
                    if(mouthCost < 0){
                        this.energy -= mouthCost * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= mouthCost * 1
                    }
                }
    
                this.nodeEnergyCost += mouthCost
            }
            if (this.suck == 1) {
                if (this.energy >= suckCost) {
                    if(suckCost < 0){
                        this.energy -= suckCost * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= suckCost * 1
                    }
                }
    
                this.nodeEnergyCost += suckCost
            }
            if (this.energy < 0) {
                this.energy = 0
            }
    
            if (this.dead == 1) {
    
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
    
            if (magnetonly == 1) {
    
            } else {
                if (keysPressed['7'] || pu.seebets == 1) {
    
                    if (this.bet > 1) {

                    if(iconsview == 1){

                        // context.drawImage(icons, this.type*16, 0, 16,16, this.x-8, this.y-8, 16,16)

                        context.imageSmoothingEnabled = true
                        context.save(); // Save the current canvas state

                        context.translate(this.x, this.y);       // Move the origin to the image center
                        context.rotate(this.a ? this.a+Math.PI : this.pushout);            // Rotate the canvas (in radians)
                        context.drawImage(
                            icons,
                            this.type * 32, 0,                   // Source x, y
                            32, 32,                              // Source width and height
                            -8*worldscaler, -8*worldscaler,                              // Destination x, y (draw centered)
                            16*worldscaler, 16*worldscaler                               // Destination width and height
                        );

                        context.restore();
                        context.imageSmoothingEnabled = false


                    }else{
                        this.body.draw(context)

                    }
                    }
                } else {
                    if(iconsview == 1){
                        context.imageSmoothingEnabled = true
                        context.save(); // Save the current canvas state

                        context.translate(this.x, this.y);       // Move the origin to the image center
                        context.rotate(this.a ? this.a+Math.PI : this.pushout);       // Rotate the canvas (in radians)
                        context.drawImage(
                            icons,
                            this.type * 32, 0,                   // Source x, y
                            32, 32,                              // Source width and height
                            -8*worldscaler, -8*worldscaler,                              // Destination x, y (draw centered)
                            16*worldscaler, 16*worldscaler                               // Destination width and height
                        );
                        context.restore();
                        context.imageSmoothingEnabled = false
                    }else{
                        this.body.draw(context)

                    }

                    if (edgeLoop == 1) {
    
    
    
                        let x1 = this.x
                        let y1 = this.y 
    
                        let flag = 0
                        if (this.x < worldscale * 2 || this.x > canvas.width - worldscale * 2) {
                            x1 = this.x;
                        
                            if (this.x < worldscale * 2) {
                                // Near top, wrap downward
                                this.x += canvas.width;
                                this.body.x += canvas.width;
                                this.body.body.x += canvas.width;
                            } else {
                                // Near bottom, wrap upward (negative offset)
                                this.x -= canvas.width;
                                this.body.x -= canvas.width;
                                this.body.body.x -= canvas.width;
                            }
                        
                            flag = 1;
                        }
                        
                        
    
                        if (this.y < worldscale * 2 || this.y > canvas.height - worldscale * 2) {
                            y1 = this.y;
                        
                            if (this.y < worldscale * 2) {
                                // Near top, wrap downward
                                this.y += canvas.height;
                                this.body.y += canvas.height;
                                this.body.body.y += canvas.height;
                            } else {
                                // Near bottom, wrap upward (negative offset)
                                this.y -= canvas.height;
                                this.body.y -= canvas.height;
                                this.body.body.y -= canvas.height;
                            }
                        
                            flag = 1;
                        }
                        
                        
    
    
    
                        if(flag == 1){
                            // ////////////////console.log(this.body)
                            if(iconsview == 1){
        
                                context.imageSmoothingEnabled = true
                                context.save(); // Save the current canvas state

                                context.translate(this.x, this.y);       // Move the origin to the image center
                                context.rotate(this.a ? this.a+Math.PI : this.pushout);          // Rotate the canvas (in radians)
                                context.drawImage(
                                    icons,
                                    this.type * 16, 0,                   // Source x, y
                                    16*worldscaler, 16*worldscaler,                              // Source width and height
                                    -8*worldscaler, -8*worldscaler,                              // Destination x, y (draw centered)
                                    16*worldscaler, 16*worldscaler                               // Destination width and height
                                );
        
                                context.restore();
                                context.imageSmoothingEnabled = false
                            }else{
                                this.body.draw(context)
        
                            }
    
                        }
    
                        this.x = x1
                        this.y = y1
                    }
                }
            }
            bodc++
        }
        time() {
            this.metatick++
            this.soundCD--
        
            this.caught = 0
            if(this.metatick > 10){
                this.metatick = 0
    
                if (this.dead == 1) {
                    if (this.firsty != 1) {
                        for (let t = 0; t < this.neighbors.length; t++) {
                            this.disconnect(globalnodes[this.neighbors[t]])
                        }
                    }
                    return
                }
                if (this.energy >= baseCostOfNode) {
                for (let t = 0; t < this.times.length; t++) {
                        this.ticks[t] += this.subticks[t]*10
                    }
                }
                if (this.energy >= baseCostOfNode) {
                for (let t = 0; t < this.times.length; t++) {
                        this.times[t] += (Math.cos(this.ticks[t]) * this.subrots[t])*10
                    }
                }
                if (this.energy >= baseCostOfNode) {
                for (let t = 0; t < this.pistontimes.length; t++) {
                        this.pistontimes[t] += (this.pistonticks[t])*10
                    }
                }
            }
        }
    
    
        push() {
            // this.pushoutsto = this.pushout
        }
    
    
        indexkill(index) {
            if (this.id < index) {} else if (this.id == index) {} else {
                this.id--
            }
            if (this.relative < index) {} else if (this.relative == index) {} else {
                this.relative--
            }
            if (this.shead < index) {} else if (this.shead == index) {} else {
                this.shead--
            }
            for (let t = 0; t < this.neighbors.length; t++) {
                if (this.neighbors[t] < index) {} else if (this.neighbors[t] == index) {
                    //////////////////////////////console.log("h")
                    // this.neighbors.splice(t,1)
                    //////////////////console.log(this)
                    // ////////////////console.log(this) 
                    this.dead = 1
                } else {
                    this.stupidneighbors[this.neighbors[t]] = false
                    this.neighbors[t]--
                    this.stupidneighbors[this.neighbors[t]] = 1
                }
            }
            for (let t = 0; t < this.link.list.length; t++) {
                // ////////////////////////////////console.log(this.link.list[t], index)
                if (this.link.list[t] < index) {} else if (this.link.list[t] == index) {
                    //////////////////////////////console.log("i")
                    // this.link.list.splice(t,1)
                } else {
                    this.link.list[t]--
                }
            }
            // ////////////////////////////console.log(this.neighbors)
            // this.stupidneighbors = []
            // for (let t = 0; t < this.neighbors.length; t++) {
            //     this.stupidneighbors[this.neighbors[t]] = 1
            // }
    
    
            for (let t = 0; t < this.immune.length; t++) {
                // ////////////////////////////////console.log(this.link.list[t], index)
                if (this.immune[t] < index) {} else if (this.immune[t] == index) {
                    //////////////////////////////console.log("r")
                    // this.immune.splice(t,1)
                } else {
                    this.stupidimmune[this.neighbors[t]] = false
                    this.immune[t]--
                    this.stupidimmune[this.neighbors[t]] = 1
                }
            }
    
    
            // this.stupidimmune = []
            // for (let t = 0; t < this.immune.length; t++) {
            //     this.stupidimmune[this.immune[t]] = 1
            // }
    
    
        }
    
        makeRotation() {
            if (this.dead == 1) {
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
            let z = 0
            // // this.link.list = []
            // if(this.linkup.length == 2){
            //     //////////////////console.log(this)
            // }
    
    
            if (this.rotor != 1) {
                return
            }
    
            // if(this.piston == 1){
            //     if(this.energy >= pistoncost){
            //         this.energy-=pistoncost
    
            //         this.pistontime+=this.pistonstep
    
            //         this.pistonpush += (Math.sin(this.pistontime)/1)
            //         this.pistonpush = Math.min(this.pistonpush, 12)
            //         this.pistonpush = Math.max(this.pistonpush, -12)
    
            //     }
            // }
    
    
            for (let t = 0; t < this.neighbors.length; t++) {
                let nd = globalnodes[this.neighbors[t]]
                if (!nd) {
                    ////////////////////////////console.log(globalnodes, this.neighbors[t])
                    continue
                }
                if (nd.dead == 1) {
                    continue
                }
                // if (this.stupidneighbors[t] == 1) {
    
                this.link.target = nd
                let j = 0
                let lf = (((this.lout + this.pistonpushes[z]) + (nd.lout + nd.pistonpushes[z])) / 2)
                // let mes = this.link.hypotenuse()
                // let a = this.link.angle()
    
    
                if (this.rotor == 1) {
                    this.lt.x = this.x + (Math.cos(((this.times[z]+ this.pushout))) * lf)
                    this.lt.y = this.y + (Math.sin(this.times[z] + this.pushout) * lf)
                    if (this.energy >= rotationCost) {
                        if(rotationCost < 0){
                            this.energy -= rotationCost * 1 * ((seedRandom()*2)*(freec / freen)) 
                        }else{
                            this.energy -= rotationCost * 1
                        }
    
    
                        if (this.link.target.anchor != 1) {
                            this.link.target.x = (this.link.target.x * (1 - this.rigs[z])) + (this.rigs[z] * this.lt.x)
                            this.link.target.y = (this.link.target.y * (1 - this.rigs[z])) + (this.rigs[z] * this.lt.y)
                        } else {
    
                            this.link.target.x = (this.link.target.x * (1 - (this.rigs[z] / 100))) + ((this.rigs[z] / 100) * this.lt.x)
                            this.link.target.y = (this.link.target.y * (1 - (this.rigs[z] / 100))) + ((this.rigs[z] / 100) * this.lt.y)
    
                        }
                        // if (this.type == 1 || this.type == 3) { 
                        nd.pushout = weightedAverageAngle([nd.pushout, this.times[z] + this.pushout],[(1), .05] )
                        // this.pushout = this.pushoutsto - this.times[z]
                        // }
                    } else {
    
                    }
    
    
                    this.nodeEnergyCost += rotationCost
                }
                // globalnodes[t].link.list.push(globalnodes.indexOf(this))
                // }
    
            z++
            z %= this.las.length
            }
    
    
    
    
        }
    
    
        makeEar(){
            if (this.dead == 1) {
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
            let z = 0
            this.eartick++
            if(this.eartick<this.earrate){
                return
            }
            this.eartick = 0
            if (this.ear != 1) {
                return
            }
            
            if(earCost < 0){
                this.energy -= earCost * 1 * ((seedRandom()*2)*(freec / freen)) 
            }else{
                this.energy -= earCost * 1
            }
    
            for(let t = 0;t<globsounds.length;t++){
    
                if(!(this.soundPref[globsounds[t].type] == 1)){
                    if(!(this.soundAvoid[globsounds[t].type] == 1)){
                        continue
                    }
                }
                let br = globsounds[t]
            if(edgeLoop == 1){
                
                br = findClosestWrappedPair([this, globsounds[t]], canvas.width, canvas.height).obj2
            }
                let er = this.earRadius+globsounds[t].radius   
                let xd = Math.abs(this.x-br.x)
                if(this.heard[`${globsounds[t].x},${globsounds[t].y}`] == 1){
                    continue
                }
                if(er < xd ){
                    let st = 2*worldscaler
                    if((st*globsounds[t].strength/((globsounds[t].radius/9)*worldscaler) < xd)){
                        this.heard[`${globsounds[t].x},${globsounds[t].y}`] = 1
                    }
                    continue
                }
                let yd = Math.abs(this.y-br.y)
                if(er < yd){
                    let st = 2*worldscaler
                    if((st*globsounds[t].strength/((globsounds[t].radius/9)*worldscaler)  < yd)){
                        this.heard[`${globsounds[t].x},${globsounds[t].y}`] = 1
                    }
                    continue
                }
                // //////console.log("k")
                if(this.soundPref[globsounds[t].type] == 1){
                    this.link.target = br
                    let a = this.link.angle()+Math.PI
                    // let cosa = Math.cos(a)
                    // let sin = Math.sin(a)
                    this.pushout =  weightedAverageAngle([a,this.pushout], [globsounds[t].strength/400,1])
                }
    
                if(this.soundAvoid[globsounds[t].type] == 1){
                    this.link.target = br
                    let a = this.link.angle()
                    // let cosa = Math.cos(a)
                    // let sin = Math.sin(a)
                    this.pushout = weightedAverageAngle([a,this.pushout], [globsounds[t].strength/400,1])
                    // //////console.log("w")
    
                }
            }
        }
    
        makeNose() {
            if (this.dead == 1) {
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
            let z = 0
            // // this.link.list = []
            // if(this.linkup.length == 2){
            //     //////////////////console.log(this)
            // }
    
    
            if (this.nose != 1) {
                return
            }
    
            // if(this.piston == 1){
            //     if(this.energy >= pistoncost){
            //         this.energy-=pistoncost
    
            //         this.pistontime+=this.pistonstep
    
            //         this.pistonpush += (Math.sin(this.pistontime)/1)
            //         this.pistonpush = Math.min(this.pistonpush, 12)
            //         this.pistonpush = Math.max(this.pistonpush, -12)
    
            //     }
            // }
    
    
            for (let t = 0; t < this.neighbors.length; t++) {
                // //////////////////////////////console.log()
                if (this.dead == 1) {
                    break
                }
                let nd = globalnodes[this.neighbors[t]]
                if (!nd) {
                    ////////////////////////////console.log(globalnodes, this.neighbors[t])
                    continue
                }
                if (nd.dead == 1) {
                    continue
                }
                // if (this.stupidneighbors[t] == 1) {
    
                this.link.target = nd
                let j = 0
                let lf = (((this.lout + this.pistonpushes[z]) + (nd.lout + nd.pistonpushes[z])) / 2)
                // let mes = this.link.hypotenuse()
                // let a = this.link.angle()
    
    
                if (this.nose == 1) {
    
                    let arcers = []
                    let zrcers = []
                    let pairups = []
    
    
    
                    for (let f = 0; f < nodetypes; f++) {
    
                        // ////////////////console.log(this.noseAvoid, this.nosePref)  
                        if (this.nosePref.includes(f)) {
                            // ////////////////console.log(f, this.nosePref)  
                            if (f < 3) {
                                let pad = []
                                let c = 0
                                let pairs = []
                                let mxes = []
                                for (let r = -2; r <= 2; r++) {
                                    for (let q = -2; q <= 2; q++) {
                                        let ter = deindexer(Math.floor((this.x + (r * smellScaler)) / smellScaler), Math.floor((this.y + (q * smellScaler)) / smellScaler), Math.floor(canvas.width / smellScaler)) % pix1.data.length
                                        pairs.push([pix1.data[ter + f], c, ter])
                                        c++
                                    }
                                }
                                pairs.sort((a, b) => a[0] > b[0] ? 1 : -1)
    
                                let goto = pairs[0][1]
                                if (pairs[0][0] < this.noseThresh) {
                                    goto = -1
                                } else {
                                    pairups.push(f)
                                }
                                if (goto == 1 || goto == 5 || goto == 0 || goto == 6) {
                                    canvas_context.color = "white"
    
                                    if (goto == 0 || goto == 6) {
                                        (arcers.push((Math.PI - (Math.PI / 8))))
                                    } else if (goto == 5) {
                                        arcers.push((Math.PI - (Math.PI / 12)))
                                    } else if (goto == 1) {
                                        arcers.push((Math.PI - (Math.PI / 6)))
                                    }
                                }
                                if (goto == 2 || goto == 7) {
                                    arcers.push((Math.PI - (Math.PI / 4)))
                                }
                                if (goto == 3 || goto == 4 || goto == 8 || goto == 9) {
                                    if (goto == 3) {
                                        arcers.push(((Math.PI / 6)))
                                    } else if (goto == 4) {
                                        arcers.push((Math.PI / 8))
                                    } else if (goto == 8) {
                                        arcers.push((Math.PI / 8))
                                    } else if (goto == 9) {
                                        arcers.push((Math.PI / 12))
                                    }
                                }
                                if (goto == 11 || goto == 10) {
                                    arcers.push((Math.PI))
                                }
                                if (goto == 12) {
                                    arcers.push(-1)
                                }
                                if (goto == 13 || goto == 14) {
                                    arcers.push(0)
                                }
                                if (goto == 15 || goto == 16 || goto == 20 || goto == 21) {
                                    if (goto == 15) {
                                        arcers.push(Math.PI + (Math.PI / 12))
                                    } else if (goto == 16 || goto == 20) {
                                        arcers.push(Math.PI + (Math.PI / 8))
                                    } else if (goto == 21) {
                                        arcers.push(Math.PI + (Math.PI / 6))
                                    }
                                }
                                if (goto == 17 || goto == 22) {
                                    arcers.push(Math.PI + (Math.PI / 4))
                                }
                                if (goto == 18 || goto == 19 || goto == 23 || goto == 24) {
                                    if (goto == 18 || goto == 24) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 3))
                                    } else if (goto == 19) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 3.5))
                                    } else if (goto == 23) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 2.5))
                                    }
                                }
                            } else if (f < 6) {
                                let pad = []
                                let c = 0
                                let pairs = []
                                let mxes = []
                                for (let r = -2; r <= 2; r++) {
                                    for (let q = -2; q <= 2; q++) {
                                        let ter = deindexer(Math.floor((this.x + (r * smellScaler)) / smellScaler), Math.floor((this.y + (q * smellScaler)) / smellScaler), Math.floor(canvas.width / smellScaler)) % pix1.data.length
                                        pairs.push([pix2.data[ter + (f - 3)], c, ter])
                                        c++
                                    }
                                }
                                pairs.sort((a, b) => a[0] > b[0] ? 1 : -1)
    
                                let goto = pairs[0][1]
                                if (pairs[0][0] < this.noseThresh) {
                                    goto = -1
                                } else {
                                    pairups.push(f)
                                }
                                if (goto == 1 || goto == 5 || goto == 0 || goto == 6) {
                                    canvas_context.color = "white"
    
                                    if (goto == 0 || goto == 6) {
                                        (arcers.push((Math.PI - (Math.PI / 8))))
                                    } else if (goto == 5) {
                                        arcers.push((Math.PI - (Math.PI / 12)))
                                    } else if (goto == 1) {
                                        arcers.push((Math.PI - (Math.PI / 6)))
                                    }
                                }
                                if (goto == 2 || goto == 7) {
                                    arcers.push((Math.PI - (Math.PI / 4)))
                                }
                                if (goto == 3 || goto == 4 || goto == 8 || goto == 9) {
                                    if (goto == 3) {
                                        arcers.push(((Math.PI / 6)))
                                    } else if (goto == 4) {
                                        arcers.push((Math.PI / 8))
                                    } else if (goto == 8) {
                                        arcers.push((Math.PI / 8))
                                    } else if (goto == 9) {
                                        arcers.push((Math.PI / 12))
                                    }
                                }
                                if (goto == 11 || goto == 10) {
                                    arcers.push((Math.PI))
                                }
                                if (goto == 12) {
                                    arcers.push(-1)
                                }
                                if (goto == 13 || goto == 14) {
                                    arcers.push(0)
                                }
                                if (goto == 15 || goto == 16 || goto == 20 || goto == 21) {
                                    if (goto == 15) {
                                        arcers.push(Math.PI + (Math.PI / 12))
                                    } else if (goto == 16 || goto == 20) {
                                        arcers.push(Math.PI + (Math.PI / 8))
                                    } else if (goto == 21) {
                                        arcers.push(Math.PI + (Math.PI / 6))
                                    }
                                }
                                if (goto == 17 || goto == 22) {
                                    arcers.push(Math.PI + (Math.PI / 4))
                                }
                                if (goto == 18 || goto == 19 || goto == 23 || goto == 24) {
                                    if (goto == 18 || goto == 24) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 3))
                                    } else if (goto == 19) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 3.5))
                                    } else if (goto == 23) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 2.5))
                                    }
                                }
                            } else if (f < 9) {
                                let pad = []
                                let c = 0
                                let pairs = []
                                let mxes = []
                                for (let r = -2; r <= 2; r++) {
                                    for (let q = -2; q <= 2; q++) {
                                        let ter = deindexer(Math.floor((this.x + (r * smellScaler)) / smellScaler), Math.floor((this.y + (q * smellScaler)) / smellScaler), Math.floor(canvas.width / smellScaler)) % pix1.data.length
                                        pairs.push([pix3.data[ter + (f - 6)], c, ter])
                                        c++
                                    }
                                }
                                pairs.sort((a, b) => a[0] > b[0] ? 1 : -1)
    
                                let goto = pairs[0][1]
                                if (pairs[0][0] < this.noseThresh) {
                                    goto = -1
                                } else {
                                    pairups.push(f)
                                }
                                if (goto == 1 || goto == 5 || goto == 0 || goto == 6) {
                                    canvas_context.color = "white"
    
                                    if (goto == 0 || goto == 6) {
                                        (arcers.push((Math.PI - (Math.PI / 8))))
                                    } else if (goto == 5) {
                                        arcers.push((Math.PI - (Math.PI / 12)))
                                    } else if (goto == 1) {
                                        arcers.push((Math.PI - (Math.PI / 6)))
                                    }
                                }
                                if (goto == 2 || goto == 7) {
                                    arcers.push((Math.PI - (Math.PI / 4)))
                                }
                                if (goto == 3 || goto == 4 || goto == 8 || goto == 9) {
    
                                    if (goto == 3) {
                                        arcers.push(((Math.PI / 6)))
                                    } else if (goto == 4) {
                                        arcers.push((Math.PI / 8))
                                    } else if (goto == 8) {
                                        arcers.push((Math.PI / 8))
                                    } else if (goto == 9) {
                                        arcers.push((Math.PI / 12))
                                    }
                                }
                                if (goto == 11 || goto == 10) {
                                    arcers.push((Math.PI))
                                }
                                if (goto == 12) {
                                    arcers.push(-1)
                                }
                                if (goto == 13 || goto == 14) {
                                    arcers.push(0)
                                }
                                if (goto == 15 || goto == 16 || goto == 20 || goto == 21) {
                                    if (goto == 15) {
                                        arcers.push(Math.PI + (Math.PI / 12))
                                    } else if (goto == 16 || goto == 20) {
                                        arcers.push(Math.PI + (Math.PI / 8))
                                    } else if (goto == 21) {
                                        arcers.push(Math.PI + (Math.PI / 6))
                                    }
                                }
                                if (goto == 17 || goto == 22) {
                                    arcers.push(Math.PI + (Math.PI / 4))
                                }
                                if (goto == 18 || goto == 19 || goto == 23 || goto == 24) {
                                    if (goto == 18 || goto == 24) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 3))
                                    } else if (goto == 19) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 3.5))
                                    } else if (goto == 23) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 2.5))
                                    }
                                }
                            } else if (f < 12) {
                                let pad = []
                                let c = 0
                                let pairs = []
                                let mxes = []
                                for (let r = -2; r <= 2; r++) {
                                    for (let q = -2; q <= 2; q++) {
                                        let ter = deindexer(Math.floor((this.x + (r * smellScaler)) / smellScaler), Math.floor((this.y + (q * smellScaler)) / smellScaler), Math.floor(canvas.width / smellScaler)) % pix1.data.length
                                        pairs.push([pix4.data[ter + (f - 9)], c, ter])
                                        c++
                                    }
                                }
                                pairs.sort((a, b) => a[0] > b[0] ? 1 : -1)
    
                                let goto = pairs[0][1]
                                if (pairs[0][0] < this.noseThresh) {
                                    goto = -1
                                } else {
                                    pairups.push(f)
                                }
                                if (goto == 1 || goto == 5 || goto == 0 || goto == 6) {
                                    canvas_context.color = "white"
    
                                    if (goto == 0 || goto == 6) {
                                        (arcers.push((Math.PI - (Math.PI / 8))))
                                    } else if (goto == 5) {
                                        arcers.push((Math.PI - (Math.PI / 12)))
                                    } else if (goto == 1) {
                                        arcers.push((Math.PI - (Math.PI / 6)))
                                    }
                                }
                                if (goto == 2 || goto == 7) {
                                    arcers.push((Math.PI - (Math.PI / 4)))
                                }
                                if (goto == 3 || goto == 4 || goto == 8 || goto == 9) {
    
                                    if (goto == 3) {
                                        arcers.push(((Math.PI / 6)))
                                    } else if (goto == 4) {
                                        arcers.push((Math.PI / 8))
                                    } else if (goto == 8) {
                                        arcers.push((Math.PI / 8))
                                    } else if (goto == 9) {
                                        arcers.push((Math.PI / 12))
                                    }
                                }
                                if (goto == 11 || goto == 10) {
                                    arcers.push((Math.PI))
                                }
                                if (goto == 12) {
                                    arcers.push(-1)
                                }
                                if (goto == 13 || goto == 14) {
                                    arcers.push(0)
                                }
                                if (goto == 15 || goto == 16 || goto == 20 || goto == 21) {
                                    if (goto == 15) {
                                        arcers.push(Math.PI + (Math.PI / 12))
                                    } else if (goto == 16 || goto == 20) {
                                        arcers.push(Math.PI + (Math.PI / 8))
                                    } else if (goto == 21) {
                                        arcers.push(Math.PI + (Math.PI / 6))
                                    }
                                }
                                if (goto == 17 || goto == 22) {
                                    arcers.push(Math.PI + (Math.PI / 4))
                                }
                                if (goto == 18 || goto == 19 || goto == 23 || goto == 24) {
                                    if (goto == 18 || goto == 24) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 3))
                                    } else if (goto == 19) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 3.5))
                                    } else if (goto == 23) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 2.5))
                                    }
                                }
                            } else if (f < 15) {
                                let pad = []
                                let c = 0
                                let pairs = []
                                let mxes = []
                                for (let r = -2; r <= 2; r++) {
                                    for (let q = -2; q <= 2; q++) {
                                        let ter = deindexer(Math.floor((this.x + (r * smellScaler)) / smellScaler), Math.floor((this.y + (q * smellScaler)) / smellScaler), Math.floor(canvas.width / smellScaler)) % pix1.data.length
                                        pairs.push([pix5.data[ter + (f - 12)], c, ter])
                                        c++
                                    }
                                }
                                pairs.sort((a, b) => a[0] > b[0] ? 1 : -1)
    
                                let goto = pairs[0][1]
                                if (pairs[0][0] < this.noseThresh) {
                                    goto = -1
                                } else {
                                    pairups.push(f)
                                }
                                if (goto == 1 || goto == 5 || goto == 0 || goto == 6) {
                                    canvas_context.color = "white"
    
                                    if (goto == 0 || goto == 6) {
                                        (arcers.push((Math.PI - (Math.PI / 8))))
                                    } else if (goto == 5) {
                                        arcers.push((Math.PI - (Math.PI / 12)))
                                    } else if (goto == 1) {
                                        arcers.push((Math.PI - (Math.PI / 6)))
                                    }
                                }
                                if (goto == 2 || goto == 7) {
                                    arcers.push((Math.PI - (Math.PI / 4)))
                                }
                                if (goto == 3 || goto == 4 || goto == 8 || goto == 9) {
    
                                    if (goto == 3) {
                                        arcers.push(((Math.PI / 6)))
                                    } else if (goto == 4) {
                                        arcers.push((Math.PI / 8))
                                    } else if (goto == 8) {
                                        arcers.push((Math.PI / 8))
                                    } else if (goto == 9) {
                                        arcers.push((Math.PI / 12))
                                    }
                                }
                                if (goto == 11 || goto == 10) {
                                    arcers.push((Math.PI))
                                }
                                if (goto == 12) {
                                    arcers.push(-1)
                                }
                                if (goto == 13 || goto == 14) {
                                    arcers.push(0)
                                }
                                if (goto == 15 || goto == 16 || goto == 20 || goto == 21) {
                                    if (goto == 15) {
                                        arcers.push(Math.PI + (Math.PI / 12))
                                    } else if (goto == 16 || goto == 20) {
                                        arcers.push(Math.PI + (Math.PI / 8))
                                    } else if (goto == 21) {
                                        arcers.push(Math.PI + (Math.PI / 6))
                                    }
                                }
                                if (goto == 17 || goto == 22) {
                                    arcers.push(Math.PI + (Math.PI / 4))
                                }
                                if (goto == 18 || goto == 19 || goto == 23 || goto == 24) {
                                    if (goto == 18 || goto == 24) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 3))
                                    } else if (goto == 19) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 3.5))
                                    } else if (goto == 23) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 2.5))
                                    }
                                }
                            } else if (f < 18) {
                                let pad = []
                                let c = 0
                                let pairs = []
                                let mxes = []
                                for (let r = -2; r <= 2; r++) {
                                    for (let q = -2; q <= 2; q++) {
                                        let ter = deindexer(Math.floor((this.x + (r * smellScaler)) / smellScaler), Math.floor((this.y + (q * smellScaler)) / smellScaler), Math.floor(canvas.width / smellScaler)) % pix1.data.length
                                        pairs.push([pix6.data[ter + (f - 15)], c, ter])
                                        c++
                                    }
                                }
                                pairs.sort((a, b) => a[0] > b[0] ? 1 : -1)
    
                                let goto = pairs[0][1]
                                if (pairs[0][0] < this.noseThresh) {
                                    goto = -1
                                } else {
                                    pairups.push(f)
                                }
                                if (goto == 1 || goto == 5 || goto == 0 || goto == 6) {
                                    canvas_context.color = "white"
    
                                    if (goto == 0 || goto == 6) {
                                        (arcers.push((Math.PI - (Math.PI / 8))))
                                    } else if (goto == 5) {
                                        arcers.push((Math.PI - (Math.PI / 12)))
                                    } else if (goto == 1) {
                                        arcers.push((Math.PI - (Math.PI / 6)))
                                    }
                                }
                                if (goto == 2 || goto == 7) {
                                    arcers.push((Math.PI - (Math.PI / 4)))
                                }
                                if (goto == 3 || goto == 4 || goto == 8 || goto == 9) {
    
                                    if (goto == 3) {
                                        arcers.push(((Math.PI / 6)))
                                    } else if (goto == 4) {
                                        arcers.push((Math.PI / 8))
                                    } else if (goto == 8) {
                                        arcers.push((Math.PI / 8))
                                    } else if (goto == 9) {
                                        arcers.push((Math.PI / 12))
                                    }
                                }
                                if (goto == 11 || goto == 10) {
                                    arcers.push((Math.PI))
                                }
                                if (goto == 12) {
                                    arcers.push(-1)
                                }
                                if (goto == 13 || goto == 14) {
                                    arcers.push(0)
                                }
                                if (goto == 15 || goto == 16 || goto == 20 || goto == 21) {
                                    if (goto == 15) {
                                        arcers.push(Math.PI + (Math.PI / 12))
                                    } else if (goto == 16 || goto == 20) {
                                        arcers.push(Math.PI + (Math.PI / 8))
                                    } else if (goto == 21) {
                                        arcers.push(Math.PI + (Math.PI / 6))
                                    }
                                }
                                if (goto == 17 || goto == 22) {
                                    arcers.push(Math.PI + (Math.PI / 4))
                                }
                                if (goto == 18 || goto == 19 || goto == 23 || goto == 24) {
                                    if (goto == 18 || goto == 24) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 3))
                                    } else if (goto == 19) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 3.5))
                                    } else if (goto == 23) {
                                        arcers.push(Math.PI + ((Math.PI / 8) * 2.5))
                                    }
                                }
                            }
                        }
    
    
                        if (this.noseAvoid.includes(f)) {
                            if (f < 3) {
                                let pad = []
                                let c = 0
                                let pairs = []
                                let mxes = []
                                for (let r = -2; r <= 2; r++) {
                                    for (let q = -2; q <= 2; q++) {
                                        let ter = deindexer(Math.floor((this.x + (r * smellScaler)) / smellScaler), Math.floor((this.y + (q * smellScaler)) / smellScaler), Math.floor(canvas.width / smellScaler)) % pix1.data.length
                                        pairs.push([pix1.data[ter + f], c, ter])
                                        c++
                                    }
                                }
                                pairs.sort((a, b) => a[0] > b[0] ? 1 : -1)
    
                                let goto = pairs[0][1]
                                if (pairs[0][0] < this.noseThresh) {
                                    goto = -1
                                } else {
                                    pairups.push(f)
                                }
                                if (goto == 1 || goto == 5 || goto == 0 || goto == 6) {
                                    // canvas_context.color = "white"
                                    // 
                                    if (goto == 0 || goto == 6) {
                                        zrcers.push(((Math.PI - (Math.PI / 8))))
                                    } else if (goto == 5) {
                                        zrcers.push((Math.PI - (Math.PI / 12)))
                                    } else if (goto == 1) {
                                        zrcers.push((Math.PI - (Math.PI / 6)))
                                    }
                                }
                                if (goto == 2 || goto == 7) {
                                    zrcers.push((Math.PI - (Math.PI / 4)))
                                }
                                if (goto == 3 || goto == 4 || goto == 8 || goto == 9) {
                                    if (goto == 3) {
                                        zrcers.push(((Math.PI / 6)))
                                    } else if (goto == 4) {
                                        zrcers.push((Math.PI / 8))
                                    } else if (goto == 8) {
                                        zrcers.push((Math.PI / 8))
                                    } else if (goto == 9) {
                                        zrcers.push((Math.PI / 12))
                                    }
                                }
                                if (goto == 11 || goto == 10) {
                                    zrcers.push((Math.PI))
                                }
                                if (goto == 12) {
                                    zrcers.push(-1)
                                }
                                if (goto == 13 || goto == 14) {
                                    zrcers.push(0)
                                }
                                if (goto == 15 || goto == 16 || goto == 20 || goto == 21) {
                                    if (goto == 15) {
                                        zrcers.push(Math.PI + (Math.PI / 12))
                                    } else if (goto == 16 || goto == 20) {
                                        zrcers.push(Math.PI + (Math.PI / 8))
                                    } else if (goto == 21) {
                                        zrcers.push(Math.PI + (Math.PI / 6))
                                    }
                                }
                                if (goto == 17 || goto == 22) {
                                    zrcers.push(Math.PI + (Math.PI / 4))
                                }
                                if (goto == 18 || goto == 19 || goto == 23 || goto == 24) {
                                    if (goto == 18 || goto == 24) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 3))
                                    } else if (goto == 19) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 3.5))
                                    } else if (goto == 23) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 2.5))
                                    }
                                }
                            } else if (f < 6) {
                                let pad = []
                                let c = 0
                                let pairs = []
                                let mxes = []
                                for (let r = -2; r <= 2; r++) {
                                    for (let q = -2; q <= 2; q++) {
                                        let ter = deindexer(Math.floor((this.x + (r * smellScaler)) / smellScaler), Math.floor((this.y + (q * smellScaler)) / smellScaler), Math.floor(canvas.width / smellScaler)) % pix1.data.length
                                        pairs.push([pix2.data[ter + (f - 3)], c, ter])
                                        c++
                                    }
                                }
                                pairs.sort((a, b) => a[0] > b[0] ? 1 : -1)
    
                                let goto = pairs[0][1]
                                if (pairs[0][0] < this.noseThresh) {
                                    goto = -1
                                } else {
                                    pairups.push(f)
                                }
                                if (goto == 1 || goto == 5 || goto == 0 || goto == 6) {
                                    canvas_context.color = "white"
    
                                    if (goto == 0 || goto == 6) {
                                        zrcers.push(((Math.PI - (Math.PI / 8))))
                                    } else if (goto == 5) {
                                        zrcers.push((Math.PI - (Math.PI / 12)))
                                    } else if (goto == 1) {
                                        zrcers.push((Math.PI - (Math.PI / 6)))
                                    }
                                }
                                if (goto == 2 || goto == 7) {
                                    zrcers.push((Math.PI - (Math.PI / 4)))
                                }
                                if (goto == 3 || goto == 4 || goto == 8 || goto == 9) {
                                    if (goto == 3) {
                                        zrcers.push(((Math.PI / 6)))
                                    } else if (goto == 4) {
                                        zrcers.push((Math.PI / 8))
                                    } else if (goto == 8) {
                                        zrcers.push((Math.PI / 8))
                                    } else if (goto == 9) {
                                        zrcers.push((Math.PI / 12))
                                    }
                                }
                                if (goto == 11 || goto == 10) {
                                    zrcers.push((Math.PI))
                                }
                                if (goto == 12) {
                                    zrcers.push(-1)
                                }
                                if (goto == 13 || goto == 14) {
                                    zrcers.push(0)
                                }
                                if (goto == 15 || goto == 16 || goto == 20 || goto == 21) {
                                    if (goto == 15) {
                                        zrcers.push(Math.PI + (Math.PI / 12))
                                    } else if (goto == 16 || goto == 20) {
                                        zrcers.push(Math.PI + (Math.PI / 8))
                                    } else if (goto == 21) {
                                        zrcers.push(Math.PI + (Math.PI / 6))
                                    }
                                }
                                if (goto == 17 || goto == 22) {
                                    zrcers.push(Math.PI + (Math.PI / 4))
                                }
                                if (goto == 18 || goto == 19 || goto == 23 || goto == 24) {
                                    if (goto == 18 || goto == 24) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 3))
                                    } else if (goto == 19) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 3.5))
                                    } else if (goto == 23) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 2.5))
                                    }
                                }
                            } else if (f < 9) {
                                let pad = []
                                let c = 0
                                let pairs = []
                                let mxes = []
                                for (let r = -2; r <= 2; r++) {
                                    for (let q = -2; q <= 2; q++) {
                                        let ter = deindexer(Math.floor((this.x + (r * smellScaler)) / smellScaler), Math.floor((this.y + (q * smellScaler)) / smellScaler), Math.floor(canvas.width / smellScaler)) % pix1.data.length
                                        pairs.push([pix3.data[ter + (f - 6)], c, ter])
                                        c++
                                    }
                                }
                                pairs.sort((a, b) => a[0] > b[0] ? 1 : -1)
                                let goto = pairs[0][1]
                                if (pairs[0][0] < this.noseThresh) {
                                    goto = -1
                                } else {
                                    pairups.push(f)
                                }
                                if (goto == 1 || goto == 5 || goto == 0 || goto == 6) {
                                    canvas_context.color = "white"
    
                                    if (goto == 0 || goto == 6) {
                                        zrcers.push(((Math.PI - (Math.PI / 8))))
                                    } else if (goto == 5) {
                                        zrcers.push((Math.PI - (Math.PI / 12)))
                                    } else if (goto == 1) {
                                        zrcers.push((Math.PI - (Math.PI / 6)))
                                    }
                                }
                                if (goto == 2 || goto == 7) {
                                    zrcers.push((Math.PI - (Math.PI / 4)))
                                }
                                if (goto == 3 || goto == 4 || goto == 8 || goto == 9) {
                                    if (goto == 3) {
                                        zrcers.push(((Math.PI / 6)))
                                    } else if (goto == 4) {
                                        zrcers.push((Math.PI / 8))
                                    } else if (goto == 8) {
                                        zrcers.push((Math.PI / 8))
                                    } else if (goto == 9) {
                                        zrcers.push((Math.PI / 12))
                                    }
                                }
                                if (goto == 11 || goto == 10) {
                                    zrcers.push((Math.PI))
                                }
                                if (goto == 12) {
                                    zrcers.push(-1)
                                }
                                if (goto == 13 || goto == 14) {
                                    zrcers.push(0)
                                }
                                if (goto == 15 || goto == 16 || goto == 20 || goto == 21) {
                                    if (goto == 15) {
                                        zrcers.push(Math.PI + (Math.PI / 12))
                                    } else if (goto == 16 || goto == 20) {
                                        zrcers.push(Math.PI + (Math.PI / 8))
                                    } else if (goto == 21) {
                                        zrcers.push(Math.PI + (Math.PI / 6))
                                    }
                                }
                                if (goto == 17 || goto == 22) {
                                    zrcers.push(Math.PI + (Math.PI / 4))
                                }
                                if (goto == 18 || goto == 19 || goto == 23 || goto == 24) {
                                    if (goto == 18 || goto == 24) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 3))
                                    } else if (goto == 19) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 3.5))
                                    } else if (goto == 23) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 2.5))
                                    }
                                }
                            } else if (f < 12) {
                                let pad = []
                                let c = 0
                                let pairs = []
                                let mxes = []
                                for (let r = -2; r <= 2; r++) {
                                    for (let q = -2; q <= 2; q++) {
                                        let ter = deindexer(Math.floor((this.x + (r * smellScaler)) / smellScaler), Math.floor((this.y + (q * smellScaler)) / smellScaler), Math.floor(canvas.width / smellScaler)) % pix1.data.length
                                        pairs.push([pix4.data[ter + (f - 9)], c, ter])
                                        c++
                                    }
                                }
                                pairs.sort((a, b) => a[0] > b[0] ? 1 : -1)
                                let goto = pairs[0][1]
                                if (pairs[0][0] < this.noseThresh) {
                                    goto = -1
                                } else {
                                    pairups.push(f)
                                }
                                if (goto == 1 || goto == 5 || goto == 0 || goto == 6) {
                                    canvas_context.color = "white"
    
                                    if (goto == 0 || goto == 6) {
                                        zrcers.push(((Math.PI - (Math.PI / 8))))
                                    } else if (goto == 5) {
                                        zrcers.push((Math.PI - (Math.PI / 12)))
                                    } else if (goto == 1) {
                                        zrcers.push((Math.PI - (Math.PI / 6)))
                                    }
                                }
                                if (goto == 2 || goto == 7) {
                                    zrcers.push((Math.PI - (Math.PI / 4)))
                                }
                                if (goto == 3 || goto == 4 || goto == 8 || goto == 9) {
                                    if (goto == 3) {
                                        zrcers.push(((Math.PI / 6)))
                                    } else if (goto == 4) {
                                        zrcers.push((Math.PI / 8))
                                    } else if (goto == 8) {
                                        zrcers.push((Math.PI / 8))
                                    } else if (goto == 9) {
                                        zrcers.push((Math.PI / 12))
                                    }
                                }
                                if (goto == 11 || goto == 10) {
                                    zrcers.push((Math.PI))
                                }
                                if (goto == 12) {
                                    zrcers.push(-1)
                                }
                                if (goto == 13 || goto == 14) {
                                    zrcers.push(0)
                                }
                                if (goto == 15 || goto == 16 || goto == 20 || goto == 21) {
                                    if (goto == 15) {
                                        zrcers.push(Math.PI + (Math.PI / 12))
                                    } else if (goto == 16 || goto == 20) {
                                        zrcers.push(Math.PI + (Math.PI / 8))
                                    } else if (goto == 21) {
                                        zrcers.push(Math.PI + (Math.PI / 6))
                                    }
                                }
                                if (goto == 17 || goto == 22) {
                                    zrcers.push(Math.PI + (Math.PI / 4))
                                }
                                if (goto == 18 || goto == 19 || goto == 23 || goto == 24) {
                                    if (goto == 18 || goto == 24) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 3))
                                    } else if (goto == 19) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 3.5))
                                    } else if (goto == 23) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 2.5))
                                    }
                                }
                            } else if (f < 15) {
                                let pad = []
                                let c = 0
                                let pairs = []
                                let mxes = []
                                for (let r = -2; r <= 2; r++) {
                                    for (let q = -2; q <= 2; q++) {
                                        let ter = deindexer(Math.floor((this.x + (r * smellScaler)) / smellScaler), Math.floor((this.y + (q * smellScaler)) / smellScaler), Math.floor(canvas.width / smellScaler)) % pix1.data.length
                                        pairs.push([pix5.data[ter + (f - 12)], c, ter])
                                        c++
                                    }
                                }
                                pairs.sort((a, b) => a[0] > b[0] ? 1 : -1)
                                let goto = pairs[0][1]
                                if (pairs[0][0] < this.noseThresh) {
                                    goto = -1
                                } else {
                                    pairups.push(f)
                                }
                                if (goto == 1 || goto == 5 || goto == 0 || goto == 6) {
                                    canvas_context.color = "white"
    
                                    if (goto == 0 || goto == 6) {
                                        zrcers.push(((Math.PI - (Math.PI / 8))))
                                    } else if (goto == 5) {
                                        zrcers.push((Math.PI - (Math.PI / 12)))
                                    } else if (goto == 1) {
                                        zrcers.push((Math.PI - (Math.PI / 6)))
                                    }
                                }
                                if (goto == 2 || goto == 7) {
                                    zrcers.push((Math.PI - (Math.PI / 4)))
                                }
                                if (goto == 3 || goto == 4 || goto == 8 || goto == 9) {
                                    if (goto == 3) {
                                        zrcers.push(((Math.PI / 6)))
                                    } else if (goto == 4) {
                                        zrcers.push((Math.PI / 8))
                                    } else if (goto == 8) {
                                        zrcers.push((Math.PI / 8))
                                    } else if (goto == 9) {
                                        zrcers.push((Math.PI / 12))
                                    }
                                }
                                if (goto == 11 || goto == 10) {
                                    zrcers.push((Math.PI))
                                }
                                if (goto == 12) {
                                    zrcers.push(-1)
                                }
                                if (goto == 13 || goto == 14) {
                                    zrcers.push(0)
                                }
                                if (goto == 15 || goto == 16 || goto == 20 || goto == 21) {
                                    if (goto == 15) {
                                        zrcers.push(Math.PI + (Math.PI / 12))
                                    } else if (goto == 16 || goto == 20) {
                                        zrcers.push(Math.PI + (Math.PI / 8))
                                    } else if (goto == 21) {
                                        zrcers.push(Math.PI + (Math.PI / 6))
                                    }
                                }
                                if (goto == 17 || goto == 22) {
                                    zrcers.push(Math.PI + (Math.PI / 4))
                                }
                                if (goto == 18 || goto == 19 || goto == 23 || goto == 24) {
                                    if (goto == 18 || goto == 24) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 3))
                                    } else if (goto == 19) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 3.5))
                                    } else if (goto == 23) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 2.5))
                                    }
                                }
                            } else if (f < 18) {
                                let pad = []
                                let c = 0
                                let pairs = []
                                let mxes = []
                                for (let r = -2; r <= 2; r++) {
                                    for (let q = -2; q <= 2; q++) {
                                        let ter = deindexer(Math.floor((this.x + (r * smellScaler)) / smellScaler), Math.floor((this.y + (q * smellScaler)) / smellScaler), Math.floor(canvas.width / smellScaler)) % pix1.data.length
                                        pairs.push([pix6.data[ter + (f - 15)], c, ter])
                                        c++
                                    }
                                }
                                pairs.sort((a, b) => a[0] > b[0] ? 1 : -1)
                                let goto = pairs[0][1]
                                if (pairs[0][0] < this.noseThresh) {
                                    goto = -1
                                } else {
                                    pairups.push(f)
                                }
                                if (goto == 1 || goto == 5 || goto == 0 || goto == 6) {
                                    canvas_context.color = "white"
    
                                    if (goto == 0 || goto == 6) {
                                        zrcers.push(((Math.PI - (Math.PI / 8))))
                                    } else if (goto == 5) {
                                        zrcers.push((Math.PI - (Math.PI / 12)))
                                    } else if (goto == 1) {
                                        zrcers.push((Math.PI - (Math.PI / 6)))
                                    }
                                }
                                if (goto == 2 || goto == 7) {
                                    zrcers.push((Math.PI - (Math.PI / 4)))
                                }
                                if (goto == 3 || goto == 4 || goto == 8 || goto == 9) {
                                    if (goto == 3) {
                                        zrcers.push(((Math.PI / 6)))
                                    } else if (goto == 4) {
                                        zrcers.push((Math.PI / 8))
                                    } else if (goto == 8) {
                                        zrcers.push((Math.PI / 8))
                                    } else if (goto == 9) {
                                        zrcers.push((Math.PI / 12))
                                    }
                                }
                                if (goto == 11 || goto == 10) {
                                    zrcers.push((Math.PI))
                                }
                                if (goto == 12) {
                                    zrcers.push(-1)
                                }
                                if (goto == 13 || goto == 14) {
                                    zrcers.push(0)
                                }
                                if (goto == 15 || goto == 16 || goto == 20 || goto == 21) {
                                    if (goto == 15) {
                                        zrcers.push(Math.PI + (Math.PI / 12))
                                    } else if (goto == 16 || goto == 20) {
                                        zrcers.push(Math.PI + (Math.PI / 8))
                                    } else if (goto == 21) {
                                        zrcers.push(Math.PI + (Math.PI / 6))
                                    }
                                }
                                if (goto == 17 || goto == 22) {
                                    zrcers.push(Math.PI + (Math.PI / 4))
                                }
                                if (goto == 18 || goto == 19 || goto == 23 || goto == 24) {
                                    if (goto == 18 || goto == 24) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 3))
                                    } else if (goto == 19) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 3.5))
                                    } else if (goto == 23) {
                                        zrcers.push(Math.PI + ((Math.PI / 8) * 2.5))
                                    }
                                }
                            }
    
                        }
                    }
    
                    // ////////////////console.log(arcers.length, arcers, pairups, this)
    
    
                    if (arcers.length > 0) {
                        let pairs = []
                        let poins = []
                        for (let w = 0; w < arcers.length; w++) {
    
                            if (arcers[w] != -1) {
    
                                pairs.push(arcers[w])
                                poins.push(this.noseStrengths[pairups[w]])
                            }
    
                        }
    
                        if (pairs.length > 0) {
    
                            let argle = weightedAverageAngle(pairs, poins)
    
    
                            // let kart = new Point(this.x + (Math.cos(argle)*10), this.y + (Math.sin(argle)*10))
    
                            // this.link.target = kart
    
                            // this.link.width = 3
                            // this.link.color = "red"
                            // this.link.draw()
    
                            // ////////////////console.log(arcers) 
    
    
    
                            // ////////////////console.log(argle, this)
    
                            if (this.noserotor == 1) {
    
                                for (let w = 0; w < arcers.length; w++) {
    
                                    if (arcers[w] != -1) {
                                        this.lt.x = this.x + (Math.cos(((arcers[w]))) * lf)
                                        this.lt.y = this.y + (Math.sin(arcers[w]) * lf)
    
    
                                        // ////////////////console.log("1")
    
                                        if (this.energy >= noseCost / arcers.length) {
                                            if(noseCost < 0){
                                                this.energy -= noseCost / arcers.length * 1 * ((seedRandom()*2)*(freec / freen)) 
                                            }else{
                                                this.energy -= noseCost / arcers.length * 1
                                            }
                                            if (this.link.target.anchor != 1) {
                                                this.link.target.x = (this.link.target.x * (1 - (this.noseStrengths[pairups[w]] / 1))) + ((this.noseStrengths[pairups[w]] / 1) * this.lt.x)
                                                this.link.target.y = (this.link.target.y * (1 - (this.noseStrengths[pairups[w]] / 1))) + ((this.noseStrengths[pairups[w]] / 1) * this.lt.y)
                                            } else {
    
                                                this.link.target.x = (this.link.target.x * (1 - (this.noseStrengths[pairups[w]] / 100))) + ((this.noseStrengths[pairups[w]] / 100) * this.lt.x)
                                                this.link.target.y = (this.link.target.y * (1 - (this.noseStrengths[pairups[w]] / 100))) + ((this.noseStrengths[pairups[w]] / 100) * this.lt.y)
    
                                            }
                                            // if (this.type == 1 || this.type == 3) { 
                                            // nd.pushout = nd.pushoutsto + this.times[z]
    
                                            // nd.pushout = weightedAverageAngle([nd.pushout, argle],[1,1])
                                            // nd.pushoutsto = weightedAverageAngle([nd.pushout, argle],[1,1])
                                            // this.pushout = weightedAverageAngle([this.pushout, argle],[1,1])
                                            // this.pushoutsto = weightedAverageAngle([this.pushout, argle],[1,1])
    
                                            nd.pushout = weightedAverageAngle([nd.pushout, argle], [1, this.noseStrengths[pairups[w]]])
                                            nd.pushoutsto = weightedAverageAngle([nd.pushout, argle], [1, this.noseStrengths[pairups[w]]])
                                            this.pushout = weightedAverageAngle([this.pushout, argle], [1, this.noseStrengths[pairups[w]]])
                                            this.pushoutsto = weightedAverageAngle([this.pushout, argle], [1, this.noseStrengths[pairups[w]]])
                                            // this.pushout = this.pushoutsto - this.times[z]
                                            // }
                                        } else {
    
                                        }
    
    
                                    }
    
                                }
                            }
                            if (this.nosemotor == 1) {
    
                                for (let w = 0; w < arcers.length; w++) {
    
                                    if (arcers[w] != -1) {
                                        // this.lt.x = this.x + (Math.cos(((arcers[w]))) * lf)
                                        // this.lt.y =  this.y + (Math.sin(arcers[w]) * lf)
    
    
                                        // ////////////////console.log("1")
    
                                        if (this.energy >= noseCost / arcers.length) {
                                            if(noseCost < 0){
                                                this.energy -= noseCost / arcers.length * 1 * ((seedRandom()*2)*(freec / freen)) 
                                            }else{
                                                this.energy -= noseCost / arcers.length * 1
                                            }
                                            // if(this.link.target.anchor != 1){
                                            //     this.link.target.x = (this.link.target.x * (1 - (this.noseStrengths[pairups[w]]/1))) + ((this.noseStrengths[pairups[w]]/1) * this.lt.x)
                                            //     this.link.target.y = (this.link.target.y * (1 - (this.noseStrengths[pairups[w]]/1))) + ((this.noseStrengths[pairups[w]]/1) * this.lt.y)
                                            // }else{
    
                                            // this.link.target.x = (this.link.target.x * (1 - (this.noseStrengths[pairups[w]]/100))) + ((this.noseStrengths[pairups[w]]/100) * this.lt.x)
                                            // this.link.target.y = (this.link.target.y * (1 - (this.noseStrengths[pairups[w]]/100))) + ((this.noseStrengths[pairups[w]]/100) * this.lt.y)
    
                                            // }
                                            // if (this.type == 1 || this.type == 3) { 
                                            // nd.pushout += (arcers[w]/80) 
    
                                            // ////////////////console.log(argle)
                                            this.pushout = weightedAverageAngle([this.pushout, argle], [1, .2])
                                            this.pushoutsto = weightedAverageAngle([this.pushout, argle], [1, .2])
                                            // this.pushout = this.pushoutsto - this.times[z]
                                            // }
                                        } else {
    
                                        }
    
    
                                    }
    
                                }
                            }
                        }
                    }
    
    
    
    
                    if (zrcers.length > 0) {
                        let pairs = []
                        let poins = []
                        for (let w = 0; w < zrcers.length; w++) {
    
                            if (zrcers[w] != -1) {
    
                                pairs.push(zrcers[w] + (Math.PI / 2))
                                poins.push(this.noseStrengths[pairups[w]])
                            }
    
                        }
                        if (pairs.length > 0) {
    
                            let argle = weightedAverageAngle(pairs, poins)
    
                            // ////////////////console.log(argle, pairs, poins)
    
                            // let kart = new Point(this.x + (Math.cos(argle)*10), this.y + (Math.sin(argle)*10))
    
                            // this.link.target = kart
    
                            // this.link.width = 3
                            // this.link.color = "red"
                            // this.link.draw()
    
                            // ////////////////console.log(zrcers) 
    
    
    
                            // ////////////////console.log(argle, this)
    
                            if (this.noserotor == 1) {
    
                                for (let w = 0; w < zrcers.length; w++) {
    
                                    if (zrcers[w] != -1) {
                                        this.lt.x = this.x + (Math.cos(((zrcers[w]))) * lf)
                                        this.lt.y = this.y + (Math.sin(zrcers[w]) * lf)
    
    
                                        // ////////////////console.log("1")
    
                                        if (this.energy >= noseCost / zrcers.length) {
                                            
                    if(noseCost < 0){
                        this.energy -= noseCost / zrcers.length * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= noseCost / zrcers.length * 1
                    }
    
                    
                                            if (this.link.target.anchor != 1) {
                                                this.link.target.x = (this.link.target.x * (1 - (this.noseStrengths[pairups[w]] / 1))) + ((this.noseStrengths[pairups[w]] / 1) * this.lt.x)
                                                this.link.target.y = (this.link.target.y * (1 - (this.noseStrengths[pairups[w]] / 1))) + ((this.noseStrengths[pairups[w]] / 1) * this.lt.y)
                                            } else {
    
                                                this.link.target.x = (this.link.target.x * (1 - (this.noseStrengths[pairups[w]] / 100))) + ((this.noseStrengths[pairups[w]] / 100) * this.lt.x)
                                                this.link.target.y = (this.link.target.y * (1 - (this.noseStrengths[pairups[w]] / 100))) + ((this.noseStrengths[pairups[w]] / 100) * this.lt.y)
    
                                            }
                                            // if (this.type == 1 || this.type == 3) { 
                                            // nd.pushout = nd.pushoutsto + this.times[z]
    
                                            nd.pushout = weightedAverageAngle([nd.pushout, argle], [1, this.noseStrengths[pairups[w]]])
                                            nd.pushoutsto = weightedAverageAngle([nd.pushout, argle], [1, this.noseStrengths[pairups[w]]])
                                            this.pushout = weightedAverageAngle([this.pushout, argle], [1, this.noseStrengths[pairups[w]]])
                                            this.pushoutsto = weightedAverageAngle([this.pushout, argle], [1, this.noseStrengths[pairups[w]]])
                                            // this.pushout = this.pushoutsto - this.times[z]
                                            // }
                                        } else {
    
                                        }
    
    
                                    }
    
                                }
                            }
                            if (this.nosemotor == 1) {
    
                                for (let w = 0; w < zrcers.length; w++) {
    
                                    if (zrcers[w] != -1) {
                                        // this.lt.x = this.x + (Math.cos(((zrcers[w]))) * lf)
                                        // this.lt.y =  this.y + (Math.sin(zrcers[w]) * lf)
    
    
                                        // ////////////////console.log("1")
    
                                        if (this.energy >= noseCost / zrcers.length) {
    
                    if(noseCost < 0){
                        this.energy -= noseCost / zrcers.length * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= noseCost / zrcers.length * 1
                    }
    
    
                                            // if(this.link.target.anchor != 1){
                                            //     this.link.target.x = (this.link.target.x * (1 - (this.noseStrengths[pairups[w]]/1))) + ((this.noseStrengths[pairups[w]]/1) * this.lt.x)
                                            //     this.link.target.y = (this.link.target.y * (1 - (this.noseStrengths[pairups[w]]/1))) + ((this.noseStrengths[pairups[w]]/1) * this.lt.y)
                                            // }else{
    
                                            // this.link.target.x = (this.link.target.x * (1 - (this.noseStrengths[pairups[w]]/100))) + ((this.noseStrengths[pairups[w]]/100) * this.lt.x)
                                            // this.link.target.y = (this.link.target.y * (1 - (this.noseStrengths[pairups[w]]/100))) + ((this.noseStrengths[pairups[w]]/100) * this.lt.y)
    
                                            // }
                                            // if (this.type == 1 || this.type == 3) { 
                                            // nd.pushout += (zrcers[w]/80) 
    
                                            // ////////////////console.log(argle)
                                            this.pushout = weightedAverageAngle([this.pushout, argle], [1, .2])
                                            this.pushoutsto = weightedAverageAngle([this.pushout, argle], [1, .2])
                                            // this.pushout = this.pushoutsto - this.times[z]
                                            // }
                                        } else {
    
                                        }
    
    
                                    }
    
                                }
                            }
                        }
                    }
    
                    this.nodeEnergyCost += noseCost
                }
                // globalnodes[t].link.list.push(globalnodes.indexOf(this))
                // }
            }
    
    
    
        }
        makePiston() {
            if (this.dead == 1) {
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
            let z = 0
    
            if (this.piston != 1) {
    
                for (let t = 0; t < timesLength; t++) {
                    this.pistonpushes[t] = 0
                }
                return
            }
    
    
            for (let t = 0; t < this.neighbors.length; t++) {
                // //////////////////////////////console.log()
                if (this.dead == 1) {
                    break
                }
                let nd = globalnodes[this.neighbors[t]]
                if (!nd) {
                    continue
                }
                if (nd.dead == 1) {
                    continue
                }
    
                this.link.target = nd
    
    
                if (this.piston == 1) {
                    if (this.energy >= pistoncost) {
                        if(pistoncost < 0){
                            this.energy -= pistoncost * 1 * ((seedRandom()*2)*(freec / freen)) 
                        }else{
                            this.energy -= pistoncost * 1
                        }
                        this.pistonpushes[z] += (Math.sin(this.pistontimes[z] + this.pistonstarts[z]) / 1)
                        this.pistonpushes[z] = Math.min(this.pistonpushes[z], ((loutmin * worldscaler) * 3))
                        this.pistonpushes[z] = Math.max(this.pistonpushes[z], -((loutmin * worldscaler) / 2))
                    }
                    this.nodeEnergyCost += pistoncost
                }
    
    
    
    
                z++
                z %= this.las.length
    
    
                this.link.mark = 1
                this.link.list.push(this.neighbors[t])
                nd.link.mark = 1
                nd.link.list.push(globalnodes.indexOf(this))
    
    
                this.xleap = (Math.abs(this.xleap) > Math.abs(nd.xleap) ? this.xleap : nd.xleap)
                this.yleap = (Math.abs(this.yleap) > Math.abs(nd.yleap) ? this.xleap : nd.yleap)
            }
    
    
    
        }
        makeLink() {
            if (this.dead == 1) {
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
            let z = 0
            this.link.list = []
            if (this.linkup.length == 2) {
                //////////////////console.log(this)
            }
    
    
            // if(this.piston == 1){
            //     if(this.energy >= pistoncost){
            //         this.energy-=pistoncost
    
            //         this.pistontime+=this.pistonstep
    
            //         this.pistonpush += (Math.sin(this.pistontime)/1)
            //         this.pistonpush = Math.min(this.pistonpush, 12)
            //         this.pistonpush = Math.max(this.pistonpush, -12)
     
            //     }
            // }
    
    
            for (let t = 0; t < this.neighbors.length; t++) {
                if(globlinker[`${this.id},${this.neighbors[t]}`] == 1){
                    continue
                }
                globlinker[`${this.id},${this.neighbors[t]}`] = 1
    
                let nd = globalnodes[this.neighbors[t]]
                if (!nd) {
                    ////////////////////////////console.log(globalnodes, this.neighbors[t])
                    continue
                }
                if (nd.dead == 1) {
                    continue
                }
    
    
                // if (this.stupidneighbors[t] == 1) {
    
                this.link.target = nd
                let j = 0
                let lf = (((this.lout + this.pistonpushes[z]) + (nd.lout + nd.pistonpushes[z])) / 2)
                let mes = this.link.hypotenuse()
                let a = this.link.angle()
                this.a = a
                if(this.motor == 1 || this.mouth == 1){
                  this.a += Math.PI
                }
                let cosa = Math.cos(a)
                let sina = Math.sin(a)
                // while (mes > lf) {
                //     j++
                //     if(j>20){
                //         break
                //     }
                //     let outs = 0
                //     if(this.anchor != 1){
                //         this.x -=cosa * 1.2
                //         this.y -=sina * 1.2
                //         outs+=1.2
                //     }else{
                //         if(this.link.target.anchor != 1){
                //     this.x -=cosa * .012
                //     this.y -=sina * .012
                //     outs+=.012
                //         }else{
                //             this.x -=cosa * .06
                //             this.y -=sina * .06
                //             outs+=.06
                //         }
                //     }
                //     if(this.link.target.anchor != 1){
                //     this.link.target.x +=cosa * 1.2
                //     this.link.target.y +=sina * 1.2
                //     outs+=1.2
                //     }else{
    
                //         if(this.anchor != 1){
                //     this.link.target.x +=cosa * .012
                //     this.link.target.y +=sina * .012
                //     outs+=.012
                //         }else{
                //             this.link.target.x +=cosa * .06
                //             this.link.target.y +=sina * .06
                //             outs+=.06
    
                //         }
    
                //     }
                //     mes-=outs
                // }
                j = 0
                while (mes > lf) {
                    j++
                    if (j > 16) {
                        break
                    }
    
                    let outs = 0
                    if (this.anchor != 1) {
                        this.x -= cosa * .8 * worldscaler
                        this.y -= sina * .8 * worldscaler
                        outs += .8 * worldscaler
                    } else {
    
                        if (this.link.target.anchor != 1) {
                            this.x -= cosa * .008 * worldscaler
                            this.y -= sina * .008 * worldscaler
                            outs += .008* worldscaler
                        } else {
    
                            this.x -= cosa * .04 * worldscaler
                            this.y -= sina * .04 * worldscaler
                            outs += .04 * worldscaler
    
                        }
                    }
                    if (this.link.target.anchor != 1) {
                        this.link.target.x += cosa * .8 * worldscaler
                        this.link.target.y += sina * .8 * worldscaler
                        outs += .8* worldscaler
                    } else {
                        if (this.anchor != 1) {
                            this.link.target.x += cosa * .008 * worldscaler
                            this.link.target.y += sina * .008 * worldscaler
                            outs += .008 * worldscaler
                        } else {
    
                            this.link.target.x += cosa * .04 * worldscaler
                            this.link.target.y += sina * .04 * worldscaler
                            outs += .04 * worldscaler
    
                        }
    
                    }
                    mes -= outs * .999
                }
    
    
    
    
                j = 0
                while (mes < lf) {
                    j++
                    if (j > 16) {
                        break
                    }
    
                    let outs = 0
                    if (this.anchor != 1) {
                        this.x += cosa * .8 * worldscaler
                        this.y += sina * .8 * worldscaler
                        outs -= .8 * worldscaler
                    } else {
    
                        if (this.link.target.anchor != 1) {
                            this.x += cosa * .008 * worldscaler
                            this.y += sina * .008 * worldscaler
                            outs -= .008 * worldscaler
                        } else {
    
                            this.x += cosa * .04 * worldscaler
                            this.y += sina * .04 * worldscaler
                            outs -= .04 * worldscaler
    
                        }
                    }
                    if (this.link.target.anchor != 1) {
                        this.link.target.x -= cosa * .8 * worldscaler
                        this.link.target.y -= sina * .8 * worldscaler
                        outs -= .8 * worldscaler
                    } else {
                        if (this.anchor != 1) {
                            this.link.target.x -= cosa * .008 * worldscaler
                            this.link.target.y -= sina * .008 * worldscaler
                            outs -= .008 * worldscaler
                        } else {
    
                            this.link.target.x -= cosa * .04 * worldscaler
                            this.link.target.y -= sina * .04 * worldscaler
                            outs -= .04 * worldscaler
    
                        }
    
                    }
                    mes -= outs * .998
                }
    
    
    
                // this.lt.x = this.x + (Math.cos(((this.times[z]))) * this.lout)
                // this.lt.y =  this.y + (Math.sin(this.times[z]) * this.lout)
    
    
                // // let easedp = new Point((this.link.target.x*(1-this.rigs[z])) + (lt.x*this.rigs[z]),    (this.link.target.y*(1-this.rigs[z])) + (lt.y*this.rigs[z]))
    
                // //
    
    
    
                // if (this.rotor == 1) {
                //         if (this.energy >= rotationCost) {
                //             this.energy-=rotationCost
                //             if(this.link.target.anchor != 1){
                //                 this.link.target.x = (this.link.target.x * (1 - this.rigs[z])) + (this.rigs[z] * this.lt.x)
                //                 this.link.target.y = (this.link.target.y * (1 - this.rigs[z])) + (this.rigs[z] * this.lt.y)
                //             }else{
    
                //             this.link.target.x = (this.link.target.x * (1 - (this.rigs[z]/10))) + ((this.rigs[z]/10) * this.lt.x)
                //             this.link.target.y = (this.link.target.y * (1 - (this.rigs[z]/10))) + ((this.rigs[z]/10) * this.lt.y)
    
                //             }
                //             // if (this.type == 1 || this.type == 3) { 
                //                     nd.pushout = nd.pushoutsto + this.times[z]
                //                     // this.pushout = this.pushoutsto - this.times[z]
                //             // }
                //         } else {
    
                //         }
    
                // }
    
    
                z++
                z %= this.las.length
    
    
                if (this.energy >= linkcost) {
                    if(linkcost < 0){
                        this.energy -= linkcost * .5 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= linkcost * .5
                    }
                }
                if (this.energy >= linkcostdistance * this.lout) {
                    if(linkcostdistance < 0){
                        this.energy -= linkcostdistance * .5 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= linkcostdistance * .5
                    }
                }
    
                this.nodeEnergyCost += linkcost / 2
                this.nodeEnergyCost += linkcostdistance * this.lout /2
                this.energy = Math.max(this.energy, 0)
    
    
                this.link.mark = 1
                this.link.list.push(this.neighbors[t])
                nd.link.mark = 1
                nd.link.list.push(globalnodes.indexOf(this))
    
    
                this.xleap = (Math.abs(this.xleap) > Math.abs(nd.xleap) ? this.xleap : nd.xleap)
                this.yleap = (Math.abs(this.yleap) > Math.abs(nd.yleap) ? this.xleap : nd.yleap)
                nd.xleap = (Math.abs(this.xleap) > Math.abs(nd.xleap) ? nd.xleap : this.xleap)
                nd.yleap = (Math.abs(this.yleap) > Math.abs(nd.yleap) ? nd.xleap : this.yleap)
    
                // globalnodes[t].link.list.push(globalnodes.indexOf(this))
                // }
            }
    
    
    
        }
        dying(alldead) {
            let add = false 
    
            if (deadwash < 3 || deadwash > deadmax - 3) {
                return add 
            }
            if (this.trueage > 2) {
                if (this.neighbors.length <= 1) {
                    this.head = 1
                }
            }
    
            if (this.die == 1) {
                //////////////////////console.log(this.neighbors, this)
                if (this.trueage > 5) {
                    this.head = 1
                    this.dead = 1
                    add = true
                }
            }
    
            if (this.cut == 1) {
                this.die = 1
            }
    
    
            if (this.mouth == 1) {
                if (this.link.list.length == 0 && this.immune.length <= 2 && this.trueage > 5) {
                    this.dead = 1
                    add = true
                }
    
    
                if (this.balanced == 1) {
    
                    if ((this.age > Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)) || (this.immune.length <= 2)) {
                        //////////////////////////////console.log(((this.ll)*(this.ll))*Math.max(((maxage - minage) - (globalnodes.length - alldead)),timemin), this.ll)
                        if (this.immune.length <= 2 || this.age > (((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)) { ///this.ll / 1.25) * (this.ll / 1.25  = this.ll / 1.25) * (this.ll / 1.25
                            this.dead = 1
                            add = true
                            if (totalKill == 1) {
                                if (totalKill == 1) {
                                    for (let d = 0; d < this.immune.length; d++) {
                                        globalnodes[this.immune[d]].dead = 1
                                        add = true
                                    }
                                }
                            }
                        }
                    }
    
                }
    
    
            } else {
    
    
                if (this.link.list.length == 0 && this.immune.length <= 2 && this.trueage > 5) {
                    this.dead = 1
                    add = true
                }
    
                if (this.balanced == 1) {
    
                    if ((this.age > Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)) || (this.immune.length <= 2)) {
                        //////////////////////////////console.log(((this.ll)*(this.ll))*Math.max(((maxage - minage) - (globalnodes.length - alldead)),timemin), this.ll)
                        if (this.immune.length <= 2 || this.age > (((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)) {
                            this.dead = 1
                            add = true
                            if (totalKill == 1) {
                                if (totalKill == 1) {
                                    for (let d = 0; d < this.immune.length; d++) {
                                        globalnodes[this.immune[d]].dead = 1
                                        add = true
                                    }
                                }
                            }
                        }
                    }
    
                }
            }
    
            return add
        }
        text(alldead) {
    
            //text()
            if (this.dead == 1) {
                return
            }
    
            if (!(keysPressed['h'] || pu.seeenergy == 1) && !(keysPressed['e'] || pu.seeage == 1)&& !keysPressed['r'] && !keysPressed['c'] && !keysPressed['b'] && !keysPressed['l']   && !keysPressed['`']) {
    
                return
            }else if(keysPressed['`']){

                let x = this.x + 15
                let y = this.y + 10


                if(this.ear == 1){
                    for(let k = 0;k<primes.length;k++){
                        canvas_context.fillStyle = `rgb(${rgbColors[k].r},${rgbColors[k].g*1},${rgbColors[k].b})`
                        canvas_context.fillRect(x+(k*4), y+(0)-6, 4,6)
                        for(let z = 0;z<primes.length;z++){

                        canvas_context.fillStyle = `rgb(${rgbColors[z].r},${rgbColors[z].g*1},${rgbColors[z].b})`
                        canvas_context.fillRect((x+(0))-6, y+(z*4), 6,4)
                        }
                    }


                    for(let k = 0;k<primes.length;k++){
                        for(let z = 0;z<primes.length;z++){
                            let sumbo = primes[k]*primes[z]
                            canvas_context.fillStyle = `rgb(${32},${32*1},32)`
                            if(k == 5 || z == 5){
                            canvas_context.fillStyle = `rgb(${32},${32*1},32)`
                            }
                            if(k == 21 || z == 21){
                            canvas_context.fillStyle = `rgb(${32},${32*1},32)`
                            }
                            // console.log(this.soundPref, primes[k], primes[z], k,z, sumbo, this.soundPref[sumbo])
                            canvas_context.fillRect(x+(k*4), y+(z*4), 5,5)
                            if(this.soundPref[sumbo] == 1 && this.soundAvoid[sumbo] == 1){
                                canvas_context.fillStyle = `rgb(${255*1},${255*1},0)`
                                canvas_context.fillRect(x+(k*4), y+(z*4),5,5) 
                            }else   if(this.soundPref[sumbo] == 1){
                                canvas_context.fillStyle = `rgb(${255*1},0,0)`
                                canvas_context.fillRect(x+(k*4), y+(z*4), 5,5)
                            }else   if(this.soundAvoid[sumbo] == 1){
                                canvas_context.fillStyle = `rgb(${0},${255*1},0)`
                                canvas_context.fillRect(x+(k*4), y+(z*4), 5,5)
                            }
                     
    
                        }
                    }
                }



            } else if (keysPressed['l']) {
    
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = `${worldscale*1.4}px arial`
    
                // this.energy = Math.round(this.energy*100)/100
    
                if (this.head == 1) {
                    canvas_context.strokeText(Math.round(this.energyOrgCost * 10000), this.xavg - 5, this.yavg + 2)
                    canvas_context.fillText(Math.round(this.energyOrgCost * 10000), this.xavg - 5, this.yavg + 2)
                }
    
    
            } else if (keysPressed['b']) {
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = `${worldscale*1.5}px arial`
    
                // this.energy = Math.round(this.energy*100)/100
    
                let c = 0
                for (let t = 0; t < this.genebucket.length; t++) {
                    c += (this.genebucket[t].split('')).length
                }
    
    
                if (this.head == 1) {
                    canvas_context.strokeText(c, this.xavg - 5, this.yavg + 2)
                    canvas_context.fillText(c, this.xavg - 5, this.yavg + 2)
                }
    
            } else if (keysPressed['c'] && keysPressed['h']) {
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = `${worldscale*1.4}px arial`
    
                // this.energy = Math.round(this.energy*100)/100
    
    
                if (this.head == 1) {
                    canvas_context.strokeText(this.genestring, this.xavg, this.yavg)
                    canvas_context.fillText(this.genestring, this.xavg, this.yavg)
                }
    
            } else if (keysPressed['c']) {
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = `${worldscale*1.4}px arial`
    
                // this.energy = Math.round(this.energy*100)/100
    
    
                canvas_context.strokeText(this.genestring, this.x, this.y)
                canvas_context.fillText(this.genestring, this.x, this.y)
    
            } else if (keysPressed['h'] || pu.seeenergy == 1) {
    
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = `${worldscale*1.4}px arial`
    
                // this.energy = Math.round(this.energy*100)/100
    
                if (this.head == 1) {
    
                    ////////////console.log(this.energy, repconstant, this.w, this.xavg, this.yavg)
                    canvas_context.strokeText(Math.round((this.energy / ((repconstant * ((((this.w))))))) * 100) + "%", this.xavg, this.yavg)
                    canvas_context.fillText(Math.round((this.energy / ((repconstant * ((((this.w))))))) * 100) + "%", this.xavg, this.yavg)
                }
            } else if (keysPressed['e'] || pu.seeage == 1) {
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = `${worldscale*1.4}px arial`
    
                // let alldead = 0
                // for (let t = 0; t < globalnodes.length; t++) {
                //     if (globalnodes[t].dead == 1) {
                //         alldead++
                //     }
                // }
                if (this.head == 1) {
                    let age = Math.round(this.age * 100) / 100
                    canvas_context.strokeText(Math.round(100 * (age / ((((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)))) + "%", this.xavg, this.yavg)
                    canvas_context.fillText(Math.round(100 * (age / ((((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)))) + "%", this.xavg, this.yavg)
                    // ////////console.log(age, ((((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)))
                    }
            } else if (keysPressed['r']) {
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = "11px arial"
    
                // this.age = Math.round(this.age*100)/100
    
                if (this.head == 1) {
                    canvas_context.strokeText(this.ll, this.xavg, this.yavg)
                    canvas_context.fillText(this.ll, this.xavg, this.yavg)
                }
            }
        }
        textbet() {
    
            if (this.dead == 1) {
                return
            }
    
    
    
            canvas_context.fillStyle = "white"
            canvas_context.lineWidth = 1
            canvas_context.strokeStyle = "black"
            canvas_context.font = "15px arial"
    
            // this.energy = Math.round(this.energy*100)/100
    
            if (this.bet >= 1) {
                canvas_context.strokeText(Math.round(this.bet * ((this.ll - 1) / 2)), this.xavg - 5, this.yavg + 2)
                canvas_context.fillText(Math.round(this.bet * ((this.ll - 1) / 2)), this.xavg - 5, this.yavg + 2)
            }
    
    
    
    
        }
    }
    
    class Snode {
        constructor(x, y, t, genes, nope = 0) {
            this.contextMarker = markCon
            // markCon++
    
    
            this.heard = {}
            this.stinkRate = 255
            this.nosePref = []
            this.noseAvoid = []
    
            this.noseStrength = 100
            //    let canvasz = document.createElement('canvas');
            //    let context = canvasz.getContext("2d", { willReadFrequently: true })
    
    
            //    contextList.push(context)
            //    canvasList.push(canvasz)
            //    mappingArt.push(new Mapper())
            //    document.body.appendChild(canvasz)
    
    
            this.energyOrgCost = 0
            this.nodeEnergyCost = 0
            this.linkApha = 1
    
            this.relative = -1
            this.xavg = 0
            this.yavg = 0
            this.charge = 0
            this.magratio = 1
            // if(seedRandom() < .66){
            //     this.charge = Math.sign(seedRandom()-.5)
            // }
            this.genestring = genes
            this.genebucket = ['P']
            this.magbucket = [1]
            this.chargebucket = [0]
            this.trueage = 0
            this.pistonpush = 0
            this.pistonpushes = []
            this.pistontime = 0
            this.pistonstep = (seedRandom() + .5) / 10
            this.shead = 0
            this.birthx = seedRandom() - .5
            this.birthy = seedRandom() - .5
            this.r = seedRandom() * 255
            this.g = seedRandom() * 255
            this.b = seedRandom() * 255
            this.p = seedRandom() * 255
            this.m = seedRandom() * 255
            this.z = seedRandom() * 255
            this.q = seedRandom() * 255
            this.linkup = []
            this.prime = 0
            this.connected = 0
            this.head = 0
            this.ll = 0
            this.dcon = []
            if (t == 5) {
                this.mouth = 1
            }
            this.caught = 0
            this.age = 0
            this.xleap = 0
            this.yleap = 0
            this.immune = []
            this.stupidimmune = []
            this.neighbors = []
            this.stupidneighbors = []
            this.type = t
            this.id = superclick
            // superclick++
            this.x = x
            this.y = y
    
            this.lastx = this.x
            this.lasty = this.y
            // if(nope == 0){
            //     this.link = new LineOP(this, this, "#808080")
            //     this.link.list  =[]
            // }
            this.lout = ((loutmin * worldscaler) + 2) - (((seedRandom() - .5) * 4) * worldscaler)
            this.loutin = this.lout
            this.las = []
            this.happy = true 
            for (let t = 0; t < timesLength; t++) {
                this.las.push(seedRandom() * 6.283)
            }
            this.rigs = []
            this.times = []
            this.subticks = []
            for (let t = 0; t < timesLength; t++) {
                this.subticks.push(((seedRandom() - .5) / 16))
            }
            this.ticks = []
    
            this.pistonstarts = []
            this.pistontimes = []
            this.pistonticks = []
            for (let t = 0; t < timesLength; t++) {
                this.times.push(seedRandom()*Math.PI*2)
                this.pistontimes.push(seedRandom()*Math.PI*2)
                this.pistonstarts.push(seedRandom() * 10000)
                this.pistonpushes.push((seedRandom() * (loutmin * worldscaler) * 3.5) - ((loutmin * worldscaler) * .5))
                this.ticks.push(((seedRandom() - .5) / 16))
                this.pistonticks.push(((((seedRandom() - .5))) * 2) / 10)
            }
            this.subrots = []
            for (let t = 0; t < timesLength; t++) {
                this.subrots.push(((seedRandom() - .5) / 6))
            }
            for (let t = 0; t < timesLength; t++) {
                this.rigs.push(1 - ((seedRandom() / 10) + .90))
            }
            this.pushout = seedRandom() * 6.283
            this.pushoutsto = this.pushout
            // ////////////////////////////////////////console.log(this.id)
            // if(nope == 0){
            //     // globalnodes.push(this)
            // }
            this.energy = 0
            this.generate = 0
            if (this.type == 4 || this.type == 7 || this.type == 8 || this.type == 14 || this.type == 11 || this.type == 9) {
                this.generate = generationConstant
            }
            if (this.type == 20) {
                this.generate = generationConstant //*.5 from when it was armor
            } 
            this.gencap = 100000000 //holycrap this kills complexity sub 1000
            this.energy = 0
    
            this.hit = 0
            this.lt = new Point(this.x, this.y)
    
        }
        freeenergy() {
            this.link.object = this
            this.nodeEnergyCost = 0
        }
        map(k, f) {
            if (this.dead == 1) {
                return
            }
    
            let scare = {}
    
            for (let d = 0; d < f.length; d++) {
                scare[k[d]] = d
            }
            return scare
        }
        freakmap() {
            mappingArt[this.contextMarker].x = Math.min(this.x, mappingArt[this.contextMarker].x)
            mappingArt[this.contextMarker].y = Math.min(this.y, mappingArt[this.contextMarker].y)
            mappingArt[this.contextMarker].width = Math.max(Math.abs(mappingArt[this.contextMarker].x - (this.x)), mappingArt[this.contextMarker].width)
            mappingArt[this.contextMarker].height = Math.max(Math.abs(mappingArt[this.contextMarker].y - (this.y)), mappingArt[this.contextMarker].height)
        }
        dupe(num) {
            // //////////////////////////////////console.log(num)
            if (this.dead == 1) {
                return false
            }
    
            let alldead = 0
            for (let t = 0; t < globalnodes.length; t++) {
                if (globalnodes[t].dead == 1) {
                    alldead++
                }
            }
    
            if ((globalnodes.length - alldead) >= nodecap - (this.immune.length * 2) || num == 0) {
                return false
            }
            // let node = new Node(seedRandom()*360 ,seedRandom()*360, this.type)
            // if(this.age > minage){
            // this.age = minage
            let node
    
    
            if(keysPressed['e'] || pu.seeage == 1){
    
                let age = Math.round(this.age * 100) / 100
                canvas_context.strokeText(Math.round(100 * (age / ((((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)))) + "%", this.xavg, this.yavg)
                canvas_context.fillText(Math.round(100 * (age / ((((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)))) + "%", this.xavg, this.yavg)
                ////////console.log(age, ((((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)))
    
    
    
            }
    
            if ((seedRandom() < mutationrate * 1) && this.head != 1) {
    
                //////////////////console.log("s")
                return false
            } else {
                if ((seedRandom() < mutationrate)) {
                    // node = new Node(this.x+((seedRandom()-.5)*20), this.y+((seedRandom()-.5)*20) , Math.floor(seedRandom()*nodetypes))
    
                    if (codonusage == 1) {
                        let g = mutateGenes(this.genestring)
                        if (seedRandom() < mutationrate) {
                            let h = g
                            g = this.genebucket[Math.floor(seedRandom() * this.genebucket.length)] //add mating
                            if(this.genebucket.length == 0){
                                g = mutateGenes(this.genestring)
                            }
                            let fr = ((h).split('')).length
                            let gr = ((g).split('')).length
                            let indexer1 = Math.floor(seedRandom() * fr)
                            let indexer2 = Math.floor(seedRandom() * gr)
                            let ls = ''
                            let rs = ''
    
    
                            for (let t = 0; t < fr; t++) {
                                if (t < indexer1) {
                                    ls += ((h).split(''))[t]
                                } else {
                                    rs += ((h).split(''))[t]
                                }
                            }
                            for (let t = 0; t < gr; t++) {
                                if (t < indexer2) {
                                    ls += ((g).split(''))[t]
                                } else {
                                    rs += ((g).split(''))[t]
                                }
                            }
                            ////////////////console.log(rs, ls)
    
                            ////////////////console.log((rs.split('')).length)
                            ////////////////console.log((ls.split('')).length)
                            if (seedRandom() < .5) {
                                if ((ls.split('')).length == 0) {
    
                                    g = rs
                                } else {
    
                                    g = ls
                                }
                            } else {
                                if ((rs.split('')).length == 0) {
    
                                    g = ls
                                } else {
    
                                    g = rs
                                }
                            }
                        }
                        node = new Node(this.x + ((this.birthx + Math.cos(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.y + ((this.birthy + Math.sin(this.pushout)) * ((loutmin * worldscaler) * 1.5)), geneToType(g), g)
                        node.head = this.head
                        node.bet = this.bet * .5
                        pu.potential += this.bet
                        headout = 1
                    } else {
                        let g = mutateGenes(this.genestring)
                        node = new Node(this.x + ((this.birthx + Math.cos(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.y + ((this.birthy + Math.sin(this.pushout)) * ((loutmin * worldscaler) * 1.5)), Math.floor(seedRandom() * (nodetypes - 1)), g) //-1 because disease
                        node.head = this.head
                        node.bet = this.bet * .5
                        pu.potential += this.bet
                        headout = 1
                    }
                } else {
                    if (codonusage == 1) {
                        let g = mutateGenes(this.genestring)
                        if (seedRandom() < mutationrate) {
    
                            let h = g
                            g = this.genebucket[Math.floor(seedRandom() * this.genebucket.length)] //add mating
                            if(this.genebucket.length == 0){
                                g = mutateGenes(this.genestring)
                            }
                            let fr = ((h).split('')).length 
                            let gr = ((g).split('')).length
                            let indexer1 = Math.floor(seedRandom() * fr)
                            let indexer2 = Math.floor(seedRandom() * gr)
                            let ls = ''
                            let rs = ''
    
                            for (let t = 0; t < fr; t++) {
                                if (t < indexer1) {
                                    ls += ((h).split(''))[t]
                                } else {
                                    rs += ((h).split(''))[t]
                                }
                            }
                            for (let t = 0; t < gr; t++) {
                                if (t < indexer2) {
                                    ls += ((g).split(''))[t]
                                } else {
                                    rs += ((g).split(''))[t]
                                }
                            }
                            // ////////////////console.log(rs, ls)
                            // ////////////////console.log((rs.split('')).length)
                            // ////////////////console.log((ls.split('')).length)
                            if (seedRandom() < .5) {
                                if ((ls.split('')).length == 0) {
    
                                    g = rs
                                } else {
    
                                    g = ls
                                }
                            } else {
                                if ((rs.split('')).length == 0) {
    
                                    g = ls
                                } else {
    
                                    g = rs
                                }
                            }
                        }
                        node = new Node(this.x + ((this.birthx + Math.cos(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.y + ((this.birthy + Math.sin(this.pushout)) * ((loutmin * worldscaler) * 1.5)), geneToType(g), g)
                        node.head = this.head
                        node.bet = this.bet * .5
                        pu.potential += this.bet
                        headout = 1
                    } else {
                        let g = this.genestring
                        node = new Node(this.x + ((this.birthx + Math.cos(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.y + ((this.birthy + Math.sin(this.pushout)) * ((loutmin * worldscaler) * 1.5)), this.type, g)
                        node.head = this.head
                        node.bet = this.bet * .5
                        pu.potential += this.bet
                        headout = 1
                    }
    
                }
    
            }
    
            //ticks rigs pushout sto time
    
            if (seedRandom() < mutationrate) {
                node.charge = 0
                if (seedRandom() < .66) {
                    node.charge = Math.sign(seedRandom() - .5)
                }
            } else {
                node.charge = this.charge
            }
    
            node.magratio = this.magratio
    
            if (seedRandom() < mutationrate) {
    
                node.magratio = this.magratio + ((seedRandom() - .5) / 4)
    
            }
    
            node.magratio = Math.min(Math.max(node.magratio, 0), magratmax)
    
    
            if (seedRandom() < mutationrate) {
                node.birthx = this.birthx + ((seedRandom() - .5))
                node.birthx = Math.max(Math.min(node.birthx, .5), -.5)
            } else {
                node.birthx = this.birthx
            }
    
            if (seedRandom() < mutationrate) {
                node.birthy = this.birthy + ((seedRandom() - .5))
                node.birthy = Math.max(Math.min(node.birthy, .5), -.5)
            } else {
                node.birthy = this.birthy
            }
    
    
            node.ticks = [...this.ticks]
            node.pistonticks = [...this.pistonticks]
            node.subticks = [...this.subticks]
            node.subrots = [...this.subrots]
            node.noseStrengths = [...this.noseStrengths]
            node.noseThresh = this.noseThresh
            node.stinkRate = this.stinkRate
    
    
            if (seedRandom() < mutationrate) {
                node.noseThresh += (Math.floor((seedRandom() - .5) * 24))
            }
            if (seedRandom() < mutationrate) {
                node.stinkRate += (Math.floor((seedRandom() - .5) * 10))
            }
    
            node.stinkRate = Math.max(5, node.stinkRate)
    
    
            node.nosePref = [...this.nosePref]
            node.noseAvoid = [...this.noseAvoid]
            node.soundPref = []
    for(let t = 0;t<this.soundPref.length;t++){
        if(this.soundPref[t] ==1){
            node.soundPref[t] = this.soundPref[t]
        }
    }
            node.soundAvoid = []
    for(let t = 0;t<this.soundAvoid.length;t++){
        if(this.soundAvoid[t] ==1){
    node.soundAvoid[t] = this.soundAvoid[t]
        }
    }
    
    
    
    if (seedRandom() < mutationrate*sensoryConstant) {
    node.nosePref.push(Math.floor(seedRandom() * nodetypes))
    }
    if (seedRandom() < mutationrate*sensoryConstant) {
    node.noseAvoid.push(Math.floor(seedRandom() * nodetypes))
    }
    
    if (seedRandom() < mutationrate*sensoryConstant) {
    node.noseAvoid.splice(Math.floor(seedRandom() * node.noseAvoid.length), 1)
    }
    if (seedRandom() < mutationrate*sensoryConstant) {
    node.nosePref.splice(Math.floor(seedRandom() * node.nosePref.length), 1)
    }
    
    
    
    
    for(let k = 0;k<sensoryConstant;k++){

        if (seedRandom() < mutationrate*sensoryConstant) {
            node.soundPref[primes[Math.floor(seedRandom() * primes.length)] * primes[Math.floor(seedRandom() * primes.length)]] = 1
            }
            if (seedRandom() < mutationrate*sensoryConstant) {
            node.soundAvoid[primes[Math.floor(seedRandom() * primes.length)] * primes[Math.floor(seedRandom() * primes.length)]] = 1
            }
            
            if (seedRandom() < mutationrate*sensoryConstant) {
            let selector = []
            for(let t = 0;t<node.soundAvoid.length;t++){ 
                if(node.soundAvoid[t] == 1){
                    selector.push(t)
                }
            }
            node.soundAvoid[selector[Math.floor(seedRandom() * selector.length)]] = 0
            }
            if (seedRandom() < mutationrate*sensoryConstant) {
            let selector = []
            for(let t = 0;t<node.soundPref.length;t++){
                if(node.soundPref[t] == 1){
                    selector.push(t)
                }
            }
            node.soundPref[selector[Math.floor(seedRandom() * selector.length)]] = 0
            }
    }




    
            for (let t = 0; t < node.ticks.length; t++) {
                if ((seedRandom() < mutationrate)) {
                    node.noseStrengths[t] += ((seedRandom() - .5) / 32)
                }
                if ((seedRandom() < mutationrate)) {
                    node.noseStrengths[t] += ((seedRandom() - .5) / 16)
                }
                node.noseStrengths[t] = Math.max(node.noseStrengths[t], 0)
            }
            for (let t = 0; t < node.ticks.length; t++) {
                if ((seedRandom() < mutationrate)) {
                    node.ticks[t] += ((seedRandom() - .5) / 32)
                }
                if ((seedRandom() < mutationrate)) {
                    node.ticks[t] = ((seedRandom() - .5) / 16)
                }
            }
    
            for (let t = 0; t < node.pistonticks.length; t++) {
                if ((seedRandom() < mutationrate)) {
                    node.pistonticks[t] += ((seedRandom() - .5) / 10)
                }
                if ((seedRandom() < mutationrate)) {
                    node.pistonticks[t] = ((((seedRandom() - .5))) * 2) / 10
                }
            }
    
            for (let t = 0; t < node.subticks.length; t++) {
                if ((seedRandom() < mutationrate)) {
                    node.subticks[t] += ((seedRandom() - .5) / 32)
                }
                if ((seedRandom() < mutationrate)) {
                    node.subticks[t] = ((seedRandom() - .5) / 16)
                }
            }
            for (let t = 0; t < node.subrots.length; t++) {
                if ((seedRandom() < mutationrate)) {
                    node.subrots[t] += ((seedRandom() - .5) / 32)
                }
                if ((seedRandom() < mutationrate)) {
                    node.subrots[t] = ((seedRandom() - .5) / 16)
                }
            }
    
            node.rigs = [...this.rigs]
            node.pistonstarts = [...this.pistonstarts]
            node.pistonpushes = [...this.pistonpushes]
            node.pistonticks = [...this.pistonticks]
            // node.pistontimes = [...this.pistontimes]
    
            node.r = Math.max(Math.min(255, this.r + ((seedRandom() - .5) * 32)), 0)
            node.g = Math.max(Math.min(255, this.g + ((seedRandom() - .5) * 32)), 0)
            node.b = Math.max(Math.min(255, this.b + ((seedRandom() - .5) * 32)), 0)
            node.p = Math.max(Math.min(255, this.p + ((seedRandom() - .5) * 32)), 0)
            node.m = Math.max(Math.min(255, this.m + ((seedRandom() - .5) * 32)), 0)
            node.z = Math.max(Math.min(255, this.z + ((seedRandom() - .5) * 32)), 0)
            node.q = Math.max(Math.min(255, this.q + ((seedRandom() - .5) * 32)), 0)
    
            for (let t = 0; t < node.rigs.length; t++) {
                if ((seedRandom() < mutationrate)) {
                    node.rigs[t] = (1 - ((seedRandom() / 10) + .90))
                }
            }
            for (let t = 0; t < node.pistonstarts.length; t++) {
                if ((seedRandom() < mutationrate)) {
                    node.pistonstarts[t] = (seedRandom() * 100000)
                }
                if ((seedRandom() < mutationrate)) {
                    node.pistonstarts[t] += ((seedRandom() - .5) * (Math.PI * 2))
                }
            }
    
            node.pushoutsto = this.pushoutsto
            node.pushout = this.pushout
    
            if ((seedRandom() < mutationrate * 1)) {
                node.pushout = seedRandom() * Math.PI * 2
            }
    
    
    
            node.lout = Math.max(this.lout + (((seedRandom() - .5) * 2) * worldscaler), (loutmin * worldscaler))
    
            node.linkApha = this.linkApha
            node.loutin = node.lout
            if ((seedRandom() < mutationrate * 1)) {
                node.pistonstep = this.pistonstep + ((((seedRandom() - .5) * 1)) / 10)
            } else {
                node.pistonstep = this.pistonstep
            }
            if ((seedRandom() < mutationrate * 1)) {
                // node.cut = 1
            } else {
    
                if (seedRandom() < mutationrate) {
    
                    let superduper = {}
                    if (deadwash == deadmax - 1) {
    
                        //////////////////////console.log("W")
                        superduper.linkto = globalnodes.indexOf(node)
                    } else {
    
                        //////////////////////console.log("M")
                        superduper.linkto = globalnodes.indexOf(node)
                    }
                    superduper.x = node.x
                    superduper.y = node.y
                    superduper.head = 0
                    if (seedRandom() < .5) {
                        if (this.head == 1) {
                            ////////////////console.log("hit")
                            node.head = 0
                            superduper.head = 1
                        }
                    }
                    superduper.type = Math.floor(seedRandom() * (nodetypes - 1)) //-1 because disease
                    let gr = this.genestring
                    let ch = this.charge
                    let mh = this.magratio
                    if (seedRandom() < .33) {
                        gr = ''
                        ch = 0
                        mh = 1
    
                        if (seedRandom() < mutationrate) {
                            mh = mh + ((seedRandom() - .5))
                        }
                        mh = Math.min(Math.max(mh, 0), magratmax)
    
    
                        if (seedRandom() < .66) {
                            if (seedRandom() < .5) {
                                ch = 1
                            } else {
                                ch = -1
                            }
                        }
                        for (let r = 0; r < genelength; r++) {
                            gr += geneChars[Math.floor(seedRandom() * geneChars.length)]
                        }
                        ch = this.charge
                        mh = this.magratio
                    } else if (seedRandom() < .33) {
                        gr = this.genebucket[Math.floor(seedRandom() * this.genebucket.length)]
                        ch = this.chargebucket[Math.floor(seedRandom() * this.chargebucket.length)]
                        mh = this.magbucket[Math.floor(seedRandom() * this.magbucket.length)]
                        if(this.genebucket.length == 0){
                            gr = this.genestring
                        }
                    }
                    superduper.genestring = gr 
                    superduper.linkApha = this.linkApha
                    if (seedRandom() < mutationrate * 3) { //2
                        superduper.radio = 1
                    } else {
                        superduper.radio = 0
                    }
                    if (seedRandom() < mutationrate * 3) { //2
                        superduper.extra = 1
                    } else {
                        superduper.extra = 0
                    }
    
                    
                    superduper.charge = ch
                    superduper.magratio = mh
                    globduper.push(superduper) 
    
    
                }
    
    
            }
    
            return node
            // }
    
    
            return false
        }
    
    
    
    
        //a teleporting magnolia tree that goes on adventures but lives on one place
        tupe(macro, node) {
            let alldead = 0
            for (let t = 0; t < globalnodes.length; t++) {
                if (globalnodes[t].dead == 1) {
                    alldead++
                }
            }
    
            if ((globalnodes.length - alldead) >= nodecap - (this.immune.length * 2)) {
                return false
            }
            if (this.dead == 1) {
                return
            }
            let table = []
            // for(let t= 0 ;t<macro.f.length;t++){
            //     table[macro.f[t]] = t
            // }
            //  let  babble  = macro.match[me]
            //  ////////////////////////////////////console.log(macro.f, node.linkup)
            //  ////////////////////////////////////console.log(table)
            if (node.linkup.length > 1) {
                //////////////////console.log(node)
            }
            for (let t = 0; t < node.linkup.length; t++) {
                let offset = macro.f.indexOf(node.linkup[t])
                // //////////////////////////////////console.log(offset, macro.f, node.linkup) 
                if (offset + macro.start <= globalnodes.length) {
                    if (globalnodes[offset + macro.start].hitcon != 1) {
                        if (offset != -1) {
    
                            node.connected++
                            globalnodes[(offset + macro.start)].connected++
                            node.connect(globalnodes[(offset + macro.start)])
                            if (node.connected > 2) {
    
                                //////////////////console.log(node, globalnodes[(offset+macro.start)], macro)
                            }
                            if (globalnodes[(offset + macro.start)].connected > 2) {
                                //////////////////console.log(node, globalnodes[(offset+macro.start)], macro)
                            }
                        }
                        // ////////////////////////////////////console.log(globalnodes[(offset+macro.start)].type, globalnodes[node.linkup[t]].type)
                        // globalnodes[offset+macro.start].hitcon = 1
                        // node.hitcon = 1
                    }
                }
            }
        }
    
    
    
    
        // tupe(num, macro, me,node){
        //     if(globalnodes.length > nodecap || num == 0){
        //         return
        //     }
        //     let keys = Object.keys(macro.match)
        //     let arts = this.map(keys, macro.f)
    
        //     //////////////////////////////////////console.log( arts, me)
        //     let letters = macro.match[arts[me]] 
        //     for(let t = 0;t<letters.length;t++){
        //         if(globalnodes[letters[t]+macro.start]){
    
        //         node.connect(globalnodes[letters[t]+macro.start])
        //         }
        //     }
        // }
        energyBalance() {
            this.m = -1
            this.balanced = 1
            if (this.head != 1) {
                return
            }
            if (this.hit == 1) {
                return
            }
            if (this.dead == 1) {
    
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
    
            if (this.caught == 1) {
                return
            }
    
    
    
            let glist = [this]
    
            let flist = [this]
    
            let runsum = this.prime
            let runprod = this.prime
            let f = [globalnodes.indexOf(this)]
            for (let t = 0; t < flist.length; t++) {
                if (flist[t]) {
                    for (let k = 0; k < flist[t].neighbors.length; k++) {
                        if (f.includes((flist[t].neighbors[k]))) { //|| globalnodes[flist[t].neighbors[k]].dead == 1
                        } else {
                            if (globalnodes[flist[t].neighbors[k]]) {
                                runprod *= globalnodes[flist[t].neighbors[k]].prime
                                runsum += globalnodes[flist[t].neighbors[k]].prime
                                f.push((flist[t].neighbors[k]))
                                // if(flist[t]){ 
                                flist.push(globalnodes[flist[t].neighbors[k]])
    
                            }
                            // }
                        }
                    }
    
                }
            }
    
    
    
    
            // ////////////////////////////////////console.log(flist)
            for (let t = 0; t < flist.length; t++) {
                for (let k = 0; k < flist[t].neighbors.length; k++) {
                    if (f.includes((flist[t].neighbors[k]))) {
    
    
                        // ////////////////////////////////////console.log(flist)
                        let screw = 0
                        let snapout = 0
                        for (let w = 0; w < glist.length; w++) {
                            if (snapout == 1) {
                                continue
                            }
                            if (glist[w].x > -10000) {
                                screw = -1
                            }
                            if (keysPressed['g']) {
                                ////////////////////////////////////console.log(globalnodes[flist[t].neighbors[k]].id)
                            }
                            if (glist[w].id == globalnodes[flist[t].neighbors[k]].id) {
                                screw = 1
                                snapout = 1
                                //  ////////////////////////////////////console.log('s')
                            }
                        }
    
    
                        if (screw == -1) {
                            glist.push(globalnodes[flist[t].neighbors[k]])
    
                        }
                    }
                }
            }
    
    
    
            for (let t = 0; t < glist.length; t++) {
                if (glist[t].radio == 1) {
                    let met = Math.floor(seedRandom() * glist.length)
                    if (met != t) {
                        glist[t].radio = 0
                        glist[t].connect(glist[met])
                    }
                }
    
            }
    
            for (let t = 0; t < glist.length; t++) {
                if (glist[t].extra == 1) {
                    let met = Math.floor(seedRandom() * glist.length)
                    let mek = Math.floor(seedRandom() * glist.length)
                    ////////////////////////////////console.log(met, mek) 
                    if (met != mek) {
                        glist[t].extra = 0
                        glist[mek].connect(glist[met])
                    }
                }
    
            }
    
    
            if (keysPressed['g']) {
                ////////////////////////////////////console.log(f,glist)
            }
            let g = 0
            let m = 0
            let ag = 0
            let ll = 0
            let p = 0
            let eoc = 0
    
            for (let t = 0; t < glist.length; t++) {
                glist[t].immune = []
                glist[t].stupidimmune = []
                glist[t].caught = 1
            }
    
            for (let t = 0; t < glist.length; t++) {
                for (let k = 0; k < glist.length; k++) {
                    glist[t].immune.push(globalnodes.indexOf(glist[k]))
                    glist[k].immune.push(globalnodes.indexOf(glist[t]))
                    glist[k].stupidimmune[glist[t].id] = 1
                    glist[t].stupidimmune[glist[k].id] = 1
    
    
                }
            }
    
    
    
            let angles = []
            let mags = []
            for (let t = 0; t < glist.length; t++) {
                // for(let k = 0;k<glist[t].link.list.length;k++){
                g += glist[t].energy
                p += glist[t].pushoutsto
                ag += glist[t].age
                ll += (glist[t].immune.length + 1)
                eoc += glist[t].nodeEnergyCost
                m++
                // }
                angles.push(glist[t].pushoutsto)
                mags.push(1)
            }
    
            if (keysPressed[' ']) {
                ////////////////////////////////////////console.log(glist)
            }
            g /= m
            p /= m
            ag /= m
            ll /= m
    
            //////////console.log(p)
            p = weightedAverageAngle(angles, mags)
            //////////console.log(p)
    
    
            // ////////////////////////////////////////console.log(g,m)
    
            let matmatch = {}
            let startin = globalnodes.length
            let macro = {}
            macro.match = matmatch
            macro.start = startin
            macro.f = f.sort((a, b) => a > b ? 1 : -1)
    
            this.m = m
            g = Math.min((repconstant * ((((m))))), g)
            if (g >= (repconstant * ((((m))))) && glist.length > 1 && macrodupe == 0 && deadwash < deadmax - 3 && deadwash > 3) {
    
                //////////////////////////////////console.log((100*(Math.sqrt(Math.sqrt((m*30)-25)))) ,g)
                glist.sort((a, b) => globalnodes.indexOf(a) > globalnodes.indexOf(b) ? 1 : -1)
                // macrodupe = 1
    
                ////////////////////////////////////console.log(glist)
                for (let t = 0; t < glist.length; t++) {
                    matmatch[globalnodes.indexOf(glist[t])] = []
                    // let mv  = []
                    for (let k = 0; k < glist[t].link.list.length; k++) {
                        if (!matmatch[globalnodes.indexOf(glist[t])].includes(glist[t].link.list[k])) {
                            // mv.push(glist[t].link.list[k])
                            matmatch[globalnodes.indexOf(glist[t])].push(glist[t].link.list[k])
                        }
                    }
    
                }
    
    
    
                let nodds = []
                headout = 0
                let kills = []
                for (let t = 0; t < glist.length; t++) {
    
                    // //////////////////////////////////console.log(glist[t].neighbors.length)
                    let nodd = glist[t].dupe(glist[t].neighbors.length)
    
                    if (nodd != false) {
    
                        if (glist[t].neighbors.length > 1) {
                            ////////////////////console.log("W")
                        }
                        nodd.linkup = [...glist[t].neighbors]
                        if (seedRandom() < mutationrate) {
                            let pos = macro.f[Math.floor(seedRandom() * macro.f.length)]
                            if (nodd.linkup.includes(pos)) {} else {
                                nodd.linkup.push(pos)
                            }
                        }
                        nodd.t = globalnodes.indexOf(glist[t])
                        nodds.push(nodd)
                    } else {
                        kills.push(globalnodes.indexOf(glist[t]))
                        ////////////////////////////console.log(matmatch)
    
                        // glist[t].neighbors.splice(glist[t].neighbors.indexOf(globalnodes.indexOf(glist[t])),1)
                        ////////////////////console.log(macro.f)
    
                        macro.f.splice(macro.f.indexOf(globalnodes.indexOf(glist[t])), 1)
                        ////////////////////console.log(macro.f)
    
    
    
    
                        // let key = Object.keys(matmatch)
                        // for(let z = 0;z<key.length;z++){
                        //     if(key[z] == glist[t].id){
                        //         delete matmatch[key[z]]
                        //     }else{
                        //         for(let q = 0;q<matmatch[key[z]].length;q++){
                        //             ////////////////////////////console.log(matmatch[key[z]].indexOf(glist[t].id))
                        //             matmatch[key[z]].splice(matmatch[key[z]].indexOf(glist[t].id),1)
                        //         }
                        //     }
                        // }
    
    
    
    
                        // return
                    }
                }
    
    
    
    
                for (let t = 0; t < kills.length; t++) {
                    for (let ww = 0; ww < nodds.length; ww++) {
                        ////////////////////////////console.log(nodds[ww].linkup.indexOf(glist[t].id))
                        ////////////////////console.log(nodds[ww].linkup)
                        nodds[ww].linkup.splice(nodds[ww].linkup.indexOf(kills[t]), 1)
                        ////////////////////console.log(nodds[ww].linkup)
    
                    }
                }
                if (nodds.length > 0) {
    
                    g -= (repconstant * ((((m)))))
                }
                for (let t = 0; t < nodds.length; t++) {
                    nodds[t].tupe(macro, nodds[t])
                    for (let k = 0; k < nodds.length; k++) {
                        // nodds[k].hitcon = 0
                    }
                }
    
    
                for (let t = 0; t < nodds.length; t++) {
                    if (nodds[t].cut == 1) { //no
    
    
                        for (let w = 0; w < globalnodes.length; w++) {
    
                        }
                        for (let k = 0; k < nodds[t].neighbors.length; k++) {
                            globalnodes[nodds[t].neighbors[k]].disconnect(nodds[t])
                            // .disconnect() //
                        }
    
                        // nodds[t].dead = 1
                        // for(let k = 0;k<nodds.length;k++){
                        //     nodds[k].disconnect(nodds[t])
                        // }
                    }
                }
                for (let t = 0; t < nodds.length; t++) {
                    nodds[t].hitcon = 0
                }
    
    
                // ////////////////////////////////////////console.log(macro)
            }
    
            let x = 0
            let y = 0
            for (let t = 0; t < glist.length; t++) {
                glist[t].genebucket = []
                glist[t].chargebucket = [0]
                glist[t].magbucket = [1]
    
            }
            for (let t = 0; t < glist.length; t++) {
                // for(let k = 0;k<glist[t].link.list.length;k++){
                glist[t].energy = g
                glist[t].pushoutsto = p
                glist[t].age = ag
                glist[t].ll = ll
                glist[t].hit = 1
                glist[t].head = 0
                glist[t].runsum = runsum
                glist[t].runprod = runprod
                glist[t].energyOrgCost = eoc
    
    
    
                glist[t].r = this.r
                glist[t].g = this.g
                glist[t].b = this.b
                glist[t].z = this.z
                glist[t].m = this.m
                glist[t].p = this.p
                glist[t].q = this.q
    
                glist[t].w = this.w
    
                x += glist[t].x
                y += glist[t].y
                for (let k = 0; k < glist.length; k++) {
                    glist[t].genebucket.push(glist[k].genestring)
                    glist[t].chargebucket.push(glist[k].charge)
                    glist[t].magbucket.push(glist[k].magratio)
    
                }
                // }
            }
    
            y /= m
            x /= m
    
            for (let t = 0; t < glist.length; t++) {
                glist[t].xavg = x
                glist[t].yavg = y
                glist[t].shead = globalnodes.indexOf(this)
            }
            if (edgeLoop == 1) {
    
                if (x < 0) {
    
                    ////////////////////////console.log(this.immune.length, glist.length)
                    for (let t = 0; t < glist.length; t++) {
                        glist[t].xleap = (canvas.width / zoom) - 0
                    }
                    // this.x += canvas.width/zoom
                }
                if (x > (canvas.width / zoom) + 0) {
    
                    for (let t = 0; t < glist.length; t++) {
                        glist[t].xleap = -((canvas.width / zoom) - 0)
                    }
                    // this.x -= canvas.width/zoom
                }
                if (y < -0) {
    
                    ////////////////////////console.log(this.immune.length, glist.length)
                    for (let t = 0; t < glist.length; t++) {
                        glist[t].yleap = (canvas.height / zoom) - 0
                    }
                    // this.y += canvas.width/zoom
                }
                if (y > (canvas.height / zoom) + 0) {
    
                    for (let t = 0; t < glist.length; t++) {
                        glist[t].yleap = -((canvas.height / zoom) - 0)
                    }
                    // this.y -= canvas.width/zoom
                }
            }
    
    
    
            this.energy = g
            this.pushoutsto = p
            this.age = ag
            this.ll = ll
            // this.pushout = p
    
            // ////////////////////////////////////////console.log(this)
            this.hit = 1
            for (let t = 0; t < this.immune.length; t++) {
                globalnodes[this.immune[t]].head = 0
                globalnodes[this.immune[t]].contextMarker = this.contextMarker
            }
    
    
    
            this.head = 1
    
    
        }
        disconnect(node) {
            if (this.superdead == 1) {
                return
            }
            if (this.dcon.includes(node.id)) {
                return
            }
    
            // //////////////////////////////////console.log(node, this)
            // if(node.neighbors.includes(globalnodes.indexOf(this))){
            let ni = node.id
            let nit = this.id
            this.neighbors.splice(this.neighbors.indexOf(ni), 1)
            node.neighbors.splice(node.neighbors.indexOf(nit), 1)
            this.stupidneighbors[ni] = 0
            node.stupidneighbors[nit] = 0
            // }
            // if(this.neighbors.includes(globalnodes.indexOf(node))){
            this.neighbors.splice(this.neighbors.indexOf(ni), 1)
            node.neighbors.splice(node.neighbors.indexOf(nit), 1)
            // }
    
            this.dcon.push(ni)
            node.dcon.push(nit)
            this.dmark = 1
            node.dmark = 1
    
            let supp = 0
            for (let t = 0; t < this.neighbors.length; t++) {
                if (this.neighbors[t] == this.id) {} else {
                    supp = 1
                }
            }
            if (supp == 0) {
                this.head = 1
            }
    
    
    
            let supph = 0
            for (let t = 0; t < node.neighbors.length; t++) {
                if (node.neighbors[t] == node.id) {} else {
                    supph = 1
                }
            }
            if (supph == 0) {
                node.head = 1
            }
    
    
        }
        connect(node) {
            if (this.dead == 1) {
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
    
            if (globalnodes.indexOf(node) == globalnodes.indexOf(this)) {
                return
            }
            if (this.neighbors.includes(globalnodes.indexOf(node)) || node.neighbors.includes(globalnodes.indexOf(this))) {
                return
            }
    
    
            this.neighbors.push(globalnodes.indexOf(node))
            node.neighbors.push(globalnodes.indexOf(this))
    
            this.stupidneighbors[globalnodes.indexOf(node)] = 1
            node.stupidneighbors[globalnodes.indexOf(this)] = 1
    
            if (this.neighbors.length > 2) {
                ////////////////////console.log(this)
            }
    
            return
    
            if (this.type == 6) {
                this.neighbors.push(globalnodes.indexOf(node))
                node.neighbors.push(globalnodes.indexOf(this))
            } else if (this.type == 0 || this.type == 3) {
                if (this.type == 3) {
                    if (node.type != 3 && node.type != 1) {
    
                        this.neighbors.push(globalnodes.indexOf(node))
                        node.neighbors.push(globalnodes.indexOf(this))
                    }
                } else {
    
                    this.neighbors.push(globalnodes.indexOf(node))
                    node.neighbors.push(globalnodes.indexOf(this))
                }
            } else {
                if (this.type == 1) {
                    if ((this.neighbors.length < 4 || node.type == 6)) {
                        if (node.type != 1 && node.type != 3) {
                            this.neighbors.push(globalnodes.indexOf(node))
                            node.neighbors.push(globalnodes.indexOf(this))
                        }
                    }
                }
                if (this.type == 2) {
                    if (this.neighbors.length < 3 || node.type == 6) {
                        if (node.type != 2) {
                            this.neighbors.push(globalnodes.indexOf(node))
                            node.neighbors.push(globalnodes.indexOf(this))
                        }
                    }
                }
                if (this.type == 4) {
                    if ((this.neighbors.length < 1 || node.type == 6) && node.type != 4 && node.type != 5) {
                        this.neighbors.push(globalnodes.indexOf(node))
                        node.neighbors.push(globalnodes.indexOf(this))
                    }
                }
                if (this.type == 5) {
                    if ((this.neighbors.length < 1 || node.type == 6) && node.type != 4) {
                        this.neighbors.push(globalnodes.indexOf(node))
                        node.neighbors.push(globalnodes.indexOf(this))
                    }
                }
    
    
            }
        }
        aged() {
    
    
    
            this.trueage++
    
            let len = this.genestring.split('').length
    
            if (this.energy > genelengthcost && codonusage == 1) {
                this.energy -= genelengthcost * len
            }
            if (codonusage == 1) {
                this.nodeEnergyCost += genelengthcost * len
    
    
            }
    
            if (this.drag == 1) {
                this.age += 1.25
                if (this.energy > dragcost) {
                    this.energy -= dragcost
                }
                this.nodeEnergyCost += dragcost
            }
    
            if (this.life != 1) {
                this.age++
            } else {
                if (this.energy > longevitycost) {
                    this.energy -= longevitycost
                    this.age += .25
                } else {
                    this.age++
                }
    
                this.nodeEnergyCost += longevitycost
            }
        }
        drive() {
    
    
            if (this.dead == 1) {
    
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
    
            if (this.energy < .01) {
                // this.age+= 10
            }
            this.hit = 0
            this.fed = 0
            if (this.produce == 1) {
                if (this.energy < this.gencap) {
                    this.energy += (this.generate * seedRandom() * 2) //same on a curve
                }
            }
    
    
            if (this.motor == 1) {
                if (this.energy >= movementCost) {
                    this.x += Math.cos(this.pushout) * 3 * worldscaler
                    this.y += Math.sin(this.pushout) * 3 * worldscaler
                    this.energy -= movementCost
                }
                this.nodeEnergyCost += movementCost
            }
            if (edgeLoop != 1) {
    
                if (this.x >= canvas.width / zoom) {
                    this.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                    // this.pushoutsto = this.pushout
                }
                if (this.y >= canvas.height / zoom) {
                    this.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                    // this.pushoutsto = this.pushout
                }
                if (this.x <= 0) {
                    this.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                    // this.pushoutsto = this.pushout
                }
                if (this.y <= 0) {
                    this.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                    // this.pushoutsto = this.pushout
                }
    
            }
        }
        make(context = canvas_context) {
    
            if (dumbdoton == 1) {
    
                dumbby.check(this)
            }
    
            if (this.type < 3) {
                // pix1.data[]
    
            } else if (this.type < 6) {
    
            } else if (this.type < 9) {
    
            } else if (this.type < 12) {
    
            } else if (this.type < 15) {
    
            } else if (this.type < 18) {
    
            }
    
            let worldscaler = (worldscale / 8)
            if (this.dead == 1) {
                this.inert = 1
    
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                // this.x = 999999
                // this.y = 999999+(seedRandom()*100000)
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Circle(this.x, this.y, 3 * (worldscaler), "#0044FF")
                }
                return
            }
    
    
            if (tempon == 1) {
                if (this.anchor != 1) {
                    this.x += ((seedRandom() - .5) / temperatureInvert) * temperature
                    this.y += ((seedRandom() - .5) / temperatureInvert) * temperature
                } else {
    
                    this.x += (((seedRandom() - .5) / temperatureInvert) * temperature) / 100
                    this.y += (((seedRandom() - .5) / temperatureInvert) * temperature) / 100
                }
            }
    
            //temperature proxy
            if (this.type == 15) {
    
                this.subr = 255
                this.subg = 200
                this.subb = 16
                this.prime = 59
                this.gill = 1
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 4 * (worldscaler), "#DDDD66", 5, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
    
    
            }
            if (this.gill == 1) {
                if(this.restrictgill == 1){
                    let xdif = Math.abs(this.lastx - this.x)
                    let ydif = Math.abs(this.lasty - this.y)
                    this.energy += (((xdif + ydif) * gillconstant) / worldscaler)*(1/5)
                    this.lastx = this.x
                    this.lasty = this.y
                }else{

                    let xdif = Math.abs(this.lastx - this.x)
                    let ydif = Math.abs(this.lasty - this.y)
                    this.energy += ((xdif + ydif) * gillconstant) / worldscaler
                    this.lastx = this.x
                    this.lasty = this.y
                }
            }
            //snode
            if (this.type == 20) {
    
                this.subr = (16 * 5) + 4
                this.subg = (16 * 3) + 2
                this.subb = 16
                this.prime = 53
                this.drag = 1
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 4 * (worldscaler), "#543210", 6, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
    
    
            }
    
    
    
            if (this.type == 0) {
                this.prime = 19
                this.subr = 255
                this.subg = 255
                this.subb = 255
                this.inert = 1
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Circle(this.x, this.y, 3 * (worldscaler), "#ffffff")
                    if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
                        this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#ffffff", 3, 0, 0, (this.pushout) + Math.PI)
                    }
                }
                if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                } else {
    
                    this.body.x = this.x
                    this.body.y = this.y
                }
            }
            if (this.type == 1) {
                this.subr = 255
                this.subg = 0
                this.subb = 128
                this.prime = 2
                this.rotor = 1
                this.armor = 1
                // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF00aa")
                // this.body = new Circle(this.x, this.y, 3, "#AA0055")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 4 * (worldscaler), "#AA0055", 4, 0, 0, (this.pushout) + Math.PI)
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) + Math.PI
            }
            if (this.type == 2) {
                this.subr = 255
                this.subg = 255
                this.subb = 0
                this.prime = 3
                this.armor = 1
                this.motor = 1
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#ffCc00", 3, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 3) {
                this.subr = 128
                this.subg = 0
                this.subb = 255
                this.prime = 5
                this.rotor = 1
                this.motor = 1
                if (this.firsty != 1) {
                    this.firsty = 1
                    // this.body = new Circle(this.x, this.y, 3.5, "#8800ff")
    
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#8800ff", 3, 0, 0, (this.pushout) + Math.PI)
                    if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
                        this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#8800ff", 3, 0, 0, (this.pushout) + Math.PI)
                    }
                }
    
                if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                } else {
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                    // this.body.x = this.x
                    // this.body.y = this.y
                }
    
            }
            if (this.type == 4) {
                this.subr = 0
                this.subg = 255
                this.subb = 0
                this.prime = 7
                this.produce = 1
                // this.body = new Circle(this.x, this.y, 4, "#00FF00")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#00FF00", 6, 0, 0, (this.pushout) + Math.PI)
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) + Math.PI
            }
            if (this.type == 5) {
                this.subr = 255
                this.subg = 0
                this.subb = 0
                this.prime = 23
                this.armor = 1
                this.mouth = 1
                // this.body = new Circle(this.x, this.y, 5, "#FF0000")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#FF0000", 5, 0, 0, (this.pushout) + Math.PI)
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) + Math.PI
            }
            if (this.type == 6) {
                this.subr = 255
                this.subg = 128
                this.subb = 0
                this.prime = 11
                this.armor = 1
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#FF8800", 4, 0, 0, (this.pushout) + Math.PI)
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) + Math.PI
            }
            if (this.type == 7) {
                this.subr = 0
                this.subg = 255
                this.subb = 255
                this.prime = 13
                this.produce = 1
                this.motor = 1
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#00FFFF", 3, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 8) {
                this.subr = 0
                this.subg = 255
                this.subb = 64
                this.prime = 17
                this.produce = 1
                this.rotor = 1
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#228844", 4, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 9) {
                this.subr = 64
                this.subg = 64
                this.subb = 255
                this.prime = 29
                this.anchor = 1
                this.produce = 1
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#4499FF", 5, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 10) {
                this.subr = 176
                this.subg = 100
                this.subb = 140
                this.prime = 31
                this.anchor = 1
                this.armor = 1
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#AA5678", 4, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 11) {
                this.subr = 176
                this.subg = 176
                this.subb = 176
                this.prime = 37
                this.piston = 1
                this.produce = 1
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 6 * (worldscaler), "#AAFFAA", 2, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 16) {
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 6 * (worldscaler), "#880000", 1, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 17) {
                this.subr = 80
                this.subg = 80
                this.subb = 80
                this.prime = 67
                this.nose = 1
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 6 * (worldscaler), "#666666", 1, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
            if (this.type == 12) {
                this.subr = 176
                this.subg = 128
                this.subb = 128
                this.prime = 41
                this.piston = 1
                this.armor = 1
                // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 6 * (worldscaler), "#AA8888", 2, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
            }
    
            if (this.type == 13) {
                this.prime = 43
                this.subr = 179
                this.subg = 0
                this.subb = 179
                this.inert = 1
                this.fertile = 1
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Circle(this.x, this.y, 3.5 * (worldscaler), "#FF44bb")
                    if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
                        this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#FF44bb", 3, 0, 0, (this.pushout) + Math.PI)
                    }
                }
                if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                } else {
    
                    this.body.x = this.x
                    this.body.y = this.y
                }
            }
            if (this.type == 13) {
                this.prime = 43
                this.subr = 179
                this.subg = 0
                this.subb = 179
                this.inert = 1
                this.fertile = 1
                if (this.firsty != 1) {
                    this.firsty = 1
                    this.body = new Circle(this.x, this.y, 3.5 * (worldscaler), "#FF44bb")
                    if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
                        this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#FF44bb", 3, 0, 0, (this.pushout) + Math.PI)
                    }
                }
                if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                } else {
    
                    this.body.x = this.x
                    this.body.y = this.y
                }
            }
            if (this.type == 14) {
                this.prime = 47
                this.subr = 128
                this.subg = 145
                this.subb = 0
                // this.inert = 1
                this.life = 1
                this.produce = 1
                if (this.firsty != 1) {
                    this.firsty = 1
                    // this.body = new Circle(this.x, this.y, 3, "#889900")
                    this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#889900", 5, 0, 0, (this.pushout) + Math.PI)
                    if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
                        this.body = new Polygon(this.x, this.y, 5 * (worldscaler), "#889900", 5, 0, 0, (this.pushout) + Math.PI)
                    }
                }
                if (viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                } else {
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                    // this.body.x = this.x
                    // this.body.y = this.y
                }
            }
            this.body.type = this.type
            if (magnetism > 0) {
                if (this.maghit != 1) {
                    this.maghit = 1
                    this.magnet = new CircleFill(this.x, this.y, magnetradius * this.magratio * worldscaler, magnetcolors[(this.charge + 1)])
                } else {
                    this.magnet.x = this.x
                    this.magnet.y = this.y
                }
                if (magdisplay == 1) {
                    if (this.charge != 0) {
                        // context.globalAlpha = this.linkApha
    
                        if (!keysPressed['7']) {
                            this.magnet.draw(context)
                        }
                        context.globalAlpha = 1
                        if (this.energy > magnetcost) {
                            this.energy -= magnetcost
                        }
    
                        this.nodeEnergyCost += magnetcost
                    }
                } else {
                    if (magmindisp == 1) {
    
                    }
                }
            }
    
            if (viewStyle == 4 || viewStyle == 6 || viewStyle == 6) {
                this.subcolor = `rgb(${(globalnodes[(this.shead)].r)},${(globalnodes[(this.shead)].g)},${ (globalnodes[(this.shead)].b)})`
                if (keysPressed['v']) {
                    this.subcolor = `rgb(${(globalnodes[(this.shead)].p)},${(globalnodes[(this.shead)].z)},${ (globalnodes[(this.shead)].q)})`
                }
                if (keysPressed['w']) {
                    this.subcolor = `rgb(${(globalnodes[(this.shead)].m)},${(globalnodes[(this.shead)].p)},${ (globalnodes[(this.shead)].z)})`
                }
                if (keysPressed['z']) {
                    this.subcolor = `rgb(${(globalnodes[(this.shead)].z)},${(globalnodes[(this.shead)].r)},${ (globalnodes[(this.shead)].m)})`
                }
    
                if (keysPressed['2']) {
                    this.subcolor = `rgb(${(globalnodes[(this.shead)].g)},${(globalnodes[(this.shead)].b)},${ (globalnodes[(this.shead)].q)})`
                }
    
    
                if (viewStyle == 6) {
                    this.subcolor = `rgb(${(globalnodes[(this.shead)][viewrota[rota%viewrota.length]])},${(globalnodes[(this.shead)][viewrota[(rota+1)%viewrota.length]])},${ (globalnodes[(this.shead)][viewrota[(rota+2)%viewrota.length]])})`
    
                }
    
    
                this.body.parent = this
                this.parent = this
            }
            if (viewStyle == 5 || viewStyle == 7) {
                this.subcolor = `rgb(${(((globalnodes[(this.shead)].r*3) + this.subr)/4)},${(((globalnodes[(this.shead)].g*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].b*3)+ this.subb)/4})`
                if (keysPressed['v']) {
                    this.subcolor = `rgb(${(((globalnodes[(this.shead)].p*3) + this.subr)/4)},${(((globalnodes[(this.shead)].z*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].q*3)+ this.subb)/4})`
                }
                if (keysPressed['w']) {
                    this.subcolor = `rgb(${(((globalnodes[(this.shead)].m*3) + this.subr)/4)},${(((globalnodes[(this.shead)].p*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].z*3)+ this.subb)/4})`
                }
    
    
                if (keysPressed['z']) {
                    this.subcolor = `rgb(${(((globalnodes[(this.shead)].z*3) + this.subr)/4)},${(((globalnodes[(this.shead)].r*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].m*3)+ this.subb)/4})`
                }
                if (keysPressed['2']) {
                    this.subcolor = `rgb(${(((globalnodes[(this.shead)].g*3) + this.subr)/4)},${(((globalnodes[(this.shead)].b*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].q*3)+ this.subb)/4})`
                }
    
    
                if (viewStyle == 7) {
                    this.subcolor = `rgb(${(((globalnodes[(this.shead)][viewrota[rota%viewrota.length]]*3) + this.subr)/4)},${(((globalnodes[(this.shead)][viewrota[(rota+1)%viewrota.length]]*3) + this.subg)/4)},${ ((globalnodes[(this.shead)][viewrota[(rota+2)%viewrota.length]]*3)+ this.subb)/4})`
    
                }
                this.body.parent = this
                this.parent = this
            }
    
    
    
    
            // if(tempon == 1){
            //     if(this.anchor != 1){
            //         this.x+=((seedRandom()-.5)/temperatureInvert)*temperature
            //         this.y+=((seedRandom()-.5)/temperatureInvert)*temperature
            //     }else{
    
            //         this.x+=(((seedRandom()-.5)/temperatureInvert)*temperature)/100
            //         this.y+=(((seedRandom()-.5)/temperatureInvert)*temperature)/100
            //     }
            // }
    
            //temperature proxy
            // if(this.age > maxage*.1){
            //     this.x+=(seedRandom()-.5)/100
            //     this.y+=(seedRandom()-.5)/100
            //     if(this.age > maxage*.5){
            //         this.x+=(seedRandom()-.5)/50
            //         this.y+=(seedRandom()-.5)/50
            //         if(this.age > maxage*.9){
            //             this.x+=(seedRandom()-.5)*.04
            //             this.y+=(seedRandom()-.5)*.04
            //         }
            //     }
            // }
    
            if (edgeLoop != 1) {
    
                this.x = Math.max(0, this.x)
                this.x = Math.min(canvas.width / zoom, this.x)
                this.y = Math.max(0, this.y)
                this.y = Math.min(canvas.height / zoom, this.y)
    
            }
            // if(this.x > canvas.width*.5){
            //     this.x = 0
            // }
            // if(this.x < 0){
            //     this.x =  canvas.width*.5
            // }
            // if(this.y > canvas.width*.5){
            //     this.y = 0
            // }
            // if(this.y < 0){
            //     this.y =  canvas.width*.5
            // }
    
        }
        drawBody(context = canvas_context) {
            if (this.anchor == 1) {
                if (this.energy >= anchorcost) {
    
                    if(anchorcost < 0){
                        this.energy -= anchorcost * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= anchorcost * 1
                    }
                }
                this.nodeEnergyCost += anchorcost
    
            }
            if (this.energy >= baseCostOfNode) {
                if (this.inert != 1) {
                    this.energy -= baseCostOfNode
                    
                    if(baseCostOfNode < 0){
                        this.energy -= baseCostOfNode * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= baseCostOfNode * 1
                    }
                }
            }
            if (this.fertile == 1) {
                if (this.energy >= fertilitycost) {
    
                    if(fertilitycost < 0){
                        this.energy -= fertilitycost * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= fertilitycost * 1
                    }
                    this.energy *= fertilityratio
                }
            }
            if (this.fertile == 1) {
                this.nodeEnergyCost += fertilitycost
            }
    
            if (this.inert != 1) {
                this.nodeEnergyCost += baseCostOfNode
            }
            if (this.mouth == 1) {
                if (this.energy >= mouthCost) {
                    if(mouthCost < 0){
                        this.energy -= mouthCost * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= mouthCost * 1
                    }
                }
    
                this.nodeEnergyCost += mouthCost
            }
            if (this.suck == 1) {
                if (this.energy >= suckCost) {
                    if(suckCost < 0){
                        this.energy -= suckCost * 1 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= suckCost * 1
                    }
                }
    
                this.nodeEnergyCost += suckCost
            }
            if (this.energy < 0) {
                this.energy = 0
            }
    
            if (this.dead == 1) {
    
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
    
            if (magnetonly == 1) {
    
            } else {
                this.body.draw(context)
            }
            bodc++
        }
        time() {
            if (this.dead == 1) {
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
    
            this.caught = 0
            for (let t = 0; t < this.times.length; t++) {
                if (this.energy >= baseCostOfNode) {
                    this.ticks[t] += this.subticks[t]
                }
            }
            for (let t = 0; t < this.times.length; t++) {
                if (this.energy >= baseCostOfNode) {
                    this.times[t] += Math.cos(this.ticks[t]) * this.subrots[t]
                }
            }
            for (let t = 0; t < this.pistontimes.length; t++) {
                if (this.energy >= baseCostOfNode) {
                    this.pistontimes[t] += this.pistonticks[t]
                }
            }
        }
    
    
        push() {
            // this.pushoutsto = this.pushout
        }
    
    
        indexkill(index) {
            if (this.id < index) {} else if (this.id == index) {} else {
                this.id--
            }
            if (this.relative < index) {} else if (this.relative == index) {} else {
                this.relative--
            }
            if (this.shead < index) {} else if (this.shead == index) {} else {
                this.shead--
            }
            for (let t = 0; t < this.neighbors.length; t++) {
                if (this.neighbors[t] < index) {} else if (this.neighbors[t] == index) {
                    //////////////////////////////console.log("h")
                    // this.neighbors.splice(t,1)
                    //////////////////console.log(this)
                    this.dead = 1
                } else {
                    this.neighbors[t]--
                }
            }
            for (let t = 0; t < this.link.list.length; t++) {
                // ////////////////////////////////console.log(this.link.list[t], index)
                if (this.link.list[t] < index) {} else if (this.link.list[t] == index) {
                    //////////////////////////////console.log("i")
                    // this.link.list.splice(t,1)
                } else {
                    this.link.list[t]--
                }
            }
            // ////////////////////////////console.log(this.neighbors)
            this.stupidneighbors = []
            for (let t = 0; t < this.neighbors.length; t++) {
                this.stupidneighbors[this.neighbors[t]] = 1
            }
    
    
            for (let t = 0; t < this.immune.length; t++) {
                // ////////////////////////////////console.log(this.link.list[t], index)
                if (this.immune[t] < index) {} else if (this.immune[t] == index) {
                    //////////////////////////////console.log("r")
                    // this.immune.splice(t,1)
                } else {
                    this.immune[t]--
                }
            }
    
    
            this.stupidimmune = []
            for (let t = 0; t < this.immune.length; t++) {
                this.stupidimmune[this.immune[t]] = 1
            }
    
    
        }
    
        makeRotation() {
            if (this.dead == 1) {
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
            let z = 0
            // // this.link.list = []
            // if(this.linkup.length == 2){
            //     //////////////////console.log(this)
            // }
    
    
            if (this.rotor != 1) {
                return
            }
    
            // if(this.piston == 1){
            //     if(this.energy >= pistoncost){
            //         this.energy-=pistoncost
    
            //         this.pistontime+=this.pistonstep
    
            //         this.pistonpush += (Math.sin(this.pistontime)/1)
            //         this.pistonpush = Math.min(this.pistonpush, 12)
            //         this.pistonpush = Math.max(this.pistonpush, -12)
    
            //     }
            // }
    
    
            for (let t = 0; t < this.neighbors.length; t++) {
                // //////////////////////////////console.log()
                if (this.dead == 1) {
                    break
                }
                let nd = globalnodes[this.neighbors[t]]
                if (!nd) {
                    ////////////////////////////console.log(globalnodes, this.neighbors[t])
                    continue
                }
                if (nd.dead == 1) {
                    continue
                }
                // if (this.stupidneighbors[t] == 1) {
    
                this.link.target = nd
                let j = 0
                let lf = (((this.lout + this.pistonpushes[z]) + (nd.lout + nd.pistonpushes[z])) / 2)
                // let mes = this.link.hypotenuse()
                // let a = this.link.angle()
    
    
                if (this.rotor == 1) {
                    this.lt.x = this.x + (Math.cos(((this.times[z]))) * lf)
                    this.lt.y = this.y + (Math.sin(this.times[z]) * lf)
                    if (this.energy >= rotationCost) {
                        this.energy -= rotationCost
                        if (this.link.target.anchor != 1) {
                            this.link.target.x = (this.link.target.x * (1 - this.rigs[z])) + (this.rigs[z] * this.lt.x)
                            this.link.target.y = (this.link.target.y * (1 - this.rigs[z])) + (this.rigs[z] * this.lt.y)
                        } else {
    
                            this.link.target.x = (this.link.target.x * (1 - (this.rigs[z] / 100))) + ((this.rigs[z] / 100) * this.lt.x)
                            this.link.target.y = (this.link.target.y * (1 - (this.rigs[z] / 100))) + ((this.rigs[z] / 100) * this.lt.y)
    
                        }
                        // if (this.type == 1 || this.type == 3) { 
                        nd.pushout = nd.pushoutsto + this.times[z] 
                        // this.pushout = this.pushoutsto - this.times[z]
                        // }
                    } else { 
    
                    }
    
    
                    this.nodeEnergyCost += rotationCost
                }
                // globalnodes[t].link.list.push(globalnodes.indexOf(this))
                // }
    
    
                z++
                z %= this.las.length
    
            }
    
    
    
        }
        makePiston() {
            if (this.dead == 1) {
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
            let z = 0
    
            if (this.piston != 1) {
    
                for (let t = 0; t < timesLength; t++) {
                    this.pistonpushes[t] = 0
                }
                return
            }
    
    
            for (let t = 0; t < this.neighbors.length; t++) {
                // //////////////////////////////console.log()
                if (this.dead == 1) {
                    break
                }
                let nd = globalnodes[this.neighbors[t]]
                if (!nd) {
                    continue
                }
                if (nd.dead == 1) {
                    continue
                }
    
                this.link.target = nd
    
    
                if (this.piston == 1) {
                    if (this.energy >= pistoncost) {
                        this.energy -= pistoncost
                        this.pistonpushes[z] += (Math.sin(this.pistontimes[z] + this.pistonstarts[z]) / 1)
                        this.pistonpushes[z] = Math.min(this.pistonpushes[z], ((loutmin * worldscaler) * 3))
                        this.pistonpushes[z] = Math.max(this.pistonpushes[z], -((loutmin * worldscaler) / 2))
                    }
                    this.nodeEnergyCost += pistoncost
                }
    
    
    
    
                z++
                z %= this.las.length
    
    
                this.link.mark = 1
                this.link.list.push(this.neighbors[t])
                nd.link.mark = 1
                nd.link.list.push(globalnodes.indexOf(this))
    
    
                this.xleap = (Math.abs(this.xleap) > Math.abs(nd.xleap) ? this.xleap : nd.xleap)
                this.yleap = (Math.abs(this.yleap) > Math.abs(nd.yleap) ? this.xleap : nd.yleap)
            }
    
    
    
        }
        makeLink() {
            if (this.dead == 1) {
                if (this.firsty != 1) {
                    for (let t = 0; t < this.neighbors.length; t++) {
                        this.disconnect(globalnodes[this.neighbors[t]])
                    }
                }
                return
            }
            let z = 0
            this.link.list = []
            if (this.linkup.length == 2) {
                //////////////////console.log(this)
            }
    
    
            // if(this.piston == 1){
            //     if(this.energy >= pistoncost){
            //         this.energy-=pistoncost
    
            //         this.pistontime+=this.pistonstep
    
            //         this.pistonpush += (Math.sin(this.pistontime)/1)
            //         this.pistonpush = Math.min(this.pistonpush, 12)
            //         this.pistonpush = Math.max(this.pistonpush, -12)
    
            //     }
            // }
    
    
            for (let t = 0; t < this.neighbors.length; t++) {
                // //////////////////////////////console.log()
                if (this.dead == 1) {
                    break
                }
                let nd = globalnodes[this.neighbors[t]]
                if (!nd) {
                    ////////////////////////////console.log(globalnodes, this.neighbors[t])
                    continue
                }
                if (nd.dead == 1) {
                    continue
                }
                // if (this.stupidneighbors[t] == 1) {
    
                this.link.target = nd
                let j = 0
                let lf = (((this.lout + this.pistonpushes[z]) + (nd.lout + nd.pistonpushes[z])) / 2)
                let mes = this.link.hypotenuse()
                let a = this.link.angle()
                let cosa = Math.cos(a)
                let sina = Math.sin(a)
                // while (mes > lf) {
                //     j++
                //     if(j>20){
                //         break
                //     }
                //     let outs = 0
                //     if(this.anchor != 1){
                //         this.x -=cosa * 1.2
                //         this.y -=sina * 1.2
                //         outs+=1.2
                //     }else{
                //         if(this.link.target.anchor != 1){
                //     this.x -=cosa * .012
                //     this.y -=sina * .012
                //     outs+=.012
                //         }else{
                //             this.x -=cosa * .06
                //             this.y -=sina * .06
                //             outs+=.06
                //         }
                //     }
                //     if(this.link.target.anchor != 1){
                //     this.link.target.x +=cosa * 1.2
                //     this.link.target.y +=sina * 1.2
                //     outs+=1.2
                //     }else{
    
                //         if(this.anchor != 1){
                //     this.link.target.x +=cosa * .012
                //     this.link.target.y +=sina * .012
                //     outs+=.012
                //         }else{
                //             this.link.target.x +=cosa * .06
                //             this.link.target.y +=sina * .06
                //             outs+=.06
    
                //         }
    
                //     }
                //     mes-=outs
                // }
                j = 0
                while (mes > lf) {
                    j++
                    if (j > 10) {
                        break
                    }
    
                    let outs = 0
                    if (this.anchor != 1) {
                        this.x -= cosa * .8 * worldscaler
                        this.y -= sina * .8 * worldscaler
                        outs += .8 * worldscaler
                    } else {
    
                        if (this.link.target.anchor != 1) {
                            this.x -= cosa * .008 * worldscaler
                            this.y -= sina * .008 * worldscaler
                            outs += .008
                        } else {
    
                            this.x -= cosa * .04 * worldscaler
                            this.y -= sina * .04 * worldscaler
                            outs += .04 * worldscaler
    
                        }
                    }
                    if (this.link.target.anchor != 1) {
                        this.link.target.x += cosa * .8 * worldscaler
                        this.link.target.y += sina * .8 * worldscaler
                        outs += .8
                    } else {
                        if (this.anchor != 1) {
                            this.link.target.x += cosa * .008 * worldscaler
                            this.link.target.y += sina * .008 * worldscaler
                            outs += .008 * worldscaler
                        } else {
    
                            this.link.target.x += cosa * .04 * worldscaler
                            this.link.target.y += sina * .04 * worldscaler
                            outs += .04 * worldscaler
    
                        }
    
                    }
                    mes -= outs * .999
                }
    
    
    
    
                j = 0
                while (mes < lf) {
                    j++
                    if (j > 10) {
                        break
                    }
    
                    let outs = 0
                    if (this.anchor != 1) {
                        this.x += cosa * .8 * worldscaler
                        this.y += sina * .8 * worldscaler
                        outs -= .8 * worldscaler
                    } else {
    
                        if (this.link.target.anchor != 1) {
                            this.x += cosa * .008 * worldscaler
                            this.y += sina * .008 * worldscaler
                            outs -= .008 * worldscaler
                        } else {
    
                            this.x += cosa * .04 * worldscaler
                            this.y += sina * .04 * worldscaler
                            outs -= .04 * worldscaler
    
                        }
                    }
                    if (this.link.target.anchor != 1) {
                        this.link.target.x -= cosa * .8 * worldscaler
                        this.link.target.y -= sina * .8 * worldscaler
                        outs -= .8 * worldscaler
                    } else {
                        if (this.anchor != 1) {
                            this.link.target.x -= cosa * .008 * worldscaler
                            this.link.target.y -= sina * .008 * worldscaler
                            outs -= .008 * worldscaler
                        } else {
    
                            this.link.target.x -= cosa * .04 * worldscaler
                            this.link.target.y -= sina * .04 * worldscaler
                            outs -= .04 * worldscaler
    
                        }
    
                    }
                    mes -= outs * .998
                }
    
    
    
                // this.lt.x = this.x + (Math.cos(((this.times[z]))) * this.lout)
                // this.lt.y =  this.y + (Math.sin(this.times[z]) * this.lout)
    
    
                // // let easedp = new Point((this.link.target.x*(1-this.rigs[z])) + (lt.x*this.rigs[z]),    (this.link.target.y*(1-this.rigs[z])) + (lt.y*this.rigs[z]))
    
                // //
    
    
    
                // if (this.rotor == 1) {
                //         if (this.energy >= rotationCost) {
                //             this.energy-=rotationCost
                //             if(this.link.target.anchor != 1){
                //                 this.link.target.x = (this.link.target.x * (1 - this.rigs[z])) + (this.rigs[z] * this.lt.x)
                //                 this.link.target.y = (this.link.target.y * (1 - this.rigs[z])) + (this.rigs[z] * this.lt.y)
                //             }else{
    
                //             this.link.target.x = (this.link.target.x * (1 - (this.rigs[z]/10))) + ((this.rigs[z]/10) * this.lt.x)
                //             this.link.target.y = (this.link.target.y * (1 - (this.rigs[z]/10))) + ((this.rigs[z]/10) * this.lt.y)
    
                //             }
                //             // if (this.type == 1 || this.type == 3) { 
                //                     nd.pushout = nd.pushoutsto + this.times[z]
                //                     // this.pushout = this.pushoutsto - this.times[z]
                //             // }
                //         } else {
    
                //         }
    
                // }
    
    
                z++
                z %= this.las.length
    
                if (this.energy >= linkcost) {
                    if(linkcost < 0){
                        this.energy -= linkcost * .5 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= linkcost * .5
                    }
                }
                if (this.energy >= linkcostdistance * this.lout) {
                    if(linkcostdistance < 0){
                        this.energy -= linkcostdistance * .5 * ((seedRandom()*2)*(freec / freen)) 
                    }else{
                        this.energy -= linkcostdistance * .5
                    }
                }
    
                this.nodeEnergyCost += linkcost / 2
                this.nodeEnergyCost += linkcostdistance * this.lout /2
                this.energy = Math.max(this.energy, 0)
    
    
                this.link.mark = 1
                this.link.list.push(this.neighbors[t])
                nd.link.mark = 1
                nd.link.list.push(globalnodes.indexOf(this))
    
    
                this.xleap = (Math.abs(this.xleap) > Math.abs(nd.xleap) ? this.xleap : nd.xleap)
                this.yleap = (Math.abs(this.yleap) > Math.abs(nd.yleap) ? this.xleap : nd.yleap)
    
                // globalnodes[t].link.list.push(globalnodes.indexOf(this))
                // }
            }
    
    
    
        }
        dying() {
    
            if (deadwash < 3 || deadwash > deadmax - 3) {
                return
            }
            if (this.trueage > 2) {
                if (this.neighbors.length <= 1) {
                    this.head = 1
                }
            }
    
            if (this.die == 1) {
                //////////////////////console.log(this.neighbors, this)
                if (this.trueage > 5) {
                    this.head = 1
                    this.dead = 1
                }
            }
    
            if (this.cut == 1) {
                this.die = 1
            }
    
    
            if (this.mouth == 1) {
                if (this.link.list.length == 0 && this.immune.length <= 2 && this.trueage > 5) {
                    this.dead = 1
                }
    
                let alldead = 0
                for (let t = 0; t < globalnodes.length; t++) {
                    if (globalnodes[t].dead == 1) {
                        alldead++
                    }
                }
    
                if (this.balanced == 1) {
    
                    if ((this.age > Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)) || (this.immune.length <= 2)) {
                        //////////////////////////////console.log(((this.ll)*(this.ll))*Math.max(((maxage - minage) - (globalnodes.length - alldead)),timemin), this.ll)
                        if (this.immune.length <= 2 || this.age > (((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)) {
                            this.dead = 1
                            if (totalKill == 1) {
                                if (totalKill == 1) {
                                    for (let d = 0; d < this.immune.length; d++) {
                                        globalnodes[this.immune[d]].dead = 1
                                    }
                                }
                            }
                        }
                    }
    
                }
    
    
            } else {
    
    
                if (this.link.list.length == 0 && this.immune.length <= 2 && this.trueage > 5) {
                    this.dead = 1
                }
                let alldead = 0
                for (let t = 0; t < globalnodes.length; t++) {
                    if (globalnodes[t].dead == 1) {
                        alldead++
                    }
                }
    
                if (this.balanced == 1) {
    
                    if ((this.age > Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)) || (this.immune.length <= 2)) {
                        //////////////////////////////console.log(((this.ll)*(this.ll))*Math.max(((maxage - minage) - (globalnodes.length - alldead)),timemin), this.ll)
                        if (this.immune.length <= 2 || this.age > (((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)) {
                            this.dead = 1
                            if (totalKill == 1) {
                                if (totalKill == 1) {
                                    for (let d = 0; d < this.immune.length; d++) {
                                        globalnodes[this.immune[d]].dead = 1
                                    }
                                }
                            }
                        }
                    }
    
                }
            }
    
        }
        text() {
    
            if (this.dead == 1) {
                return
            }
    
            if (!keysPressed['h'] && !keysPressed['e'] && !keysPressed['r'] && !keysPressed['c'] && !keysPressed['b'] && !keysPressed['l']) {
    
                return
            } else if (keysPressed['l']) {
    
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = `${worldscale*1.4}px arial`
    
                // this.energy = Math.round(this.energy*100)/100
    
                if (this.head == 1) {
                    canvas_context.strokeText(Math.round(this.energyOrgCost * 10000), this.xavg - 5, this.yavg + 2)
                    canvas_context.fillText(Math.round(this.energyOrgCost * 10000), this.xavg - 5, this.yavg + 2)
                }
    
    
            } else if (keysPressed['b']) {
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = `${worldscale*1.5}px arial`
    
                // this.energy = Math.round(this.energy*100)/100
    
                let c = 0
                for (let t = 0; t < this.genebucket.length; t++) {
                    c += (this.genebucket[t].split('')).length
                }
    
    
                if (this.head == 1) {
                    canvas_context.strokeText(c, this.xavg - 5, this.yavg + 2)
                    canvas_context.fillText(c, this.xavg - 5, this.yavg + 2)
                }
    
            } else if (keysPressed['c'] && keysPressed['h']) {
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = `${worldscale*1.4}px arial`
    
                // this.energy = Math.round(this.energy*100)/100
    
    
                if (this.head == 1) {
                    canvas_context.strokeText(this.genestring, this.xavg, this.yavg)
                    canvas_context.fillText(this.genestring, this.xavg, this.yavg)
                }
    
            } else if (keysPressed['c']) {
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = `${worldscale*1.4}px arial`
    
                // this.energy = Math.round(this.energy*100)/100
    
    
                canvas_context.strokeText(this.genestring, this.x, this.y)
                canvas_context.fillText(this.genestring, this.x, this.y)
    
            } else if (keysPressed['h']) {
    
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = `${worldscale*1.4}px arial`
    
                // this.energy = Math.round(this.energy*100)/100
    
                if (this.head == 1) {
    
                    canvas_context.strokeText(Math.round((this.energy / ((repconstant * ((((this.w))))))) * 100) + "%", this.xavg, this.yavg)
                    canvas_context.fillText(Math.round((this.energy / ((repconstant * ((((this.w))))))) * 100) + "%", this.xavg, this.yavg)
                }
            } else if (keysPressed['e']) {
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = `${worldscale*1.4}px arial`
    
                let alldead = 0
                for (let t = 0; t < globalnodes.length; t++) {
                    if (globalnodes[t].dead == 1) {
                        alldead++
                    }
                }
                if (this.head == 1) {
                    let age = Math.round(this.age * 100) / 100
                    canvas_context.strokeText(Math.round(100 * (age / ((((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)))) + "%", this.xavg, this.yavg)
                    canvas_context.fillText(Math.round(100 * (age / ((((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)))) + "%", this.xavg, this.yavg)
                    ////////console.log( ((((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)), timemin)))
                }
            } else if (keysPressed['r']) {
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = "11px arial"
    
                // this.age = Math.round(this.age*100)/100
    
                if (this.head == 1) {
                    canvas_context.strokeText(this.ll, this.xavg, this.yavg)
                    canvas_context.fillText(this.ll, this.xavg, this.yavg)
                }
            }
        }
    }
    
    let globalnodes = []
    
    
    let nodein = []
    
    // for(let t = 0;t<2;t++){
    //     let node = new Node(seedRandom()*canvas.width,seedRandom()*canvas.height, nodein[t])
    //     if(seedRandom() <1){
    //         node.connect(globalnodes[Math.floor(seedRandom()*globalnodes.length)])
    //     }
    //   }
    // //   for(let t = 0;t<50;t++){
    // //       let node = new Node(360+ (seedRandom()*80),360+ (seedRandom()*80), Math.floor(seedRandom()*6))
    // //       if(seedRandom() <.8){
    // //           node.connect(globalnodes[Math.floor(seedRandom()*globalnodes.length)])
    // //       }
    // //     }
    // //   for(let t = 0;t<2;t++){
    // //     let node = new Node(seedRandom()*canvas.width,seedRandom()*canvas.height, 4)
    // //     if(seedRandom() <.2){
    // //         node.connect(globalnodes[Math.floor(seedRandom()*globalnodes.length)])
    // //     }
    // //   }
    
    //   for(let t = 0;t<10;t++){
    //     globalnodes[Math.floor(seedRandom()*globalnodes.length)].connect(globalnodes[Math.floor(seedRandom()*globalnodes.length)])
    //   }
    
    
    
    function init(nodein) {
    
    
        smellMax = 1
        if (makeall == 1) {
    
            runcount = 1
        } else {
    
            for (let t = 0; t < nodein.length; t++) {
    
                let genes = ""
                if (nodein[t] == 22) {
                    // let jump = Math.floor(seedRandom()*geneChars.length)
                    let vals = getUniqueValues(genelength)
                    for (let r = 0; r < vals.length; r++) {
                        genes += geneChars[vals[r]] //(nodein[t]+r+jump)%(geneChars.length)
                    }
                } else {
    
                    // let jump = Math.floor(seedRandom()*geneChars.length) 
                    if (genelength > 1) {
    
                        for (let r = 0; r < 2; r++) {
                            genes += geneChars[nodein[t]]
                        }
                    } else {
    
                        for (let r = 0; r < 1; r++) {
                            genes += geneChars[nodein[t]]
                        }
    
                    }
                    // for(let r = 0;r<genelength-2;r++){
                    //     genes+=geneChars[(nodein[t]+r+jump)%(geneChars.length)]
                    // }
                    if (genelength > 2) {
    
                        let vals = getUniqueValues(Math.max(genelength - 2, 1))
                        for (let r = 0; r < vals.length; r++) {
                            genes += geneChars[vals[r]] //(nodein[t]+r+jump)%(geneChars.length)
                        }
                    }
                }
    
    
                let node = new Node(canvas.width / (zoom * 2), (canvas.height / (zoom * 2)), nodein[t], genes)
                if (t == 0) {
                    node.head = 1
                }
                if (seedRandom() < 1) {
                    node.connect(globalnodes[Math.floor(seedRandom() * globalnodes.length)])
                }
            }
            for (let t = 0; t < nodein.length; t++) {
                let f = Math.floor(seedRandom() * globalnodes.length)
                let g = Math.floor(seedRandom() * globalnodes.length)
                if (f != g) {
                    if (globalnodes[f].neighbors.length < 3 && globalnodes[g].neighbors.length < 3) {
    
                        globalnodes[f].connect(globalnodes[g])
                    }
    
                } else {
                    t--
                }
            }
        }
    
    
    
    
        if (makeall == 1) {
    
            for (let t = 0; t < nodetypes; t++) {
                for (let k = t; k < nodetypes; k++) {
    
    
    
                    let genest = ""
                    for (let r = 0; r < genelength; r++) {
                        if (geneChars[t]) {
    
                            genest += geneChars[t]
                        } else {
    
                            genest += geneChars[r]
                        }
                    }
    
                    let genesk = ""
                    for (let r = 0; r < genelength; r++) {
                        if (geneChars[k]) {
    
                            genesk += geneChars[k]
                        } else {
    
                            genesk += geneChars[r]
                        }
                    }
    
    
    
                    // let node = new Node(30 + (30 * (k)), 30 + (30 * t), k, genesk)
                    // let nud = new Node(30 + (30 * (k)), 30 + (30 * t), t, genest)
    
                    let node = new Node(40 + (40 * (k)), 40 + (40 * t), k, genesk)
                    let nud = new Node(40 + (40 * (k)), 40 + (40 * t), t, genest)

                    node.head = 1
                    nud.connect(node)
                }
            }
    
    
    
        } else if (makegreen == 1) {
    
            for (let t = 0; t < 15; t++) {
                if (greens.includes(t)) {
    
                    let genest = ""
                    for (let r = 0; r < genelength; r++) {
                        genest += geneChars[t]
                    }
    
                    let genes4 = ""
                    for (let r = 0; r < genelength; r++) {
                        genes4 += geneChars[4]
                    }
    
                    let node = new Node(100 + (100 * (t % 4)), 100 + (100 * Math.floor(t / 4)), 4, genes4)
                    let nud = new Node(100 + (100 * (t % 4)), 100 + (100 * Math.floor(t / 4)), t, genest)
    
                    node.head = 1
                    nud.connect(node)
                }
    
            }
    
        }
    
    
        if (ringon == 1) {
    
            let ringsize = 40
            let a = (Math.PI / ringsize) * 2
            let cosa = Math.cos(a)
            let sina = Math.sin(a)
    
            for (let t = 0; t < ringsize; t++) {
    
    
                let genest = ""
                for (let r = 0; r < genelength; r++) {
                    genest += geneChars[t]
                }
    
                let genes4 = ""
                for (let r = 0; r < genelength; r++) {
                    genes4 += geneChars[6]
                }
    
    
                let node = new Node((canvas.width / (zoom * 2)) + (Math.cos(a * t) * ringsize * 2*worldscaler), (canvas.height / (zoom * 2)) + (Math.sin(a * t) * ringsize * 2*worldscaler), 6, genes4)
                if (makeline == 1) {
    
                    // node.type = 5
                    node.charge = -1
                    node.magratio = seedRandom() * 2.5
                }
    
    
                if (t == 0) {
                    node.head = 1
                }
                if (t > 0) {
                    globalnodes[t - 1 + nodein.length].connect(node)
                }
            }
            if (makeline == 1) {
    
            } else {
    
                globalnodes[0 + nodein.length].connect(globalnodes[globalnodes.length - 1])
            }
    
            for (let t = 0; t < ringsize; t++) {
                let genes4 = ""
                for (let r = 0; r < genelength; r++) {
                    genes4 += geneChars[5]
                }
    
                let node = new Node((canvas.width / (zoom * 2)) + (Math.cos(a * t) * ringsize * 2.2*worldscaler), (canvas.height / (zoom * 2)) + (Math.sin(a * t) * ringsize * 2.2*worldscaler), 5, genes4)
    
                if (makeline == 1) {
    
                    node.charge = 1
                    node.magratio = seedRandom() * 2.5
                }
                globalnodes[(t * 1) + nodein.length].connect(node)
                if (t > 0) {
                    globalnodes[t - 1 + nodein.length].connect(node)
                }
    
                if (t > 0) {
                    globalnodes[t - 1 + nodein.length + ringsize].connect(node)
                }
    
    
            }
            if (makeline == 1) {
    
            } else {
    
                globalnodes[nodein.length + ringsize].connect(globalnodes[globalnodes.length - 1])
                globalnodes[nodein.length + ringsize].connect(globalnodes[globalnodes.length - (ringsize + 1)])
            }
    
    
        }
    
    }
    //   let nodem = new Node(360,360, 5)
    //   nodem.connect(globalnodes[Math.floor(seedRandom()*globalnodes.length)])
    // //   nodem.connect(globalnodes[Math.floor(seedRandom()*globalnodes.length)])
    
    
    //   for(let t = 0;t<globalnodes.length;t++){
    
    //     if(globalnodes[t].neighbors.length == 0){
    //         // globalnodes.splice(t,1)
    //         // t--
    //         // globalnodes[t].dead = 1
    
    //     }
    //   }
    
    // let nod1 = new Node(100, 100, 0)
    // let nod2 = new Node(110, 100, 0)
    // let nod3 = new Node(130, 100, 0)
    // let nod4 = new Node(140, 100, 1)
    // let nod5 = new Node(140, 100, 2)
    // let nod6 = new Node(160, 100, 0)
    // let leaf1 = new Node(110, 110, 4)
    // let leaf2 = new Node(110, 90, 4)
    // let leaf3 = new Node(120, 110, 4)
    // let leaf4 = new Node(120, 90, 4)
    // let leaf5 = new Node(120, 90, 4)
    
    // let push1 = new Node(90, 100, 2)
    // let push2 = new Node(690, 100, 2)
    // let push3 = new Node(90, 100, 2)
    // let push4 = new Node(90, 100, 2)
    // let pivot1 = new Node(120, 100, 0)
    // let pivot3 = new Node(420, 400, 1)
    // let pivot2 = new Node(120, 100, 1)
    // let pivot3 = new Node(120, 100, 1)
    // let pivot4 = new Node(120, 100, 1)
    
    
    // globalnodes.push(nod1, nod2, nod3, leaf1, leaf2, push1, pivot1)
    
    
    // for(let t = 0;t<globalnodes.length;t++){
    
    //     if(globalnodes[t].neighbors.length == 0){
    //         // globalnodes[t].dead = 1
    //     }
    //   }
    
    
    canvas_context.imageSmoothingEnabled = true
    
    
    let instructions = []
    
    instructions.push("Structural node: No cost, no special value, just structure.")
    instructions.push("Rotation node: Low cost, rotational value. Turns other components. Cant be eaten.")
    instructions.push("Head node: Medium cost, propulsion value, armor value. Pulls other components and cannot be eaten.")
    instructions.push("Rotational head node: High cost, propulsion value, rotation value. Pulls other components and rotates other components.")
    instructions.push("Production node: High energy production. Energy is needed for replication of any components.")
    instructions.push("Tooth node:  Medium cost, eats other components. Gain energy as a predator, cannot be eaten.")
    instructions.push("Armored Longevity node: High cost, blocks other components. cannot be eaten, increases lifespan.")
    instructions.push("Production motor node: Moderate energy production,  Pulls components.")
    instructions.push("Production rotor node: Moderate energy production,  Rotates components.")
    instructions.push("Production anchor node: Produces energy, Holds fast.")
    instructions.push("Armored anchor node: Medium cost, Holds fast. cannot be eaten.")
    instructions.push("Generator Piston node: Generate energy, Pushes components.")
    instructions.push("Armored piston node: Medium cost, Pushes components. Can't be eaten.")
    instructions.push("Reproduction node: Inverse cost, reduces time to reproduce (female).")
    instructions.push("Longevity node: Produces some energy, increases lifespan.")
    instructions.push("Static gill node: Converts kinetic motion into energy.")
    instructions.push("Sapping node: Low cost. Steals energy from contacted nodes.")
    instructions.push("Rotor Nose node: Consumes some energy, rotates components with scent, cannot be eaten.")
    instructions.push("Motor Nose node: Consumes some energy, moves components with scent.")
    instructions.push("Reproduction node: Inverse cost, reduces time to reproduce (male).")
    instructions.push("Pushing Armor node: Cant be eaten, pushes other components.")
    instructions.push("Ear gill node: Converts some kinetic motion into energy, navigates based on sound.")
    instructions.push("Disease node: Consumes some energy, decreases lifespan.")
    
    
    
    
    class Toggle {
        constructor(x, y, initial, onChange) {
            this.x = x - 160
            this.y = y;
            this.width = 40;
            this.height = 20;
            this.state = initial; // true or false
            this.onChange = onChange;
        }
    
        draw(label) {
            // Label
            canvas_context.fillStyle = '#FFF';
            canvas_context.font = '14px Arial';
            canvas_context.fillText(label, this.x - 0, this.y - 5);
    
            // Background
            canvas_context.fillStyle = this.state == 1 ? '#0f0' : '#800';
            canvas_context.fillRect(this.x, this.y, this.width, this.height);
    
            // Thumb
            const thumbX = this.x + (this.state == 1 ? this.width - this.height : 0);
            canvas_context.fillStyle = '#FFF';
            canvas_context.beginPath();
            canvas_context.arc(thumbX + this.height / 2, this.y + this.height / 2, this.height / 2, 0, Math.PI * 2);
            canvas_context.fill();
        }
    
        isPointInside(point) {
            return (
                point.x >= this.x &&
                point.x <= this.x + this.width &&
                point.y >= this.y &&
                point.y <= this.y + this.height
            );
        }
    
        handlePointer(point) {}
        handlePoint(point) {
            if (this.isPointInside(point)) {
                this.state *= -1;
                if (this.onChange) {
                    this.onChange(this.state);
                }
            }
        }
    }
    
    
    
    
    class Slider {
        constructor(x, y, width, min, max, initial, onChange) {
            this.x = x - 465;
            if (x == 760) {
                this.x -= 24
            }
            this.y = (y * .83) - 15;
            this.width = width * .75;
            this.min = min;
            this.max = max;
            this.value = initial;
            this.onChange = onChange; // Callback when value changes
        }
    
        draw(label) {
            // Draw label
            canvas_context.fillStyle = '#FFF';
            canvas_context.font = '12px Arial';
            canvas_context.fillText(label, this.x, this.y - 6);
    
            // Draw track
            canvas_context.fillStyle = '#af0';
            canvas_context.fillRect(this.x, this.y, this.width, 10);
    
            // Draw thumb
            const ratio = (this.value - this.min) / (this.max - this.min);
            const thumbX = this.x + ratio * this.width - 5;
            canvas_context.fillStyle = '#f00';
            canvas_context.fillRect(thumbX + 5, this.y - 5, 2, 20);
    
            // Draw value readout
            canvas_context.fillStyle = '#FFF';
            canvas_context.font = '14px Arial';
            if (Math.abs(this.value) >= .01) {
                canvas_context.fillText(this.value.toFixed(2), this.x + this.width + 10, this.y + 9);
            } else {
                if (Math.abs(this.value) >= .001) {
                    canvas_context.fillText(this.value.toFixed(3), this.x + this.width + 10, this.y + 9);
                } else {
                    canvas_context.fillText(this.value.toFixed(4), this.x + this.width + 10, this.y + 9);
                }
            }
        }
    
        isPointInside(point) {
            return (
                point.x >= this.x &&
                point.x <= this.x + this.width &&
                point.y >= this.y - 10 &&
                point.y <= this.y + 20
            );
        }
    
        handlePointer(point) {
            if (this.isPointInside(point)) {
                const relativeX = point.x - this.x;
                const ratio = Math.min(1, Math.max(0, relativeX / this.width));
                const newValue = this.min + ratio * (this.max - this.min);
                this.value = newValue;
                if (this.onChange) {
                    this.onChange(this.value);
                }
            }
        }
    
        handlePoint(point) {
            if (this.isPointInside(point)) {
                const relativeX = point.x - this.x;
                const ratio = Math.min(1, Math.max(0, relativeX / this.width));
                const newValue = this.min + ratio * (this.max - this.min);
                this.value = newValue;
                if (this.onChange) {
                    this.onChange(this.value);
                }
            }
        }
    }
    
    class HotSlider {
        constructor(x, y, width, min, max, initial, onChange) {
            this.x = x - 280;
            this.y = y;
            this.width = width;
            this.min = min;
            this.max = max;
            this.value = initial;
            this.onChange = onChange; // Callback when value changes
        }
    
        draw(label) {
            // Draw label
            canvas_context.fillStyle = '#FFF';
            canvas_context.font = '14px Arial';
            canvas_context.fillText(label, this.x, this.y - 6);
    
            // Draw track
            canvas_context.fillStyle = '#FF0';
            canvas_context.fillRect(this.x, this.y, this.width, 20);
    
            // Draw thumb
            const ratio = (this.value - this.min) / (this.max - this.min);
            const thumbX = this.x + ratio * this.width - 5;
            canvas_context.fillStyle = '#f00';
            canvas_context.fillRect(thumbX + 5, this.y - 5, 4, 30);
    
            // Draw value readout
            canvas_context.fillStyle = '#FFF';
            canvas_context.font = '14px Arial';
            // if(Math.abs(this.value) >= .01){
            //     canvas_context.fillText(this.value.toFixed(2), this.x + this.width + 10, this.y + 9);
            // }else{
            //     if(Math.abs(this.value) >= .001){
            //     canvas_context.fillText(this.value.toFixed(3), this.x + this.width + 10, this.y + 9);
            //     }else{
            //     canvas_context.fillText(this.value.toFixed(4), this.x + this.width + 10, this.y + 9);
            //     }
            // }
        }
    
        isPointInside(point) {
            return (
                point.x >= this.x &&
                point.x <= this.x + this.width &&
                point.y >= this.y - 10 &&
                point.y <= this.y + 20
            );
        }
    
        handlePointer(point) {
            if (this.isPointInside(point)) {
                const relativeX = point.x - this.x;
                const ratio = Math.min(1, Math.max(0, relativeX / this.width));
                const newValue = this.min + ratio * (this.max - this.min);
                this.value = newValue;
                if (this.onChange) {
                    this.onChange(this.value);
                }
            }
        }
    
        handlePoint(point) {
            if (this.isPointInside(point)) {
                const relativeX = point.x - this.x;
                const ratio = Math.min(1, Math.max(0, relativeX / this.width));
                const newValue = this.min + ratio * (this.max - this.min);
                this.value = newValue;
                if (this.onChange) {
                    this.onChange(this.value);
                }
            }
        }
    }
    
    
    function adjustMovementCost(input) {
        movementCost = input
    }
    
    function adjustEnergyGeneration(input) {
        generationConstant = input
    }
    
    function adjustbaseCostOfNode(input) {
        baseCostOfNode = input
    }
    
    function adjustmouthCost(input) {
        mouthCost = input
    }
    
    function adjustsuckCost(input) {
        suckCost = input
    }
    
    function adjustsmellScaler(input) {
        smellScaler = Math.round(input)
        resizeCanvas()
    }
    
    function adjustdragCost(input) {
        dragcost = input
    }
    
    function adjustanchorCost(input) {
        anchorcost = input
    }
    
    function adjustpistonCost(input) {
        pistoncost = input
    }
    
    function adjustrotationCost(input) {
        rotationCost = input
    }
    
    function adjustmagnetCost(input) {
        magnetcost = input
    }
    
    function adjustgenelengthcost(input) {
        genelengthcost = input
    }
    
    function adjustlinkcostdistance(input) {
        linkcostdistance = input
    }
    
    function adjustlinkcost(input) {
        linkcost = input
    }
    
    
    function adjustlongevitycost(input) {
        longevitycost = input
    }
    
    function adjustfertilitycost(input) {
        fertilitycost = input
    }
    
    function adjustTemperature(input) {
        temperature = input
    }
    
    function adjustmagnetradius(input) {
        magnetradius = input
    }
    
    function adjustspeciesdistance(input) {
        speciesdistance = input
    }
    
    function adjustbreedingdistance(input) {
        breedingdistance = input
    }
    
    function adjustrepconstant(input) {
        repconstant = input
    
    
        freen = repconstant * 5000 //nodecap
    
        freec = freen
    
    
    }
    
    function adjustminage(input) {
        minage = input
    }
    
    function adjustmaxage(input) {
        maxage = input
    }
    
    function adjustloutmin(input) {
        loutmin = input
    }
    
    function adjustcodonconstant(input) {
        codonconstant = input
    }
    
    function adjustgenelength(input) {
        genelength = input
    }
    
    function adjustworldscale(input) {
        worldscale = input
        bucketsize = worldscale*(Math.sqrt(12)/Math.sqrt(worldscale))*2.5
        //////console.log(bucketsize)
        resizeCanvas()
    }
    
    function adjustpredatorIncentive(input) {
        predatorIncentive = input
    }
    
    function adjustdriftconstant(input) {
        driftconstant = input
    }
    
    function adjustdriftdistance(input) {
        diffdist = input
    }
    
    function adjusttimemin(input) {
        timemin = input
    }
    
    function adjustcodonusage(input) {
        codonusage = input
    }
    
    function adjustsmellFlip(input) {
        smellFlip = input
    }
    
    function adjustsoundFlip(input) {
        soundFlip = input
    }
    
    function adjustfreeEnergyOn(input) {
        freeEnergyOn = input
    }
    
    function adjustparticletoggle(input) {
        particletoggle = input
    }
    
    function adjustmutationrate(input) {
        mutationrate = input
    }
    
    function adjustedgeLoop(input) {
      edgeLoop = input
  }
  function adjustaudioping(input) {
    audioPing = input
  }
    

    
    function adjustdumbdoton(input) {
        dumbdoton = input
        resizeCanvas()
    }
    
    function adjustgillconstant(input) {
        gillconstant = input
    }
    
    function adjustsuckratio(input) {
        suckratio = input
    }
    
    function adjustagesuckrat(input) {
        agesuckrat = input
    }
    
    
    class Wordball {
        constructor(word, x, y, target) {
            this.ball = new Circle(x, y, 1, '#000000')
            this.ball.subcolor = "#000000"
            this.ball.type = 0
            this.ball.parent = {}
            this.ball.parent.subcolor = "#000000"
            this.ball.parent.color = "#000000"
            this.word = word
            this.time = 50
            this.target = target
            this.link = new LineOPR(this.ball, this.target, getRandomLightColor(), .5)
            this.link.truewidth = 1
            this.xr = this.target.xavg - this.ball.x
            this.ry = this.target.yavg - this.ball.y
        }
        draw() {
            // this.ry++
            this.xr += (Math.random() - .5) * 3
            this.ry += (Math.random() - .5) * 3
    
    
            this.ball.x = this.target.xavg - this.xr
            this.ball.y = this.target.yavg - this.ry
    
            this.link.draw()
    
            canvas_context.fillStyle = getRandomLightColor()
            canvas_context.strokeStyle = "black"
            canvas_context.lineWidth = 1
            canvas_context.font = "15px arial"
            canvas_context.strokeText(this.word, this.ball.x, this.ball.y)
            canvas_context.fillText(this.word, this.ball.x, this.ball.y)
    
    
    
        }
    }
    
    let potential = new Image()
    potential.src = 'potential.png'
    
    
    let panel = new Image()
    panel.src = 'panel.png'
    let buttons = new Image()
    buttons.src = 'buttons.png'
    let glove = new Image()
    glove.src = 'glove.png'
    
    class PlayerUI {
        constructor() {
            this.potential = 100
            this.active = 1
    
            this.checked = 0
            this.betmax = 10
            this.freemove = -1
            this.frame = 0
            this.gumblo  = 1
            this.grab  = -1
            this.grab2  = -1
            this.kill2  = -1
            this.feed  = -1
            this.seebets  = -1
            this.seeage  = -1
            this.seeenergy  = -1
            this.kill  = -1
    
            this.wordballs = []
            this.buttons = []
            for(let t = 0;t<10;t++){
              let button = new Rectangle(82+(128*t),945,128,135,"WHite")
              this.buttons.push(button)
            }
        }
        draw() {
          this.worldtouch = 0
          this.checked = 0
            if (keysPressed['=']) {
                this.betmax += 10
                keysPressed['='] = false
            }
            if (keysPressed['-']) {
                keysPressed['-'] = false
                this.betmax -= 10
                this.betmax = Math.max(this.betmax, 0)
            }
            if (keysPressed['m']) {
                this.active *= -1
                keysPressed['m'] = false
            }
    
            this.potential += .001
            if (this.active == 1) {
                for (let t = 0; t < this.wordballs.length; t++) {
                    this.wordballs[t].time--
                    this.wordballs[t].draw()
                }
                for (let t = 0; t < this.wordballs.length; t++) {
                    if (this.wordballs[t].time <= 0) {
                        this.wordballs.splice(t, 1)
                    }
                }
    
    
                this.len = Math.floor(potential.width / 20)
                this.frame += .1
                // ////////////////console.log(this.len, this.frame)
    
                canvas_context.fillStyle = "white"
                canvas_context.font = "20px arial"
    
    
                this.potential = Math.max(0, this.potential)
                canvas_context.fillText((this.potential).toFixed(2) + '/' + (this.betmax).toFixed(2), 40, 27)
                let offsetx =0 
                let width = panel.width
                let offsety = canvas.height-135
                let w = Math.min(1280, canvas.width)
                let h = Math.min(135, canvas.height)
                if(canvas.width > width){

                  offsetx = (canvas.width-Math.min(width, canvas.width))/2

                }

                canvas_context.globalAlpha =  ((TIP_engine.y/offsety)-.05)**20
   
                canvas_context.drawImage(panel,0,0,panel.width, panel.height, offsetx,offsety, w,h)
                canvas_context.drawImage(buttons,0,0,buttons.width, buttons.height, offsetx,offsety, w,h)
                canvas_context.globalAlpha =  1


            this.buttons = []
            for(let t = 0;t<10;t++){
              let button = new Rectangle(offsetx+((w/10)*t),offsety,((w/10)),h,"WHite")
              this.buttons.push(button)
            }



                this.spot = 0
                if(this.gumblo == 1){
                  this.spot = 0
                }
                if(this.grab2 == 1){
                  this.spot = 128
                }
                if(this.feed == 1){
                  this.spot = 256
                }
                if(this.kill2 == 1){
                  this.spot = 128*3
                }
                if(this.spot == 0){
                  this.gumblo = 1
                }
                canvas_context.drawImage(buttons, this.spot,0,128,135, TIP_engine.x-12, TIP_engine.y-12, 24,24)
                canvas_context.drawImage(potential, (Math.floor(this.frame) % this.len) * 20, 0, 20, 20, 10, 10, 20, 20)
    
    
    
            }
    
    
        }
        check(point){
          this.checked = 1
          if(this.grab2 == 1){
            this.grab*=-1
          }else{

          }
          if(this.kill2 == 1){
            this.kill = 1
          }else{

          }



          for(let t = 0;t<this.buttons.length;t++){
            if(this.buttons[t].isPointInside(point)){ 
              this.gumblo  = -1
              this.grab  = -1
              this.feed  = -1
              this.kill  = -1
              if(t != 1){
               this.grab2= -1
              }
              if(t != 3){
               this.kill2= -1
               this.kill = -1
              }
              if(t != 4){
                this.seebets  = -1
              }
              if(t != 5){
                this.seeage  = -1
              }
              if(t != 6){
                this.seeenergy  = -1
              }
            }
          }
          for(let t = 0;t<this.buttons.length;t++){
            if(this.buttons[t].isPointInside(point)){ 
              this.worldtouch = 1
              if(t == 0){
                this.gumblo*=-1
                this.checked = -1
              }else if(t == 1){
                this.grab2*=-1
              }else if(t == 2){
                this.feed*=-1
              }else if(t == 3){
                this.kill2*=-1 
              }else if(t == 4){
                this.seebets*=-1
                
              }else if(t == 5){
                this.seeage*=-1
                
              }else if(t == 6){
                this.seeenergy*=-1
                
              }else if(t == 7){
                if(viewStyle != 4){

                  viewStyle = 4

            for (let t = 0; t < globalnodes.length; t++) {
              globalnodes[t].firsty = 0
          }
                }else{

                viewStyle = 0

            for (let t = 0; t < globalnodes.length; t++) {
              globalnodes[t].firsty = 0
          }
                }
                
              }else if(t == 8){
                this.betmax+=10+Math.floor(this.betmax/10)
                
              }else if(t == 9){
                this.betmax-=10+Math.floor(this.betmax/10)
              
                this.betmax = Math.max(0,this.betmax)
              }

              
            }
          }

        }
    }
    
    let pu = new PlayerUI()
    
    
    let looptext = "no loop"
    let edgebutt = new Rectangle(350, 200, 80, 40, "yellow")
    class NodeUI {
        constructor() {
    
    
            this.sliders = []
            this.sliderlabels = []
    
            this.sliders.push(new Slider(600, 60, 100, -.5, .5, movementCost, adjustMovementCost))
            this.sliderlabels.push("Movement Cost")
            this.sliders.push(new Slider(600, 100, 100, -1, 1, generationConstant, adjustEnergyGeneration))
            this.sliderlabels.push("Energy Production")
            this.sliders.push(new Slider(600, 140, 100, -.1, .1, baseCostOfNode, adjustbaseCostOfNode))
            this.sliderlabels.push("Base Node Cost")
            this.sliders.push(new Slider(600, 180, 100, -.5, .5, mouthCost, adjustmouthCost))
            this.sliderlabels.push("Mouth Cost")
            this.sliders.push(new Slider(600, 220, 100, -.5, .5, dragcost, adjustdragCost))
            this.sliderlabels.push("Disease Cost")
            this.sliders.push(new Slider(600, 260, 100, -.5, .5, anchorcost, adjustanchorCost))
            this.sliderlabels.push("Anchor Cost")
            this.sliders.push(new Slider(600, 300, 100, -.5, .5, pistoncost, adjustpistonCost))
            this.sliderlabels.push("Piston Cost")
            this.sliders.push(new Slider(600, 340, 100, -.5, .5, rotationCost, adjustrotationCost))
            this.sliderlabels.push("Rotor Cost")
            this.sliders.push(new Slider(600, 380, 100, -.5, .5, magnetcost, adjustmagnetCost))
            this.sliderlabels.push("Magnetism Cost")
            this.sliders.push(new Slider(600, 420, 100, -.05, .05, genelengthcost, adjustgenelengthcost))
            this.sliderlabels.push("Gene Cost")
            this.sliders.push(new Slider(600, 460, 100, -.1, .1, linkcostdistance, adjustlinkcostdistance))
            this.sliderlabels.push("Link Length Cost")
            this.sliders.push(new Slider(600, 500, 100, -2, 2, fertilitycost, adjustfertilitycost))
            this.sliderlabels.push("Fertility Cost")
            this.sliders.push(new Slider(600, 540, 100, -2, 2, longevitycost, adjustlongevitycost))
            this.sliderlabels.push("Longevity Cost")
            this.sliders.push(new Slider(760, 300, 100, 0, 500, temperature, adjustTemperature))
            this.sliderlabels.push("Temperature")
            this.sliders.push(new Slider(760, 340, 100, 0, 50, magnetradius, adjustmagnetradius))
            this.sliderlabels.push("Magnet Radius Factor")
            this.sliders.push(new Slider(600, 580, 100, 0, 32 * 7 * 2, speciesdistance, adjustspeciesdistance))
            this.sliderlabels.push("Cannibal Range Factor")
            this.sliders.push(new Slider(600, 700, 100, 0, 32 * 7 * 8, breedingdistance, adjustbreedingdistance))
            this.sliderlabels.push("Breeding Range Factor")
            this.sliders.push(new Slider(760, 60, 100, 25, 500, repconstant, adjustrepconstant))
            this.sliderlabels.push("Reproduction Cost")
            this.sliders.push(new Slider(760, 100, 100, 1, 100, minage, adjustminage))
            this.sliderlabels.push("Minimum Death Age")
            this.sliders.push(new Slider(760, 140, 100, 101, 2500, maxage, adjustmaxage))
            this.sliderlabels.push("Maximum Age Scalar")
            this.sliders.push(new Slider(760, 180, 100, 1, 25, loutmin, adjustloutmin))
            this.sliderlabels.push("Link Length Minimum")
            this.sliders.push(new Slider(760, 220, 100, 0, 5, codonconstant, adjustcodonconstant))
            this.sliderlabels.push("Codon Mutation Factor")
            this.sliders.push(new Slider(760, 260, 100, 1, 17, genelength, adjustgenelength))
            this.sliderlabels.push("Gene Codon Base Length")
            this.sliders.push(new Slider(760, 380, 100, 4, 24, worldscale, adjustworldscale))
            this.sliderlabels.push("World Scale")
            this.sliders.push(new Slider(760, 420, 100, 0, 250, predatorIncentive, adjustpredatorIncentive))
            this.sliderlabels.push("Predation Incentive")
            this.sliders.push(new Slider(760, 460, 100, 1, 2500, driftconstant, adjustdriftconstant))
            this.sliderlabels.push("Drift Force Constant")
            this.sliders.push(new Slider(760, 500, 100, -1, 30, diffdist, adjustdriftdistance))
            this.sliderlabels.push("Drift Distance")
            this.sliders.push(new Slider(760, 540, 100, -.5, .5, linkcost, adjustlinkcost))
            this.sliderlabels.push("Link Flat Cost")
            this.sliders.push(new Slider(760, 580, 100, 0, 20, timemin, adjusttimemin))
            this.sliderlabels.push("Life Extension Factor")
            this.sliders.push(new Slider(760, 620, 100, -2, 2, gillconstant, adjustgillconstant))
            this.sliderlabels.push("Gill Constant")
            this.sliders.push(new Slider(600, 620, 100, 1, 500, suckratio, adjustsuckratio))
            this.sliderlabels.push("Energy Sapping Ratio")
            this.sliders.push(new Slider(600, 660, 100, .1, 25, agesuckrat, adjustagesuckrat))
            this.sliderlabels.push("Age Sapping Ratio")
            this.sliders.push(new Slider(760, 660, 100, -.5, .5, suckCost, adjustsuckCost))
            this.sliderlabels.push("Sapping Node Cost")
            this.sliders.push(new Slider(760, 700, 100, 5, 25, smellScaler, adjustsmellScaler))
            this.sliderlabels.push("Smell Grid Size")
    
            this.sliders.push(new Toggle(200, 220, smellFlip, adjustsmellFlip))
            this.sliderlabels.push("Smell Use")
            this.sliders.push(new Toggle(200, 140, soundFlip, adjustsoundFlip))
            this.sliderlabels.push("Sound Use")
            this.sliders.push(new Toggle(200, 180, freeEnergyOn, adjustfreeEnergyOn))
            this.sliderlabels.push("Light Struggle")
            this.sliders.push(new Toggle(200, 300, codonusage, adjustcodonusage))
            this.sliderlabels.push("Codon Use")
            this.sliders.push(new Toggle(200, 340, particletoggle, adjustparticletoggle))
            this.sliderlabels.push("Particles")
            this.sliders.push(new Toggle(200, 380, edgeLoop, adjustedgeLoop))
            this.sliderlabels.push("Edge Loop")
            this.sliders.push(new Toggle(200, 420, audioPing, adjustaudioping))
            this.sliderlabels.push("Audio Play")
            this.sliders.push(new Toggle(200, 260, dumbdoton, adjustdumbdoton))
            this.sliderlabels.push("Cage Orb")
            this.sliders.push(new HotSlider(300, 520, 100, 0, .11, mutationrate, adjustmutationrate))
            this.sliderlabels.push("Mutation Rate")
    
    
            this.buttons = []
            this.muttons = [new Rectangle(50, 50, 80, 40, "green")]
    
            this.mutations = [new Rectangle(200, 100, 40, 40, "yellow"), new Rectangle(250, 100, 40, 40, "orange"), ]
    
    
            for (let t = 0; t < nodetypes; t++) {
                let button = new Rectangle(10, 20 + (20.5 * t), 20, 20, "white")
                this.buttons.push(button)
            }
        }
        draw() {
            for (let t = 0; t < this.muttons.length; t++) {
                canvas_context.fillStyle = "green"
                canvas_context.fillRect(this.muttons[t].x, this.muttons[t].y, this.muttons[t].width, this.muttons[t].height)
    
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = "14px arial"
                canvas_context.strokeText("Start", this.muttons[t].x + 20, this.muttons[t].y + 25)
                canvas_context.fillText("Start", this.muttons[t].x + 20, this.muttons[t].y + 25)
    
    
    
            }
            for (let t = 0; t < this.sliders.length; t++) {
                this.sliders[t].draw(this.sliderlabels[t])
            }
            // for(let t = 0;t<this.mutations.length;t++){
            //     canvas_context.fillStyle = this.mutations[t].color
            //     canvas_context.fillRect(this.mutations[t].x, this.mutations[t].y, this.mutations[t].width, this.mutations[t].height)
    
            // }
            for (let t = 0; t < this.buttons.length; t++) {
                canvas_context.fillStyle = "#333333"
                canvas_context.fillRect(this.buttons[t].x, this.buttons[t].y, this.buttons[t].width, this.buttons[t].height)
    
                this.x = this.buttons[t].x + 10
                this.y = this.buttons[t].y + 10
    
                this.type = t
                if (this.type == 0) {
                    this.inert = 1
                    this.body = new Circle(this.x, this.y, 3, "#ffffff")
                }
                if (this.type == 1) {
                    this.rotor = 1
                    this.armor = 1
                    // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF00aa")
                    // this.body = new Circle(this.x, this.y, 3, "#AA0055")
                    this.body = new Polygon(this.x, this.y, 4, "#AA0055", 4, 0, 0, (0) + Math.PI)
                }
                if (this.type == 2) {
                    this.armor = 1
                    this.motor = 1
                    // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                    // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF8800")
                    this.body = new Polygon(this.x, this.y, 5, "#ffCc00", 3, 0, 0, (0))
                }
                if (this.type == 3) {
                    this.rotor = 1
                    this.motor = 1
                    // this.body = new Circle(this.x, this.y, 3.5, "#8800ff")
    
                    this.body = new Polygon(this.x, this.y, 5, "#8800ff", 3, 0, 0, (0) + Math.PI)
                }
                if (this.type == 4) {
                    this.produce = 1
                    // this.body = new Circle(this.x, this.y, 4, "#00FF00")
                    this.body = new Polygon(this.x, this.y, 5, "#00FF00", 6, 0, 0, (0) + Math.PI)
                }
                if (this.type == 5) {
                    this.armor = 1
                    this.mouth = 1
                    // this.body = new Circle(this.x, this.y, 5, "#FF0000")
                    this.body = new Polygon(this.x, this.y, 5, "#FF0000", 5, 0, 0, (0) + Math.PI)
                }
                if (this.type == 6) {
                    this.armor = 1
                    this.body = new Polygon(this.x, this.y, 5, "#FF8800", 4, 0, 0, (0) + Math.PI)
                }
                if (this.type == 7) {
                    this.produce = 1
                    this.motor = 1
                    this.body = new Polygon(this.x, this.y, 5, "#00FFFF", 3, 0, 0, (0))
                }
                if (this.type == 8) {
                    this.produce = 1
                    this.rotor = 1
                    this.body = new Polygon(this.x, this.y, 5, "#228844", 1, 0, 0, (0))
                }
                if (this.type == 9) {
                    this.anchor = 1
                    this.body = new Polygon(this.x, this.y, 5, "#4499FF", 5, 0, 0, (0))
                }
                if (this.type == 10) {
                    this.anchor = 1
                    this.rotor = 1
                    this.body = new Polygon(this.x, this.y, 5, "#AA5678", 4, 0, 0, (0))
                }
                if (this.type == 11) {
                    this.piston = 1
                    this.inert = 1
                    this.body = new Polygon(this.x, this.y, 6, "#AAFFAA", 2, 0, 0, (0))
                }
                if (this.type == 12) {
                    this.piston = 1
                    this.body = new Polygon(this.x, this.y, 6, "#AA8888", 2, 0, 0, (0))
                }
                if (this.type == 13) {
                    this.fertile = 1
                    this.body = new Circle(this.x, this.y, 3.5, "#FF44bb")
                }
                if (this.type == 14) {
                    this.life = 1
                    this.body = new Polygon(this.x, this.y, 5, "#889900", 5, 0, 0, (0))
                }
                if (this.type == 15) {
                    this.gill = 1
                    this.body = new Polygon(this.x, this.y, 4, "#DDDD66", 5, 0, 0, (0))
                }
                if (this.type == 16) {
                    this.suck = 1
                    this.body = new Polygon(this.x, this.y, 6, "#880000", 1, 0, 0, (0))
                }
                if (this.type == 17) {
                    this.nose = 1
                    this.noserotor = 1
                    this.body = new Polygon(this.x, this.y, 4, "#555555", 4, 0, 0, (0))
                }
                if (this.type == 18) {
                    this.nose = 1
                    this.nosemotor = 1
                    this.body = new Polygon(this.x, this.y, 4, "#2233CC", 3, 0, 0, (0))
                }
                if (this.type == 19) {
                    this.fertile = 1
                    this.male = 1
                    this.body = new Polygon(this.x, this.y, 4, "#FFAAAA", 1, 0, 0, (0))
                }
                if (this.type == 20) {
                    this.produce = 1
                    this.pusher = 1
                    this.body = new Polygon(this.x, this.y, 6, "#982754", 3, 0, 0, (Math.PI))
                }
                if (this.type == 21) {
                    this.ear = 1
                    this.body = new Polygon(this.x, this.y, 6, "#AA88ff", 3, 0, 0, (0))
                }
                if (this.type == 22) {
                    this.drag = 1
                    this.body = new Polygon(this.x, this.y, 5, "#543210", 6, 0, 0, (0))
                }
    
    
                if (viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7) {
                    this.subcolor = this.body.color
                    this.body.parent = this
                    this.parent = this
                }
    
    
    
                this.body.type = this.type
                this.body.draw(canvas_context)
    
            }
        }
        subcheck(point) {
    
            // if(edgebutt.isPointInside(point)){
    
            //     canvas_context.fillStyle = "white"
            //     canvas_context.lineWidth = 1
            //     canvas_context.strokeStyle = "black"
            //     canvas_context.font = "14px arial"
            //     canvas_context.strokeText("World Loop Toggle", point.x, point.y)
            //     canvas_context.fillText("World Loop Toggle", point.x, point.y)
            //     return
            // }
    
            for (let t = 0; t < this.muttons.length; t++) {
                this.x = this.muttons[t].x
                this.y = this.muttons[t].y
                this.width = this.muttons[t].width
                this.height = this.muttons[t].height
    
                if (point.x >= this.x) {
                    if (point.y >= this.y) {
                        if (point.x <= this.x + this.width) {
                            if (point.y <= this.y + this.height) {
                                canvas_context.fillStyle = "white"
                                canvas_context.lineWidth = 1
                                canvas_context.strokeStyle = "black"
                                canvas_context.font = "14px arial"
                                canvas_context.strokeText("Start", point.x, point.y)
                                canvas_context.fillText("Start", point.x, point.y)
                            }
                        }
                    }
                }
    
            }
    
            // for(let t = 0;t<this.mutations.length;t++){
            // this.x = this.mutations[t].x
            // this.y = this.mutations[t].y
            // this.width = this.mutations[t].width
            // this.height = this.mutations[t].height
    
            // if (point.x >= this.x) {
            //     if (point.y >= this.y) {
            //         if (point.x <= this.x + this.width) {
            //             if (point.y <= this.y + this.height) {
            //                 if(t == 0){
            //                     canvas_context.fillStyle = "white"
            //                     canvas_context.lineWidth = 1
            //                     canvas_context.strokeStyle = "black"
            //                     canvas_context.font = "14px arial"
            //                     canvas_context.strokeText("Mutation Down", point.x, point.y)
            //                     canvas_context.fillText("Mutation Down", point.x, point.y)
            //                 }else{
    
            //                     canvas_context.fillStyle = "white"
            //                     canvas_context.lineWidth = 1
            //                     canvas_context.strokeStyle = "black"
            //                     canvas_context.font = "14px arial"
            //                     canvas_context.strokeText("Mutation Up", point.x, point.y)
            //                     canvas_context.fillText("Mutation Up", point.x, point.y)
            //                 }
            //             }
            //         }
            //     }
            // }
    
            // }
    
            for (let t = 0; t < this.buttons.length; t++) {
                this.x = this.buttons[t].x
                this.y = this.buttons[t].y
                this.width = this.buttons[t].width
                this.height = this.buttons[t].height
                ////////////////////////////////console.log(this)
                if (point.x >= this.x) {
                    if (point.y >= this.y) {
                        if (point.x <= this.x + this.width) {
                            if (point.y <= this.y + this.height) {
    
                                if (nodin1 == -1) {
                                    // nodein.push(t)
                                    canvas_context.fillStyle = '#092909'
                                    canvas_context.fillRect(point.x - 10, point.y - 15, canvas_context.measureText(instructions[t]).width + 20, 20)
    
    
                                    canvas_context.fillStyle = "white"
                                    canvas_context.lineWidth = 1
                                    canvas_context.strokeStyle = "black"
                                    canvas_context.font = "14px arial"
                                    canvas_context.strokeText(instructions[t], point.x, point.y)
                                    canvas_context.fillText(instructions[t], point.x, point.y)
                                    return
                                }
                            }
                        }
                    }
                }
            }
    
        }
        stupidCheck(point) {
    
            for (let t = 0; t < this.sliders.length; t++) {
    
                this.sliders[t].handlePointer(point)
    
            }
        }
        check(point) {
    
            if (edgebutt.isPointInside(point)) {
                edgeLoop *= -1
                return
            }
    
            for (let t = 0; t < this.sliders.length; t++) {
    
                this.sliders[t].handlePoint(point)
    
            }
            for (let t = 0; t < this.muttons.length; t++) {
                this.x = this.muttons[t].x
                this.y = this.muttons[t].y
                this.width = this.muttons[t].width
                this.height = this.muttons[t].height
    
                if (point.x >= this.x) {
                    if (point.y >= this.y) {
                        if (point.x <= this.x + this.width) {
                            if (point.y <= this.y + this.height) {
                                signal = 1
                            }
                        }
                    }
                }
    
            }
    
    
    
            for (let t = 0; t < this.mutations.length; t++) {
                this.x = this.mutations[t].x
                this.y = this.mutations[t].y
                this.width = this.mutations[t].width
                this.height = this.mutations[t].height
    
                if (point.x >= this.x) {
                    if (point.y >= this.y) {
                        if (point.x <= this.x + this.width) {
                            if (point.y <= this.y + this.height) {
                                if (t == 0) {
                                    if (mutationrate > 0) {
                                        if (mutationrate < .0101) {
    
                                            mutationrate -= .001
                                        } else {
                                            mutationrate -= .01
                                        }
                                    }
                                } else {
                                    if (mutationrate < .1) {
                                        if (mutationrate < .01) {
                                            mutationrate += .001
                                        } else {
                                            mutationrate += .01
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
    
            }
    
    
    
    
            for (let t = 0; t < this.buttons.length; t++) {
                this.x = this.buttons[t].x
                this.y = this.buttons[t].y
                this.width = this.buttons[t].width
                this.height = this.buttons[t].height
                ////////////////////////////////console.log(this)
                if (point.x >= this.x) {
                    if (point.y >= this.y) {
                        if (point.x <= this.x + this.width) {
                            if (point.y <= this.y + this.height) {
    
                                if (nodin1 == -1) {
                                    nodein.push(t)
                                    return
                                }
                            }
                        }
                    }
                }
            }
    
        }
    }
    
    let UI = new NodeUI()
    
    let deadwash = 4
    let deadmax = 33
    
    function cleanDeadOut() {
        deadwash++
        if (deadwash == deadmax) {
            mindead = 0
            deadwash = 0
            let killer = []
            // let marks = []
            // for (let t = globalnodes.length - 1; t >= 0; t--) {
            // for (let t = 0; t < globalnodes.length; t++) {
                for (let t = globalnodes.length - 1; t >= 0; t--) {
                // ////////////////////////////////console.log(globalnodes[t])
                // if(typeof globalnodes[t] != "undefined"){
    
                if (globalnodes[t].dead == 1) {
                    killer.push(t)
    
    
                    //relationview '7' "7"
                    // canvasList[globalnodes[t].contextMarker] = {}
                    // contextList[globalnodes[t].contextMarker] = {}
                    // mappingArt[globalnodes[t].contextMarker] = {}
    
    
                    globalnodes.splice(t, 1)
                    ////////////////////////////////console.log("")
                    // if(mindead > t){
                    //     mindead--
                    // }
                    // t--
                    superclick--
                    // let con = [...globalnodes[t].dcon] 
                    // globalnodes[t] = new Circle(0,0,1)
                    // globalnodes[t].dead = 1
                    // globalnodes[t].superdead = 1
                    // globalnodes[t].dcon = [...con]
                }
                // }
            }
    
            killer.sort((a,b) => a<b?1:-1)
    
            for (let k = 0; k < globalnodes.length; k++) {
                // if(t != k){
    
                //////////////////////////////console.log(t, globalnodes[t].id)
                for(let w = 0;w<killer.length;w++){
                    globalnodes[k].indexkill(killer[w])
                }
                // }
            }
    
    
            // for (let t = 0; t < globalnodes.length; t++) {
            //     // ////////////////////////////////console.log(globalnodes[t])
            //     // if(typeof globalnodes[t] != "undefined"){
    
            //     if (globalnodes[t].dead == 1) {
            //         for (let k = 0; k < globalnodes.length; k++) {
            //             // if(t != k){
    
            //             //////////////////////////////console.log(t, globalnodes[t].id)
            //             globalnodes[k].indexkill(t)
            //             // }
            //         }
    
            //         //relationview '7' "7"
            //         canvasList[globalnodes[t].contextMarker] = {}
            //         contextList[globalnodes[t].contextMarker] = {}
            //         mappingArt[globalnodes[t].contextMarker] = {}
    
            //         globalnodes.splice(t, 1)
            //         ////////////////////////////////console.log("")
            //         // if(mindead > t){
            //         //     mindead--
            //         // }
            //         t--
            //         superclick--
            //         // let con = [...globalnodes[t].dcon] 
            //         // globalnodes[t] = new Circle(0,0,1)
            //         // globalnodes[t].dead = 1
            //         // globalnodes[t].superdead = 1
            //         // globalnodes[t].dcon = [...con]
            //     }
            //     // }
            // }
            // for (let t = 0; t < globalnodes.length; t++) {
            //     // ////////////////////////////////console.log(globalnodes[t])
            //     // if(typeof globalnodes[t] != "undefined"){
    
            //     if (globalnodes[t].dead == 1) {
            //         for (let k = 0; k < globalnodes.length; k++) {
            //             // if(t != k){
    
            //             //////////////////////////////console.log(t, globalnodes[t].id)
            //             globalnodes[k].indexkill(t)
            //             // }
            //         }
    
    
            //         //relationview '7' "7"
            //         canvasList[globalnodes[t].contextMarker] = {}
            //         contextList[globalnodes[t].contextMarker] = {}
            //         mappingArt[globalnodes[t].contextMarker] = {}
    
    
            //         globalnodes.splice(t, 1)
            //         ////////////////////////////////console.log("")
            //         // if(mindead > t){
            //         //     mindead--
            //         // }
            //         t--
            //         superclick--
            //         // let con = [...globalnodes[t].dcon] 
            //         // globalnodes[t] = new Circle(0,0,1)
            //         // globalnodes[t].dead = 1
            //         // globalnodes[t].superdead = 1
            //         // globalnodes[t].dcon = [...con]
            //     }
            //     // }
            // }
            // for (let t = 0; t < globalnodes.length; t++) {
            //     // ////////////////////////////////console.log(globalnodes[t])
            //     // if(typeof globalnodes[t] != "undefined"){
    
            //     if (globalnodes[t].dead == 1) {
            //         for (let k = 0; k < globalnodes.length; k++) {
            //             // if(t != k){
    
            //             //////////////////////////////console.log(t, globalnodes[t].id)
            //             globalnodes[k].indexkill(t)
            //             // }
            //         }
    
    
            //         //relationview '7' "7"
            //         canvasList[globalnodes[t].contextMarker] = {}
            //         contextList[globalnodes[t].contextMarker] = {}
            //         mappingArt[globalnodes[t].contextMarker] = {}
    
    
            //         globalnodes.splice(t, 1)
            //         ////////////////////////////////console.log("")
            //         // if(mindead > t){
            //         //     mindead--
            //         // }
            //         t--
            //         superclick--
            //         // let con = [...globalnodes[t].dcon] 
            //         // globalnodes[t] = new Circle(0,0,1)
            //         // globalnodes[t].dead = 1
            //         // globalnodes[t].superdead = 1
            //         // globalnodes[t].dcon = [...con]
            //     }
            //     // }
            // }
    
            for (let t = 0; t < globalnodes.length; t++) {
                globalnodes[t].id = t
            }
        }
    
    }
    
    let metrics = {}
    metrics.tick = 100
    metrics.time = 0
    metrics.species = []
    metrics.complexity = []
    metrics.mincomplexity = []
    metrics.maxcomplexity = []
    metrics.diversity = []
    metrics.nodepopulation = []
    metrics.population = []
    let metricsON = 0
    
    let nodecolors = ["#FFFFFF", "#AA0055", "#ffCc00", "#8800ff", "#00FF00", "#FF0000", "#FF8800", "#00FFFF", "#228844", "#4499FF", "#AA5678", "#AAFFAA", "#AA8888", "#FF44bb", "#889900", "#DDDD66", "#880000", "#555555", "#2233CC", "#ffaaaa","#982754","#AA88ff", "#543210"]
    // nodecolors[100] = "#543210"
    let types = ["Structural Node", "Rotation Node", "Head Node", "Rotational Head Node", "Production Node", "Tooth Node", "Armor Node", "Production Motor Node", "Production Rotor Node", "Generator Anchor Node", "Armored Anchor Node", "Generator Piston Node", "Armored Piston Node", "Female Reproduction Node", 'Longevity Node', "Static Gill Node", "Sapping Node", "Rotor Nose Node", "Motor Nose Node", "Male Reproduction Node", "Pushing Armor Node", "Ear gill Node", "Disease Node"]
    
    
    
    canvas_context.fillStyle = "black"
    canvas_context.fillRect(0, 0, canvas.width, canvas.height)
    let pix = canvas_context.getImageData(0, 0, canvas.width * .5, canvas.height * .5)
    let pix1 = canvas_context.getImageData(0, 0, canvas.width * .5, canvas.height * .5)
    let pix2 = canvas_context.getImageData(0, 0, canvas.width * .5, canvas.height * .5)
    let pix3 = canvas_context.getImageData(0, 0, canvas.width * .5, canvas.height * .5)
    let pix4 = canvas_context.getImageData(0, 0, canvas.width * .5, canvas.height * .5)
    let pix5 = canvas_context.getImageData(0, 0, canvas.width * .5, canvas.height * .5)
    let pix6 = canvas_context.getImageData(0, 0, canvas.width * .5, canvas.height * .5)
    let humanpix1 = canvas_context.getImageData(0, 0, canvas.width * .5, canvas.height * .5)
    let humanpix2 = canvas_context.getImageData(0, 0, canvas.width * .5, canvas.height * .5)
    let humanpix3 = canvas_context.getImageData(0, 0, canvas.width * .5, canvas.height * .5)
    let humanpix4 = canvas_context.getImageData(0, 0, canvas.width * .5, canvas.height * .5)
    let humanpix5 = canvas_context.getImageData(0, 0, canvas.width * .5, canvas.height * .5)
    let humanpix6 = canvas_context.getImageData(0, 0, canvas.width * .5, canvas.height * .5)
    
    
    
    let particles = []
    
    let geneChars = ["S", "R", "H", "Q", "P", "T", "A", "M", "W", "N", "L", "O", "X", "+", "#", "G", 'Z', 'U', "V", "C","B","E"]
    
    
    function geneToType(genestring) {
    
    
    
    
        let chars = genestring.split('')
     
        let c = {}
        for (let k = 0; k < chars.length; k++) {
            if (c[chars[k]]) {
                c[chars[k]]++
            } else {
                c[chars[k]] = 1
            }
        }
    
        let keys = Object.keys(c)
    
        let art = []
        for (let t = 0; t < keys.length; t++) {
            art.push([c[keys[t]], keys[t]])
        }
    
        art.sort((a, b) => a[0] > b[0] ? -1 : 1)
    
        let type = geneChars.indexOf(art[0][1])
    
        if (art[1]) {
            if (art[0][0] == art[1][0]) {
                if (art[0][0] > 1) {
    
                } else {
                    return 22
                }
            }
        }
    
    
        if (art.length > 1) {
            // ////////////////console.log(art, keys, c, genestring, type)
        }
    
        return type
    }
    
    function mutateGenes(genes) {
    
    
        let chars = genes.split('')
    
    
    
    
        for (let t = 0; t < chars.length; t++) {
            if (seedRandom() < mutationrate * codonconstant) {
                chars[t] = geneChars[Math.floor(seedRandom() * geneChars.length)]
            }
        }
        if (seedRandom() < mutationrate * codonconstant) {
            if (chars.length > 1) {
                let t = Math.floor(seedRandom() * chars.length)
                chars.splice(t, 1)
            }
        }
    
        if (seedRandom() < mutationrate * codonconstant) {
            if (seedRandom() < .5) {
                if (seedRandom() < .5) {
                    chars.push(geneChars[Math.floor(seedRandom() * geneChars.length)])
                } else {
                    chars.unshift(geneChars[Math.floor(seedRandom() * geneChars.length)])
                }
            } else {
                if (seedRandom() < .5) {
                    chars.push(chars[Math.floor(seedRandom() * chars.length)])
                } else {
                    chars.unshift(chars[Math.floor(seedRandom() * chars.length)])
                }
            }
        }
    
        let g = ''
    
        for (let t = 0; t < chars.length; t++) {
            g += chars[t]
        }
        return g
    
    }
    
    
    class X {
        constructor(x, y, color, size) {
            const angle = Math.PI / 4
            this.size = size
            this.x = x
            this.y = y
            this.point1 = new Point(x + (Math.cos(angle) * this.size), y + (Math.sin(angle) * this.size))
            this.point2 = new Point(x + (Math.cos(angle) * -this.size), y + (Math.sin(angle) * -this.size))
            this.point3 = new Point(x + (Math.cos(angle + Math.PI * .5) * this.size), y + (Math.sin(angle + Math.PI * .5) * this.size))
            this.point4 = new Point(x + (Math.cos(angle + Math.PI * .5) * -this.size), y + (Math.sin(angle + Math.PI * .5) * -this.size))
            this.link1 = new LineOP(this.point1, this.point2, color, 2)
            this.link2 = new LineOP(this.point3, this.point4, color, 2)
            this.color = color
        }
        draw(angler, context) {
            this.angle = angler
            const angle = Math.PI / 4
            this.point1.x = this.x + (Math.cos(angle + this.angle) * this.size)
            this.point1.y = this.y + (Math.sin(angle + this.angle) * this.size)
            this.point2.x = this.x + (Math.cos(angle + this.angle) * -this.size)
            this.point2.y = this.y + (Math.sin(angle + this.angle) * -this.size)
            this.point3.x = this.x + (Math.cos(angle + this.angle + (Math.PI * .5)) * this.size)
            this.point3.y = this.y + (Math.sin(angle + this.angle + (Math.PI * .5)) * this.size)
            this.point4.x = this.x + (Math.cos(angle + this.angle + (Math.PI * .5)) * -this.size)
            this.point4.y = this.y + (Math.sin(angle + this.angle + (Math.PI * .5)) * -this.size)
    
    
            // ////////////////console.log(this)
    
            this.link1.color = this.color
            this.link2.color = this.color
            if (start == 1) {
    
                this.link1.width = 3 * worldscaler
                this.link2.width = 3 * worldscaler
            } else {
    
                this.link1.width = 3
                this.link2.width = 3
            }
            this.link1.draw(context)
            this.link2.draw(context)
        }
    }
    
    class SX {
        constructor(x, y, color, size) {
            const angle = Math.PI / 4
            this.size = size
            this.x = x
            this.y = y
            this.point1 = new Point(x + (Math.cos(angle) * this.size), y + (Math.sin(angle) * this.size))
            this.point2 = new Point(x + (Math.cos(angle) * -this.size), y + (Math.sin(angle) * -this.size))
            this.point3 = new Point(x + (Math.cos(angle + Math.PI * .5) * this.size), y + (Math.sin(angle + Math.PI * .5) * this.size))
            this.point4 = new Point(x + (Math.cos(angle + Math.PI * .5) * -this.size), y + (Math.sin(angle + Math.PI * .5) * -this.size))
            this.link1 = new LineOP(this.point1, this.point2, color, 2)
            this.link2 = new LineOP(this.point3, this.point4, color, 2)
            this.color = color
        }
        draw(angler, context) {
            this.angle = angler
            const angle = Math.PI / 4
            this.point1.x = this.x + (Math.cos(angle + this.angle) * this.size)
            this.point1.y = this.y + (Math.sin(angle + this.angle) * this.size)
            this.point2.x = this.x + (Math.cos(angle + this.angle) * -this.size)
            this.point2.y = this.y + (Math.sin(angle + this.angle) * -this.size)
            this.point3.x = this.x + (Math.cos(angle + this.angle + (Math.PI * .5)) * this.size)
            this.point3.y = this.y + (Math.sin(angle + this.angle + (Math.PI * .5)) * this.size)
            this.point4.x = this.x + (Math.cos(angle + this.angle + (Math.PI * .5)) * -this.size)
            this.point4.y = this.y + (Math.sin(angle + this.angle + (Math.PI * .5)) * -this.size)
    
    
            // ////////////////console.log(this)
    
            this.link1.color = this.color
            this.link2.color = this.color
            if (start == 1) {
    
                this.link1.width = 2 * worldscaler
                this.link2.width = 2 * worldscaler
            } else {
    
                this.link1.width = 3
                this.link2.width = 3
            }
            this.link1.draw(context)
            this.link2.draw(context)
        }
    }
    
    
    
    
    function resizeCanvas() {
        timerresize = 1000
    }
    window.addEventListener('resize', resizeCanvas);
    
    
    
    function reconstitute(guys) {
    
    
        // ////////////////console.log(guys)
        let guylist = []
        for (let t = 0; t < guys.hold.length; t++) {
    
            let g = JSON.parse(guys.hold[t])
            // ////////////////console.log(g)
            let nud = new Node(g.x, g.y, g.type, g.genestring)
    
            let keys = Object.keys(g)
            for (let k = 0; k < keys.length; k++) {
                // nud[keys[k]] = g[keys[k]]
            }
    
            nud.type = g.type
            nud.indse = g.indse
            nud.charge = g.charge
            nud.magratio = g.magratio
            nud.neighborz = [...g.neighborz]
            nud.link = new LineOP(nud, nud)
            nud.link.list = []
            nud.head = 0
    
            //add shizz like rigs through smell stuff //stupe takes care of this? //no
    
    
    
    
            nud.rigs = [...g.rigs]
            nud.pistonstarts = [...g.pistonstarts]
            nud.pistonpushes = [...g.pistonpushes]
            nud.pistonticks = [...g.pistonticks]
            // nud.pistontimes = [...g.pistontimes]
            nud.ticks = [...g.ticks]
            nud.pistonticks = [...g.pistonticks]
            nud.subticks = [...g.subticks]
            nud.subrots = [...g.subrots]
            nud.noseStrengths = [...g.noseStrengths]
            nud.noseThresh = g.noseThresh
            nud.stinkRate = g.stinkRate
            nud.nosePref = [...g.nosePref]
            nud.noseAvoid = [...g.noseAvoid]
            nud.soundPref = []
    for(let t = 0;t<g.soundPref.length;t++){
        nud.soundPref[t] = g.soundPref[t]
        }
                nud.soundAvoid = []
        for(let t = 0;t<g.soundAvoid.length;t++){
            nud.soundAvoid[t] = g.soundAvoid[t]
        }
    
    
            nud.r = g.r
            nud.g = g.g
            nud.b = g.b
            nud.m = g.m
            nud.p = g.p
            nud.q = g.q
            nud.z = g.z
            nud.lout = g.lout * (g.worldscale / worldscale)
    
    
    
    
            nud.firsty = 0
            nud.age = 0
            nud.trueage = 0
            nud.dead = 0
            nud.first = 0
    
            nud.neighbors = []
            nud.dcon = []
            nud.dmark = 0
            nud.superdead = 0
            nud.caught = 0
    
            guylist.push(nud)
    
        }
    
        // ////////////////console.log(guylist) 
    
        for (let m = 0; m < guylist.length; m++) {
            for (let n = 0; n < guylist.length; n++) {
                if (m != n) {
    
                    if (guylist[m].neighborz.includes(guylist[n].indse)) {
                        guylist[m].connect(guylist[n])
                    } else if (guylist[n].neighborz.includes(guylist[m].indse)) {
                        guylist[n].connect(guylist[m])
                    }
                }
            }
        }
    
    
    
        if (guylist.length > 0) {
            guylist[0].head = 1
        }
    
    
    
    
    }
    
    function DupeNoRef(node, tip) {
        if(node.trueage < 2){
            return
        }
    
        let json = {}
        json.hold = []
    
    
        for (let t = 0; t < node.stupidimmune.length; t++) {
            if (node.stupidimmune[t] == 1) {
    
    
                let n = globalnodes[t]
                if (typeof n != "undefined") {
                    let nud = n.stupe()
                    nud.worldscale = worldscale
                    nud.indse = t
                    nud.neighborz = [...n.neighbors]
                    nud.x = tip.x / zoom + ((n.x - n.xavg) * worldscaler)
                    nud.y = tip.y / zoom + ((n.y - n.yavg) * worldscaler)
                    let s = JSON.stringify(nud)
                    json.hold.push(s)
                }
            }
        }
    
    
    
        dorecon = 1
        reconflag = json
        let reconflagz = json
    
        worldsave.guys.push((reconflagz))
    
    }
    
    function dissipateAndDecay(pixelData, width, height, decay = 0.96, dissipateFactor = 0.2, radius = 1) {
        const src = pixelData.data;
        const dst = new Uint8ClampedArray(src.length);
        const w4 = width * 4;
    
        // Pre-calculate constants for better performance
        const dissipate1 = 1 - (dissipateFactor - 0.5); // (1 - (dissipateFactor-.5))
        const dissipate2 = dissipateFactor + 0.60; // (dissipateFactor+.60)
        const finalMultiplier = decay * 0.53; // decay * 0.53
    
    
        if (edgeLoop == 1) {
    
    
            // Create a lookup table for the neighbors to avoid recalculating in the inner loop
            const neighbors = [];
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    neighbors.push([dx, dy]);
                }
            }
            const neighborCount = neighbors.length;
    
            // Helper function to calculate index with wrapping
            function getIndex(x, y) {
                // Handle wrapping around edges
                x = (x + width) % width;
                y = (y + height) % height;
                return (y * width + x) * 4;
            }
    
            // Process each pixel
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0,
                        g = 0,
                        b = 0;
    
                    // Sample the neighborhood
                    for (let i = 0; i < neighborCount; i++) { //tklinefix
                        const [dx, dy] = neighbors[i];
                        const ni = getIndex(x + dx, y + dy);
    
                        r += src[ni];
                        g += src[ni + 1];
                        b += src[ni + 2];
                    }
    
                    // Average the values
                    r /= neighborCount;
                    g /= neighborCount;
                    b /= neighborCount;
    
                    // Apply decay factors
                    r = r * 0.99 - 1;
                    g = g * 0.99 - 1;
                    b = b * 0.99 - 1;
    
                    // Calculate current pixel index
                    const i = getIndex(x, y);
    
                    // Combine original and dissipated values with decay
                    dst[i] = ((src[i] * dissipate1) + (r * dissipate2)) * finalMultiplier;
                    dst[i + 1] = ((src[i + 1] * dissipate1) + (g * dissipate2)) * finalMultiplier;
                    dst[i + 2] = ((src[i + 2] * dissipate1) + (b * dissipate2)) * finalMultiplier;
                    dst[i + 3] = src[i + 3]; // Keep alpha channel unchanged
                }
            }
    
            // Update the pixel data
            pixelData.data.set(dst);
            return pixelData;
    
        } else {
    
    
            // Create a lookup table for the neighbors to avoid recalculating in the inner loop
            const neighbors = [];
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    neighbors.push([dx, dy]);
                }
            }
            const neighborCount = neighbors.length;
    
            function getIndex(x, y) {
                // Only return valid index if within bounds
                if (x >= 0 && x < width && y >= 0 && y < height) {
                    return (y * width + x) * 4;
                }
                // Return -1 or throw an error if out of bounds
                return -1; // Or alternatively throw new Error("Coordinates out of bounds");
            }
            // Process each pixel
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0,
                        g = 0,
                        b = 0;
    
                    // Sample the neighborhood
                    for (let i = 0; i < neighborCount; i++) {
                        const [dx, dy] = neighbors[i];
                        const ni = getIndex(x + dx, y + dy);
    
                        if (ni != -1) {
                            r += src[ni];
                            g += src[ni + 1];
                            b += src[ni + 2];
                        }
                    }
    
                    // Average the values
                    r /= neighborCount;
                    g /= neighborCount;
                    b /= neighborCount;
    
                    // Apply decay factors
                    r = r * 0.99 - 1;
                    g = g * 0.99 - 1;
                    b = b * 0.99 - 1;
    
                    // Calculate current pixel index
                    const i = getIndex(x, y);
    
                    // Combine original and dissipated values with decay
                    if (i != -1) {
                        dst[i] = ((src[i] * dissipate1) + (r * dissipate2)) * finalMultiplier;
                        dst[i + 1] = ((src[i + 1] * dissipate1) + (g * dissipate2)) * finalMultiplier;
                        dst[i + 2] = ((src[i + 2] * dissipate1) + (b * dissipate2)) * finalMultiplier;
                        dst[i + 3] = src[i + 3]; // Keep alpha channel unchanged
    
                    }
                }
            }
    
            // Update the pixel data
            pixelData.data.set(dst);
            return pixelData;
    
        }
    }
    
    function dissipateAndDecayMultiple(pixelDataArray, width, height, decay = 0.96, dissipateFactor = 0.2, radius = 1) {
        const w4 = width * 4;
        const numLayers = pixelDataArray.length;
        const output = [];
    
        // Cache the neighborhood offsets once
        const offsets = [];
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const dist2 = dx * dx + dy * dy + 1;
                const weight = 1 / 1; // uniform weighting, change if needed
                offsets.push({
                    dx,
                    dy,
                    weight
                });
            }
        }
    
        // For each layer/image
        for (let l = 0; l < numLayers; l++) {
            const src = pixelDataArray[l].data;
            const dst = new Uint8ClampedArray(src.length);
    
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0,
                        g = 0,
                        b = 0,
                        count = 0;
    
                    for (const {
                            dx,
                            dy,
                            weight
                        }
                        of offsets) {
                        let nx = (x + dx + width) % width;
                        let ny = (y + dy + height) % height;
                        const ni = (ny * width + nx) * 4;
    
                        r += src[ni] * weight;
                        g += src[ni + 1] * weight;
                        b += src[ni + 2] * weight;
                        count += weight;
                    }
    
                    r = (r / count) * 0.98 - 1;
                    g = (g / count) * 0.98 - 1;
                    b = (b / count) * 0.98 - 1;
    
                    const i = (y * width + x) * 4;
                    dst[i] = (((src[i] * (1 - (dissipateFactor - 0.5))) + (r * (dissipateFactor + 0.60))) * decay) * 0.53;
                    dst[i + 1] = (((src[i + 1] * (1 - (dissipateFactor - 0.5))) + (g * (dissipateFactor + 0.60))) * decay) * 0.53;
                    dst[i + 2] = (((src[i + 2] * (1 - (dissipateFactor - 0.5))) + (b * (dissipateFactor + 0.60))) * decay) * 0.53;
                    dst[i + 3] = src[i + 3]; // Preserve alpha
                }
            }
    
            const outputImage = new ImageData(dst, width, height);
            output.push(outputImage);
        }
    
        return output;
    }
    
    
    
    class DumbDot {
        constructor(x, y, r, a) {
            this.x = x
            this.y = y
            this.radius = r
            this.angle = a
            this.link = new LineOPR(this, this)
            this.link2 = new LineOP(this, this)
        }
        draw() {
    
            canvas_context.beginPath();
            canvas_context.lineWidth = this.radius * .3
            canvas_context.arc(this.x, this.y, (this.radius * .85), -.5, (+.5), true)
            canvas_context.strokeStyle = "#889988"
            canvas_context.stroke();
            canvas_context.closePath();
            this.topy = new CircleCap(this.x - (Math.cos(Math.PI - .5) * (this.radius * .9)), this.y - (Math.sin(Math.PI - .5) * (this.radius * .9)), this.radius * .2, "#889988")
    
            this.topy.draw()
            this.topz = new CircleCap(this.x - (Math.cos(Math.PI + .5) * (this.radius * .9)), this.y - (Math.sin(Math.PI + .5) * (this.radius * .9)), this.radius * .2, "#889988")
    
            this.topz.draw()
        }
        check(point) {
    
            if (true) {
                this.link2.object = this.topz
    
                this.link2.target = point
                let h = this.link2.hypotenuse()
                let a = this.link2.angle() + Math.PI
                let j = 0
                while (h < this.radius * .2) {
                    j++
                    if (j > 10) {
                        break
                    }
                    h = this.link2.hypotenuse()
                    point.x += Math.cos(a) * 2
                    point.y += Math.sin(a) * 2
                    point.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                }
    
            }
            if (true) {
                this.link2.object = this.topy
                this.link2.target = point
                let h = this.link2.hypotenuse()
                let a = this.link2.angle() + Math.PI
    
                let j = 0
                while (h < this.radius * .2) {
                    j++
                    if (j > 10) {
                        break
                    }
                    h = this.link2.hypotenuse()
                    point.x += Math.cos(a) * 2
                    point.y += Math.sin(a) * 2
                    point.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                }
    
            }
    
    
    
            if (true) {
    
                this.link.object = this
                this.link.target = point
                let h = this.link.hypotenuse()
                let a = this.link.angle() + Math.PI
    
                if ((a + Math.PI).between(Math.PI - .5, Math.PI + .5)) {
    
                } else if ((a - Math.PI).between(Math.PI - .5, Math.PI + .5)) {
    
                } else {
                    if (h < this.radius * .7) {
    
                    } else {
                        if (h >= this.radius * .7) {
    
                            if (h <= (this.radius * .85)) {
                                point.x = ((Math.cos(a) * (this.radius * .7)) + this.x) + (point.x - point.xavg)
                                point.y = ((Math.sin(a) * (this.radius * .7)) + this.y) + (point.y - point.yavg)
                                point.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                            } else if (h <= this.radius) {
                                if (h >= this.radius * .85) {
                                    point.x = ((Math.cos(a) * (this.radius * 1.01)) + this.x) + (point.x - point.xavg)
                                    point.y = ((Math.sin(a) * (this.radius * 1.01)) + this.y) + (point.y - point.yavg)
                                    point.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                                }
                            }
    
                        } else if (h <= this.radius) {
                            if (h >= this.radius * .85) {
                                point.x = ((Math.cos(a) * (this.radius * 1.01)) + this.x) + (point.x - point.xavg)
                                point.y = ((Math.sin(a) * (this.radius * 1.01)) + this.y) + (point.y - point.yavg)
                                point.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                            }
                        }
    
                    }
    
    
                }
    
            }
    
    
            if (true) {
    
                point.link.target = this
                let h = point.link.hypotenuse()
                let a = point.link.angle()
    
                if ((a + Math.PI).between(Math.PI - .5, Math.PI + .5)) {
    
                } else {
                    if (h < this.radius * .7) {
    
                    } else {
                        if (h >= this.radius * .7) {
    
                            if (h <= this.radius * .85) {
                                point.x = (Math.cos(a) * (this.radius * .7)) + this.x
                                point.y = (Math.sin(a) * (this.radius * .7)) + this.y
                                point.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                            } else if (h <= this.radius) {
                                if (h >= this.radius * .85) {
                                    point.x = (Math.cos(a) * (this.radius * 1.01)) + this.x
                                    point.y = (Math.sin(a) * (this.radius * 1.01)) + this.y
                                    point.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                                }
                            }
    
                        } else if (h <= this.radius) {
                            if (h >= this.radius * .85) {
                                point.x = (Math.cos(a) * (this.radius * 1.01)) + this.x
                                point.y = (Math.sin(a) * (this.radius * 1.01)) + this.y
                                point.pushout += Math.PI / (((seedRandom() - .5) * 4) + .01)
                            }
                        }
    
                    }
    
    
                }
    
            }
        }
    }
    
    function scalePixelData20x(originalImageData, scale) {
        const originalWidth = originalImageData.width;
        const originalHeight = originalImageData.height;
        const scaledWidth = originalWidth * scale;
        const scaledHeight = originalHeight * scale;
    
        const tempCanvas = new OffscreenCanvas(originalWidth, originalHeight);
        // canvas_context.putImageData(originalImageData,0,0)
        const tempCtx = tempCanvas.getContext("2d", { willReadFrequently: true })
        tempCtx.fillStyle = "Red"
    
    
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height)
        tempCtx.putImageData(originalImageData, 0, 0);
    
        const finalCanvas = new OffscreenCanvas(scaledWidth, scaledHeight);
        const finalCtx = finalCanvas.getContext("2d", { willReadFrequently: true })
    
        // finalCtx.fillStyle = getRandomColor()
        finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height)
        // Optional: Disable smoothing for pixelated look
        canvas_context.imageSmoothingEnabled = true;
        // canvas_context.imageSmoothingEnabled = false;
    
        // Draw scaled version
        canvas_context.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, scaledWidth, scaledHeight);
    
        // let fs = finalCtx.getImageData(0, 0, scaledWidth, scaledHeight);
        // // ////////////////console.log(fs)
        // return fs
    }
    
    
    
    function averagePixelDataArray(pixelDataArray, width, height) {
        const finalData = new Uint8ClampedArray(width * height * 4);
        const numLayers = pixelDataArray.length;
        const numPixels = width * height;
    
        for (let i = 0; i < numPixels; i++) {
            const index = i * 4;
            let sumR = 0,
                sumG = 0,
                sumB = 0,
                sumA = 0;
    
            for (let layer = 0; layer < numLayers; layer++) {
                sumR += pixelDataArray[layer].data[index];
                sumG += pixelDataArray[layer].data[index + 1];
                sumB += pixelDataArray[layer].data[index + 2];
                sumA += pixelDataArray[layer].data[index + 3];
            }
    
            //   ////////////////console.log(sumR, sumG, sumB)
            finalData[index] = sumR;
            finalData[index + 1] = sumG;
            finalData[index + 2] = sumB;
            finalData[index + 3] = 255;
        }
    
        return new ImageData(finalData, width, height);
    }
    
    
    function weightedAverageAngle(angles, magnitudes) {
        if (angles.length !== magnitudes.length || angles.length === 0) {
            throw new Error("angles and magnitudes must be the same length and non-empty");
        }
    
        let sumX = 0;
        let sumY = 0;
    
        for (let i = 0; i < angles.length; i++) {
            let angle = angles[i];
            let magnitude = magnitudes[i];
    
            sumX += Math.cos(angle) * magnitude;
            sumY += Math.sin(angle) * magnitude;
        }
    
        return Math.atan2(sumY, sumX); // Returns the average angle in radians
    }
    
    
    let dumbby = new DumbDot(canvas.width * .25, canvas.height * .25, 150, 1)
    
    
    
    
    function seedRandom() {
        return Math.random()
    }
    
    //    ////////////////console.log(rands)
    
    let bucksnap = []; // 1D array of arrays
    
    function F1(){
        globlinker = {}
        relationView = false
    
        if (keysPressed['n']) {
            magnetonly *= -1
            keysPressed['n'] = false
        }
    
        // if(keysPressed['y']){
        //     magnetzoom = 1
        //     keysPressed['y'] = false
        // }
        if (keysPressed['5']) {
            magnetzoom = -1
            keysPressed['5'] = false
        }
    
    
        if (keysPressed['s']) {
            // slide *= -1
    
            // keysPressed['s'] = false
        }
    
        if (keysPressed['t']) {
            viewStyle = 1
            for (let t = 0; t < globalnodes.length; t++) {
                globalnodes[t].firsty = 0
            }
        }
        if (keysPressed['k']) {
            viewStyle = 0
            for (let t = 0; t < globalnodes.length; t++) {
                globalnodes[t].firsty = 0
            }
        }
        if (keysPressed['0']) {
            viewStyle = 6
            for (let t = 0; t < globalnodes.length; t++) {
                globalnodes[t].firsty = 0
            }
        }
        if (keysPressed['1']) {
            viewStyle = 7
            for (let t = 0; t < globalnodes.length; t++) {
                globalnodes[t].firsty = 0
            }
        }
        if (keysPressed['u']) {
            viewStyle = 2
            for (let t = 0; t < globalnodes.length; t++) {
                globalnodes[t].firsty = 0
            }
        }
        // if(keysPressed['f']){
        //     viewStyle = 3
        //     canvas_context.fillStyle= "black"
        //     canvas_context.fillRect(0,0,canvas.width,canvas.height)
        //     for(let t = 0;t<globalnodes.length;t++){
        //         globalnodes[t].firsty = 0
        //     }
        // }
        if (keysPressed['j']) {
            viewStyle = 4
            for (let t = 0; t < globalnodes.length; t++) {
                globalnodes[t].firsty = 0
            }
        }
        if (keysPressed['q']) {
            viewStyle = 5
            for (let t = 0; t < globalnodes.length; t++) {
                globalnodes[t].firsty = 0
            }
        }
        if (keysPressed['q']) {
            metricsON = 1
        }
        if (keysPressed['V']) {
            metricsON = 0
        }
        if (keysPressed['W']) {
            let metrics = {}
            metrics.tick = 100
            metrics.time = 0
            metrics.species = []
            metrics.complexity = []
            metrics.mincomplexity = []
            metrics.maxcomplexity = []
            metrics.diversity = []
            metrics.nodepopulation = []
            metrics.population = []
        }
        if (keysPressed['7']) {
            // relationView = true
        }
        if (keysPressed['8']) {
            dumbdoton *= -1
            keysPressed['8'] = false
        }
        if (keysPressed['=']) {
            // iconsview *= -1
            // keysPressed['='] = false
        }
    
        if (keysPressed['Escape']) {
            start = 0
            signal = 0
            nodein = []
            globalnodes = []
            globduper = []
            particles = []
            globsounds = []
            if (keysPressed[' ']) {
                randomcounter = 1
            }
            return true
        }
        return false
    }
    
    function F2(){
        for (let t = 0; t < globalnodes.length; t++) {
            // if (globalnodes[t].head == 1 && globalnodes[t].trueage > 2) {
                let x = 0
                let y = 0
                for(let g = 0;g<globalnodes[t].immune.length;g++){
                    if(globalnodes[globalnodes[t].immune[g]]){
                   x+=  globalnodes[globalnodes[t].immune[g]].x
                   y+=  globalnodes[globalnodes[t].immune[g]].y
                    }
                }
                x/=Math.floor(globalnodes[t].immune.length*1)
                y/=Math.floor(globalnodes[t].immune.length*1)
    
                for(let g = 0;g<globalnodes[t].immune.length;g++){
                    if(globalnodes[globalnodes[t].immune[g]]){
                globalnodes[globalnodes[t].immune[g]].xavg = x
                globalnodes[globalnodes[t].immune[g]].yavg = y
                    }
                }
                globalnodes[t].xavg = x
                globalnodes[t].yavg = y
            // }
        }
    }
    function F3(){
        for (let t = 0; t < globalnodes.length; t++) {
            if (globalnodes[t].lockon == 1 && (pu.freemove == 1 || keysPressed['6'] || (pu.grab == 1 && pu.grab2 == 1))) {
    
                if (pu.freemove == 1) {
    
                } else {
                    pu.potential -= Math.abs((globalnodes[t].x - (((TIP_engine.x / zoom)) - (globalnodes[t].xavg - globalnodes[t].x))) / worldscale)
                    pu.potential -= Math.abs((globalnodes[t].y - (((TIP_engine.y / zoom)) - (globalnodes[t].yavg - globalnodes[t].y))) / worldscale)
    
                }
    
                
                globalnodes[t].x = ((TIP_engine.x / zoom)) - (globalnodes[t].xavg - globalnodes[t].x) //- globalnodes[t].xavg)-globalnodes[t].x
                globalnodes[t].y = ((TIP_engine.y / zoom)) - (globalnodes[t].yavg - globalnodes[t].y) // - globalnodes[t].yavg)-globalnodes[t].y
          
                globalnodes[t].xavg = TIP_engine.x//- globalnodes[t].xavg)-globalnodes[t].x
                globalnodes[t].yavg = TIP_engine.y
            }
        }
    }
    function F4(){
    
    
        for (let t = 0; t < globalnodes.length; t++) {
            if (globalnodes[t].nearestmouse == 1) {
                if (keysPressed['f'] || (pu.checked == 1 && pu.feed == 1)) {
                  pu.checked = -1
                    if (pu.freemove == 1) {} else {
                        pu.potential -= .5
                    }
                    globalnodes[t].energy += repconstant/1.8 
                    keysPressed['f'] = false
                }
                if (keysPressed['x']|| (pu.checked == 1 && pu.kill == 1)) {
    
                    if (pu.freemove == 1) {} else {
                        pu.potential -= 5
                    }
                    globalnodes[t].dead = 1
                    keysPressed['x'] = false
                }
                if (keysPressed['y'] || (pu.gumblo == 1 && pu.checked == 1)) {
                  pu.checked = -1
                    keysPressed['y'] = false
                    if (pu.freemove == 1) {} else {
                        if (Math.min(pu.potential, pu.betmax) > 1) {
                            pu.wordballs.push(new Wordball("Bet Placed: " + Math.min(pu.potential, pu.betmax).toFixed(0), TIP_engine.x, TIP_engine.y, globalnodes[t]))
                            globalnodes[t].bet += Math.min(pu.potential, pu.betmax)
                            pu.potential -= Math.min(pu.potential, pu.betmax)
                        }
                    }
    
                }
            }
        }
    }
    
    function F5(){
    
    
        worldscaler = worldscale / 8
        // timerresize++
        if (timerresize % 100 == 1) {
    
        }else{} if (timerresize % 100 == 0) {
      
             timerresize = 1
    
    
    
            canvas.width = document.documentElement.clientWidth;
            canvas.height = document.documentElement.clientHeight;
            canvas.width = Math.max(1, Math.floor(canvas.width / smellScaler) * smellScaler)
            canvas.height = Math.max(1, Math.floor(canvas.height / smellScaler) * smellScaler)
            // ////////////////console.log("Weh") 
            if (canvas.width > 0) {
                if (canvas.height > 0) {
                    //////console.log("Weh")
    
                    pix1 = canvas_context.getImageData(0, 0, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler))
                    pix2 = canvas_context.getImageData(0, 0, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler))
                    pix3 = canvas_context.getImageData(0, 0, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler))
                    pix4 = canvas_context.getImageData(0, 0, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler))
                    pix5 = canvas_context.getImageData(0, 0, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler))
                    pix6 = canvas_context.getImageData(0, 0, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler))
                }
            }
            for (let t = 0; t < pix1.data.length; t += 4) {
                pix1.data[t + 3] = 255
                pix2.data[t + 3] = 255
                pix3.data[t + 3] = 255
                pix4.data[t + 3] = 255
                pix5.data[t + 3] = 255
                pix6.data[t + 3] = 255
            }
    
    
            globuckets =[]
            let id = 0
    
            let tmax = Math.ceil(canvas.width/bucketsize)
            let kmax = Math.ceil(canvas.height/bucketsize)
    
            let w = (Math.ceil(canvas.width/bucketsize)+1)*bucketsize
            let h = (Math.ceil(canvas.height/bucketsize)+1)*bucketsize
            let w1 = (Math.ceil(canvas.width/bucketsize)+1)*1
            let h1 = (Math.ceil(canvas.height/bucketsize)+1)*1
    
            for(let t =0;t<w1;t+=1){
                globuckets.push([])
                ////////////////console.log(t,1)
                for(let k =0;k<h1;k+=1){
                    globuckets[Math.floor(t/1)].push({})
                }
            }
    
    
            for(let t =0;t<w1;t+=1){
                for(let k =0;k<h1;k+=1){
                    // //////console.log(Math.floor(t/1),Math.floor(k/1))
                    let mm  =  globuckets[Math.floor(t/1)][Math.floor(k/1)]
                    mm.range = []
                    for(let f = -1;f<2;f++){
                        for(let g = -1;g<2;g++){
                            let tke = ((f+Math.floor(t/1))+tmax)%tmax
                            let kte = ((g+Math.floor(k/1))+kmax)%kmax
                            mm.range.push([tke,kte])
                        }
                    }
                    mm.range2 = []
                    for(let f = -2;f<3;f++){
                        for(let g = -2;g<3;g++){
                            let tke = ((f+Math.floor(t/1))+tmax)%tmax
                            let kte = ((g+Math.floor(k/1))+kmax)%kmax
                            mm.range2.push([tke,kte])
                        }
                    }
                    mm.guys = []
                    mm.id = id
                    mm.idt = Math.floor(t/1)
                    mm.idk = Math.floor(k/1)
                    // mm.rect = new Rectangle(t*bucketsize,k*bucketsize,bucketsize,bucketsize,getRandomDarkColor())
                    id++
    
                }
            }
    
            // humanpix1 = canvas_context.getImageData(0,0,Math.floor(canvas.width/10),Math.floor(canvas.height/10))
            // humanpix2 = canvas_context.getImageData(0,0,Math.floor(canvas.width/10),Math.floor(canvas.height/10))
            // humanpix3 = canvas_context.getImageData(0,0,Math.floor(canvas.width/10),Math.floor(canvas.height/10))
            // humanpix4 = canvas_context.getImageData(0,0,Math.floor(canvas.width/10),Math.floor(canvas.height/10))
            // humanpix5 = canvas_context.getImageData(0,0,Math.floor(canvas.width/10),Math.floor(canvas.height/10))
            // humanpix6 = canvas_context.getImageData(0,0,Math.floor(canvas.width/10),Math.floor(canvas.height/10))
    
    
            // pix2 = canvas_context.getImageData(0,0,canvas.width,canvas.height)
            // pix3 = canvas_context.getImageData(0,0,canvas.width,canvas.height)
            // pix4 = canvas_context.getImageData(0,0,canvas.width,canvas.height)
            // pix5 = canvas_context.getImageData(0,0,canvas.width,canvas.height)
    
            if (dumbdoton == 1) {
                dumbby.x = canvas.width / (zoom * 2)
                dumbby.y = canvas.height / (zoom * 2)
                dumbby.radius = Math.min(dumbby.x / 1.4, dumbby.y / 1.4)
            }
    
        }
    
    }
    function F6(){
        rotatick++
        // ////////////////console.log(rotatick)
        if (rotatick >= rotaspeed) {
            rotatick = 0
            rota++
            // ////////////////console.log(rota)
            if (rota % rotaclickover == 0) {
                viewrota.sort((a, b) => Math.random() > .5 ? 1 : -1)
            }
        }
    }
    function F7(){
        
        bodc = 0
        canvas_context.font = `${worldscale*1.4}px arial`
        canvas_context.fillStyle = "black"
        if (viewStyle != 3) {
    
    
            if (smellFlip == 1) {
    
                canvas_context.fillStyle = "#00000020"
    
                // if (smellTime % (smellMax * 5) == 0 ) {//&& cyclock == 0
                    if (smellTime % (smellMax * 50) == 0 && cyclock == 0) {
                    cycler++
                    cycler %= 6
    
                }
    
                smellTime++
    
                // let ins = [pix1, pix1, pix3,pix4,pix5,pix6 ]
                // if(smellTime%smellMax == 0){
    
                //     let mult = dissipateAndDecayMultiple(ins,Math.floor(canvas.width/10), Math.floor(canvas.height/10), .8, .5, 1)
    
                //     pix1 = mult[0]
                //     pix2 = mult[1]
                //     pix3 = mult[2]
                //     pix4 = mult[3]
                //     pix5 = mult[4]
                //     pix6 = mult[5]
                // }
    
                if (smellTime % smellMax == 0) { //scaling was the problem
                    pix1 = dissipateAndDecay(pix1, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler), .90012345, .5, 1)
                    pix2 = dissipateAndDecay(pix2, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler), .90012345, .5, 1)
                    pix3 = dissipateAndDecay(pix3, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler), .90012345, .5, 1)
                    pix4 = dissipateAndDecay(pix4, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler), .90012345, .5, 1)
                    pix5 = dissipateAndDecay(pix5, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler), .90012345, .5, 1)
                    pix6 = dissipateAndDecay(pix6, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler), .90012345, .5, 1)
                }
    
                if(edgeLoop == 1){
                    if(keysPressed['w']||keysPressed['a']||keysPressed['s']||keysPressed['d']){
                        pix1 = shiftPixels(pix1, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler))
                        pix2 = shiftPixels(pix2, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler))
                        pix3 = shiftPixels(pix3, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler))
                        pix4 = shiftPixels(pix4, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler))
                        pix5 = shiftPixels(pix5, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler))
                        pix6 = shiftPixels(pix6, Math.floor(canvas.width / smellScaler), Math.floor(canvas.height / smellScaler))
                    }
                }
    
    
    
    
                
                //    humanpix1 = dissipateAndDecay(humanpix1, Math.floor(canvas.width/10), Math.floor(canvas.height/10), .9, .5, 1)
                //    humanpix2 = dissipateAndDecay(humanpix2, Math.floor(canvas.width/10), Math.floor(canvas.height/10), .9, .5, 1)
                //    humanpix3 = dissipateAndDecay(humanpix3, Math.floor(canvas.width/10), Math.floor(canvas.height/10), .9, .5, 1)
                //    humanpix4 = dissipateAndDecay(humanpix4, Math.floor(canvas.width/10), Math.floor(canvas.height/10), .9, .5, 1)
                //    humanpix5 = dissipateAndDecay(humanpix5, Math.floor(canvas.width/10), Math.floor(canvas.height/10), .9, .5, 1)
                //    humanpix6 = dissipateAndDecay(humanpix6, Math.floor(canvas.width/10), Math.floor(canvas.height/10), .9, .5, 1)
    
    
                //   let totalhumo =  averagePixelDataArray([humanpix1,humanpix2,humanpix3, humanpix4, humanpix5, humanpix6], Math.floor(canvas.width/10), Math.floor(canvas.height/10))
    
                //   ////////////////console.log(totalhumo, humanpix1)
    
                //    overlayPixelDataArray([humanpix1,humanpix2,humanpix3, humanpix4, humanpix5, humanpix6], Math.floor(canvas.width/10), Math.floor(canvas.height/10))
    
    
                canvas_context.fillRect(0, 0, canvas.width, canvas.height)
    
                if (keysPressed[']']) {
    
                    // canvas_context.putImageData(scalePixelData20x(totalhumo, 10),0,0)
                    // canvas_context.putImageData(scalePixelData20x(humanpix1, smellScaler),0,0)
                    // canvas_context.putImageData(scalePixelData20x(humanpix2, smellScaler),0,0)
                    // canvas_context.putImageData(scalePixelData20x(humanpix3, smellScaler),0,0)
                    // canvas_context.putImageData(scalePixelData20x(humanpix4, smellScaler),0,0)
                    // canvas_context.putImageData(scalePixelData20x(humanpix5, smellScaler),0,0)
                    // canvas_context.putImageData(scalePixelData20x(humanpix6, smellScaler),0,0)
                } else {
    
                    if (!keysPressed[';']) {
    
                        if (keysPressed['!'] || cycler == 0) {
                            cycler = 0
                            cyclock = 1
                            // canvas_context.putImageData(0,0)
                            scalePixelData20x(pix1, smellScaler)
                        }
    
                        if (keysPressed['@'] || cycler == 1) {
                            cycler = 1
    
                            cyclock = 1
                            // canvas_context.putImageData(scalePixelData20x(pix2, smellScaler),0,0)
                            scalePixelData20x(pix2, smellScaler)
                        }
    
                        if (keysPressed['#'] || cycler == 2) {
    
                            cycler = 2
                            cyclock = 1
                            // canvas_context.putImageData(scalePixelData20x(pix3, smellScaler),0,0)
                            scalePixelData20x(pix3, smellScaler)
    
                        }
    
                        if (keysPressed['$'] || cycler == 3) {
    
                            cycler = 3
                            cyclock = 1
                            // canvas_context.putImageData(scalePixelData20x(pix4, smellScaler),0,0)
                            scalePixelData20x(pix4, smellScaler)
    
                        }
                        if (keysPressed['%'] || cycler == 4) {
                            cycler = 4
                            cyclock = 1
                            // canvas_context.putImageData(scalePixelData20x(pix5, smellScaler),0,0)
                            scalePixelData20x(pix5, smellScaler)
    
                        }
                        if (keysPressed['^'] || cycler == 5) {
                            cycler = 5
                            cyclock = 1
                            // canvas_context.putImageData(scalePixelData20x(pix6, smellScaler),0,0)
                            scalePixelData20x(pix6, smellScaler)
    
                        }
    
                    } else {
    
                        if (keysPressed['!'] || cycler == 0) {
                            cycler = 0
    
                            // canvas_context.putImageData(scalePixelData20x(humanpix1, 10),0,0)
                        }
    
                        if (keysPressed['@'] || cycler == 1) {
                            cycler = 1
    
                            // canvas_context.putImageData(scalePixelData20x(humanpix2, 10),0,0)
                        }
    
                        if (keysPressed['#'] || cycler == 2) {
                            cycler = 2
    
                            // canvas_context.putImageData(scalePixelData20x(humanpix3, 10),0,0)
                        }
    
                        if (keysPressed['$'] || cycler == 3) {
                            cycler = 3
    
                            // canvas_context.putImageData(scalePixelData20x(humanpix4, 10),0,0)
                        }
                        if (keysPressed['%'] || cycler == 4) {
    
                            cycler = 4
    
                            // canvas_context.putImageData(scalePixelData20x(humanpix5, 10),0,0)
                        }
    
                        if (keysPressed['^'] || cycler == 5) {
                            cycler = 5
                            // canvas_context.putImageData(scalePixelData20x(humanpix6, 10),0,0)
                        }
                    }
                }
    
            } else {
                canvas_context.fillRect(0, 0, canvas.width, canvas.height)
    
            }
        }
    }
    
    function F8(){
        if (start == 0) {
            canvas_context.fillStyle = "white"
            canvas_context.lineWidth = 1
            canvas_context.strokeStyle = "black"
            canvas_context.font = "14px arial"
            canvas_context.strokeText("Pick two or more nodes for a seed organism and click start. Organisms need a production node (green).", 10, 12)
            canvas_context.fillText("Pick two or more nodes for a seed organism and click start. Organisms need a production node (green).", 10, 12)
    
            canvas_context.strokeText("Mutation Rate: " + (Math.round(mutationrate * 10000) / 100) + "%", 10, 575 + (-15))
            canvas_context.fillText("Mutation Rate: " + (Math.round(mutationrate * 10000) / 100) + "%", 10, 575 + (-15))
            // canvas_context.fillText("Nodes:", 300, 300+(-15))
            canvas_context.strokeText("H can be used to see energy levels, E for age, R for complexity.", 10, 552 + 45)
            canvas_context.fillText("H can be used to see energy levels, E for age, R for complexity.", 10, 552 + 45)
    
    
            canvas_context.strokeText("Q, T, U, J, 1, 0, 2, N, 7, and K are different visualization modes.", 10, 582 + 45)
            canvas_context.fillText("Q, T, U, J, 1, 0, 2, N, 7, and K are different visualization modes.", 10, 582 + 45)
            canvas_context.strokeText("Use 6 to pick up an organism. With 6 held, F to feed, X to kill.", 10, 612 + 45)
            canvas_context.fillText("Use 6 to pick up an organism. With 6 held, F to feed, X to kill.", 10, 612 + 45)
            canvas_context.strokeText("O/P are for speed. 3 to dupe nearest organism. M to hide play", 10, 642 + 45)
            canvas_context.fillText("O/P are for speed. 3 to dupe nearest organism. M to hide play", 10, 642 + 45)
            canvas_context.strokeText("Escape will end the round, returning you to the main menu.", 10, 672 + 45)
            canvas_context.fillText("Escape will end the round, returning you to the main menu.", 10, 672 + 45)
    
    
    
            canvas_context.fillStyle = "white"
            canvas_context.lineWidth = 1
            canvas_context.strokeStyle = "black"
            canvas_context.font = "15px arial"
    
            canvas_context.strokeText("Chosen Nodes:", 45, 760 + (-16))
            canvas_context.fillText("Chosen Nodes:", 45, 760 + (-16))
            for (let t = 0; t < nodein.length; t++) {
    
    
                canvas_context.fillStyle = nodecolors[[nodein[t]]]
    
                canvas_context.strokeText(types[nodein[t]], 45, 760 + (t * 16))
                canvas_context.fillText(types[nodein[t]], 45, 760 + (t * 16))
    
    
            }
    
    
            // edgebutt.draw()
            // if(edgeLoop != 1){
            //     looptext = "no loop"
            //     edgebutt.color = "Yellow"
            // }else{
            //     looptext = "loop"
            //     edgebutt.color = "white"
            // }
            canvas_context.strokeStyle = "black"
            canvas_context.font = "14px arial"
            // canvas_context.fillText(looptext, edgebutt.x+20, edgebutt.y+20)
    
    
            UI.draw()
            UI.subcheck(TIP_engine)
    
    
    
    
            if (signal == 1) {
                if (nodein.length >= 2) {
                    init(nodein)
                    start = 1
                } else {
                    signal = 0
                }
            } else {
    
            }
            canvas_context.drawImage(buttons, 128,0,128,135, TIP_engine.x-7, TIP_engine.y-7, 14,14)
            return true
        }
        return false
    }
    
    
    function F9(){
        if (dumbdoton == 1) {
            dumbby.draw()
        }
    }
    
    function F10(){
        if (relationView) {
            let bucketOseenx = {}
            for (let t = 0; t < globalnodes.length; t++) {
                if (bucketOseenx[globalnodes[t].contextMarker] == 1) {
                } else {
                    bucketOseenx[globalnodes[t].contextMarker] = 1
                    let cn = canvasList[globalnodes[t].contextMarker]
                    let tn = contextList[globalnodes[t].contextMarker]
                    cn.width = canvas.width
                    cn.height = canvas.height
                    tn.clearRect(0, 0, cn.width, cn.height)
                }
            }
        }
    }
    function F11(){
        ld = 0
        seenToday = {}
         mindead = 0
         lock = 0
         makdead = 0
        for (let t = 0; t < globalnodes.length; t++) {
    
            if (globalnodes[t].dead == 1) {
                if (lock == 0) {
                    // mindead = t //huh
                    makdead = t
                }
                continue
            }
            lock = 1
            globalnodes[t].time()
            if (relationView) {
                globalnodes[t].freakmap()
            }
            globalnodes[t].freeenergy()
        }
    }
    let lock = 0
    let makdead = 0
    
    function F12(){
    
    
        if (freeEnergyOn == -1) {
    
            freec = freen
        } else {
    
            freec = freen
            for (let t = makdead; t < globalnodes.length; t++) {
                if(globalnodes[t].dead == 1){
                    continue
                }
                freec -= globalnodes[t].energy
                freec -= repconstant
            }
    
        }
    
    
    
    }
    
    function F13(){
    
    
        for (let t = 0; t < globalnodes.length; t++) {
            if (globalnodes[t].dead == 1) {
                continue
            }
            globalnodes[t].drive()
            globalnodes[t].link.mark = 0
            globalnodes[t].link.list = []
    
        }

        if(soundFlip == 1){

            if (smellFlip == 1) {
                for (let t = mindead; t < globalnodes.length; t++) {
                    if (globalnodes[t].dead == 1) {
                        continue
                    }
                    globalnodes[t].makeNose()
                globalnodes[t].makeEar()
        
                globalnodes[t].makeRotation()
                globalnodes[t].makePiston()
                // globalnodes[t].makeLink()
            }
            for (let t = mindead; t < globalnodes.length; t++) {
                if (globalnodes[t].dead == 1) {
                    continue
                }
            globalnodes[t].makeLink()
        }
        }else{
        
            for (let t = mindead; t < globalnodes.length; t++) {
                if (globalnodes[t].dead == 1) {
                    continue
                }
                // globalnodes[t].makeNose()
                globalnodes[t].makeEar()
            globalnodes[t].makeRotation()
            globalnodes[t].makePiston()
            // globalnodes[t].makeLink()
        }
    
    
        for (let t = mindead; t < globalnodes.length; t++) {
            if (globalnodes[t].dead == 1) {
                continue
            }
        globalnodes[t].makeLink()
        }
        }
        }else{

        if (smellFlip == 1) {
            for (let t = mindead; t < globalnodes.length; t++) {
                if (globalnodes[t].dead == 1) {
                    continue
                }
                globalnodes[t].makeNose()
            // globalnodes[t].makeEar()
    
            globalnodes[t].makeRotation()
            globalnodes[t].makePiston()
            // globalnodes[t].makeLink()
        }
        for (let t = mindead; t < globalnodes.length; t++) {
            if (globalnodes[t].dead == 1) {
                continue
            }
        globalnodes[t].makeLink()
    }
    }else{
    
        for (let t = mindead; t < globalnodes.length; t++) {
            if (globalnodes[t].dead == 1) {
                continue
            }
            // globalnodes[t].makeNose()
            // globalnodes[t].makeEar()
        globalnodes[t].makeRotation()
        globalnodes[t].makePiston()
        // globalnodes[t].makeLink()
    }


    for (let t = mindead; t < globalnodes.length; t++) {
        if (globalnodes[t].dead == 1) {
            continue
        }
    globalnodes[t].makeLink()
    }
    }
        }
    }
    
    function F14(){
        for (let t = mindead; t < globalnodes.length; t++) {
            globalnodes[t].x += globalnodes[t].xleap
            globalnodes[t].y += globalnodes[t].yleap
            globalnodes[t].lastx += globalnodes[t].xleap
            globalnodes[t].lasty += globalnodes[t].yleap
    
            globalnodes[t].xleap = 0
            globalnodes[t].yleap = 0
        }
    }
    
    function MakeUp(){
    
    
        for (let t = 0; t < globduper.length; t++) {
    
            let node
            if (codonusage == 1) {
    
                node = new Node(globduper[t].x, globduper[t].y, geneToType(globduper[t].genestring), globduper[t].genestring)
            } else {
                node = new Node(globduper[t].x, globduper[t].y, globduper[t].type, globduper[t].genestring)
            }
            node.head = 0
            node.radio = globduper[t].radio
            node.extra = globduper[t].extra
            node.charge = globduper[t].charge
            node.magratio = globduper[t].magratio
            node.linkApha = globduper[t].linkApha
            node.head = globduper[t].head
            // if(globalnodes[globduper[t].linkto].cut != 1){
            //////////////////console.log(globduper[t].linkto)
            node.connect(globalnodes[globduper[t].linkto])
            // }
        }
        globduper = []
    
    
        macrodupe = 0
    }
    
    function clearBucket(){
    
    //  let w = (Math.ceil(canvas.width/bucketsize)+1)*bucketsize
    //  let h = (Math.ceil(canvas.height/bucketsize)+1)*bucketsize
        for (let t = 0; t < globuckets.length; t += 1) {
            for (let k = 0; k < globuckets[0].length; k += 1) { 
                let bx = Math.floor(t / 1);
                let by = Math.floor(k / 1);
            bx = Math.min(Math.max(0, bx),globuckets.length-1)
            by = Math.min(Math.max(0, by),globuckets[bx].length-1)
                // let bucket = globuckets[bx][by];
                // bucket.rect.draw()
                globuckets[bx][by].guys = [];
            }
        }
    }
    
    function F15(){
        for (let t = mindead; t < globalnodes.length; t++) {
            if (globalnodes[t].dead == 1) {
                continue
            }
            //relationview '7' "7"
            if (relationView) {
                globalnodes[t].make(contextList[globalnodes[t].contextMarker])
            } else {
                globalnodes[t].make(canvas_context) 
            }
        }
    }
    
    function F16(){
    
    
        let stuporgrab = {}
        for (let t = 0; t < globalnodes.length; t++) {
            if (globalnodes[t].dead == 1) {
                continue
            }
            if (globalnodes[t].link.mark == 1) {
                for (let r = 0; r < globalnodes[t].link.list.length; r++) {
                    if (globalnodes[globalnodes[t].link.list[r]].dead != 1 && globalnodes[t].dead != 1) {
    
                        //////////////////////////////console.log(globalnodes[t].link.list[r])
                        globalnodes[t].link.target = globalnodes[globalnodes[t].link.list[r]]
                        globalnodes[t].link.width = 2 * worldscaler
                        globalnodes[t].link.color = `rgb(${128+ (.5*globalnodes[(globalnodes[t].shead)].r)},${128+ (.5*globalnodes[(globalnodes[t].shead)].g)},${128+ (.5*globalnodes[(globalnodes[t].shead)].b)})`
                        if (magnetonly == 1) { 
    
                        } else {
                            // canvas_context.globalAlpha = globalnodes[t].linkApha 
    
                            //relationview '7' "7"
                            if (relationView) {
                                globalnodes[t].link.draw(contextList[globalnodes[t].contextMarker])
                            } else {
                                if (keysPressed['7'] || pu.seebets == 1) {
                                    if (globalnodes[t].bet > 1) {
    
                                        if (!stuporgrab[`${globalnodes[t].link.list[r]},t`]) {
                                            if(globalnodes[t].link.list.length == 1){
                                                stuporgrab[`${globalnodes[t].link.list[r]},t`] = true
                                            }
                                            globalnodes[t].link.draw(canvas_context)
                                            if (edgeLoop == 1) {
    
                                                if (globalnodes[t].x < 0 || globalnodes[t].x > (canvas.width)) {
                                                    if (globalnodes[t].x < 0) {
                                                        let x1 = globalnodes[t].x
                                                        let x2 = globalnodes[globalnodes[t].link.list[r]].x
                                                        globalnodes[t].x += canvas.width
                                                        globalnodes[globalnodes[t].link.list[r]].x += canvas.width
                                                        globalnodes[t].link.draw(canvas_context)
                                                        globalnodes[globalnodes[t].link.list[r]].x = x2
                                                        globalnodes[t].x = x1
                                                    } else {
    
                                                        // if(globalnodes[globalnodes[t].link.list[r]].x > (canvas.width-worldscale)){
    
                                                        let x1 = globalnodes[t].x
                                                        let x2 = globalnodes[globalnodes[t].link.list[r]].x
                                                        globalnodes[t].x += canvas.width
                                                        globalnodes[globalnodes[t].link.list[r]].x -= canvas.width
                                                        globalnodes[t].x %= canvas.width
                                                        // globalnodes[globalnodes[t].link.list[r]].x %= canvas.width
                                                        globalnodes[t].link.draw(canvas_context)
                                                        globalnodes[globalnodes[t].link.list[r]].x = x2
                                                        globalnodes[t].x = x1
    
                                                        // }else{
    
                                                        //     let x1 = globalnodes[t].x 
                                                        //     let x2 = globalnodes[globalnodes[t].link.list[r]].x 
                                                        //     globalnodes[t].x += canvas.width
                                                        //     globalnodes[globalnodes[t].link.list[r]].x -= canvas.width
                                                        //     globalnodes[t].x %= canvas.width
                                                        //     // globalnodes[globalnodes[t].link.list[r]].x %= canvas.width
                                                        //     globalnodes[t].link.draw(canvas_context)
                                                        //     globalnodes[globalnodes[t].link.list[r]].x = x2
                                                        //     globalnodes[t].x = x1
                                                        // }
                                                    }
                                                }
                                                if (globalnodes[t].y < 0 || globalnodes[t].y > (canvas.height - 0)) {
                                                    if (globalnodes[t].y < 0) {
    
                                                        let y1 = globalnodes[t].y
                                                        let y2 = globalnodes[globalnodes[t].link.list[r]].y
                                                        globalnodes[t].y += canvas.height
                                                        globalnodes[globalnodes[t].link.list[r]].y += canvas.height
                                                        globalnodes[t].link.draw(canvas_context)
                                                        globalnodes[globalnodes[t].link.list[r]].y = y2
                                                        globalnodes[t].y = y1
                                                    } else {
    
    
                                                        let y1 = globalnodes[t].y
                                                        let y2 = globalnodes[globalnodes[t].link.list[r]].y
                                                        globalnodes[t].y += canvas.height
                                                        globalnodes[globalnodes[t].link.list[r]].y -= canvas.height
                                                        globalnodes[t].y %= canvas.height
                                                        // globalnodes[globalnodes[t].link.list[r]].y %= canvas.width
                                                        globalnodes[t].link.draw(canvas_context)
                                                        globalnodes[globalnodes[t].link.list[r]].y = y2
                                                        globalnodes[t].y = y1
    
    
                                                    }
                                                }
                                            }
    
    
                                        } else {
                                            // ////////////////console.log("case")
                                        }
                                    } else {
    
                                    }
    
                                } else {
    
                                    if (!stuporgrab[`${globalnodes[t].link.list[r]},t`]) {
                                        if(globalnodes[t].link.list.length == 1){
                                            stuporgrab[`${globalnodes[t].link.list[r]},t`] = true
                                        }
                                        globalnodes[t].link.draw(canvas_context)
                                        if (edgeLoop == 1) {
    
                                            if (globalnodes[t].x < 0 || globalnodes[t].x > (canvas.width)) {
                                                if (globalnodes[t].x < 0) {
                                                    let x1 = globalnodes[t].x
                                                    let x2 = globalnodes[globalnodes[t].link.list[r]].x
                                                    globalnodes[t].x += canvas.width
                                                    globalnodes[globalnodes[t].link.list[r]].x += canvas.width
                                                    globalnodes[t].link.draw(canvas_context)
                                                    globalnodes[globalnodes[t].link.list[r]].x = x2
                                                    globalnodes[t].x = x1
                                                } else {
    
                                                    // if(globalnodes[globalnodes[t].link.list[r]].x > (canvas.width-worldscale)){
    
                                                    let x1 = globalnodes[t].x
                                                    let x2 = globalnodes[globalnodes[t].link.list[r]].x
                                                    globalnodes[t].x += canvas.width
                                                    globalnodes[globalnodes[t].link.list[r]].x -= canvas.width
                                                    globalnodes[t].x %= canvas.width
                                                    // globalnodes[globalnodes[t].link.list[r]].x %= canvas.width
                                                    globalnodes[t].link.draw(canvas_context)
                                                    globalnodes[globalnodes[t].link.list[r]].x = x2
                                                    globalnodes[t].x = x1
    
                                                    // }else{
    
                                                    //     let x1 = globalnodes[t].x 
                                                    //     let x2 = globalnodes[globalnodes[t].link.list[r]].x 
                                                    //     globalnodes[t].x += canvas.width
                                                    //     globalnodes[globalnodes[t].link.list[r]].x -= canvas.width
                                                    //     globalnodes[t].x %= canvas.width
                                                    //     // globalnodes[globalnodes[t].link.list[r]].x %= canvas.width
                                                    //     globalnodes[t].link.draw(canvas_context)
                                                    //     globalnodes[globalnodes[t].link.list[r]].x = x2
                                                    //     globalnodes[t].x = x1
                                                    // }
                                                }
                                            }
                                            if (globalnodes[t].y < 0 || globalnodes[t].y > (canvas.height - 0)) {
                                                if (globalnodes[t].y < 0) {
    
                                                    let y1 = globalnodes[t].y
                                                    let y2 = globalnodes[globalnodes[t].link.list[r]].y
                                                    globalnodes[t].y += canvas.height
                                                    globalnodes[globalnodes[t].link.list[r]].y += canvas.height
                                                    globalnodes[t].link.draw(canvas_context)
                                                    globalnodes[globalnodes[t].link.list[r]].y = y2
                                                    globalnodes[t].y = y1
                                                } else {
    
    
                                                    let y1 = globalnodes[t].y
                                                    let y2 = globalnodes[globalnodes[t].link.list[r]].y
                                                    globalnodes[t].y += canvas.height
                                                    globalnodes[globalnodes[t].link.list[r]].y -= canvas.height
                                                    globalnodes[t].y %= canvas.height
                                                    // globalnodes[globalnodes[t].link.list[r]].y %= canvas.width
                                                    globalnodes[t].link.draw(canvas_context)
                                                    globalnodes[globalnodes[t].link.list[r]].y = y2
                                                    globalnodes[t].y = y1
    
    
                                                }
                                            }
                                        }
    
    
    
                                    } else {
                                        // ////////////////console.log("case")
                                    }
                                }
                            }
                            canvas_context.globalAlpha = 1
                        }
                    }
                }
            }
        }
        
    }
    
    
    function consolidateSound() {
        let changed = true;
    
        while (changed) {
            changed = false;
            let used = new Set();
            let list = [];
    
            let len = globsounds.length;
    
            // Track merges per pass
            let merged = new Array(len).fill(false);
    
            for (let i = 0; i < len; i++) {
                if (merged[i]) continue;
    
                let a = globsounds[i];
                let group = [a]; 
                let totalStrength = a.strength;
                let totalWeight = a.radius * a.radius;
                let weightedX = a.x * totalWeight;
                let weightedY = a.y * totalWeight;
    
                for (let j = 0; j < len; j++) {
                    if (i === j || merged[j]) continue;
    
                    let b = globsounds[j];
                    if (a.type !== b.type) continue;
    
                    let dx = a.x - b.x;
                    let dy = a.y - b.y;
                    let d2 = dx * dx + dy * dy;
    
                    let contains = (d2 <= a.radius * a.radius || d2 <= b.radius * b.radius);
                    if (contains) {
                        group.push(b);
                        let w = b.radius * b.radius;
                        totalStrength += b.strength;
                        weightedX += b.x * w;
                        weightedY += b.y * w;
                        totalWeight += w;
                        merged[j] = true;
                    }
                }
    
                if (group.length > 1) {
                    // Perform actual merge
                    changed = true;
                    merged[i] = true;
    
                    list.push({
                        x: weightedX / totalWeight,
                        y: weightedY / totalWeight,
                        radius: Math.sqrt(totalWeight) / 1.009,
                        strength: Math.min(totalStrength / 1.8, 500),
                        type: a.type
                    });
                } else if (!merged[i]) {
                    // Keep unmerged
                    list.push(a);
                }
            }
    
            globsounds = list;
        }
    }
    
    
    
    
    function drawSound(){
    
        eartick++
        if(eartick%earsnap == 0){
            consolidateSound()
        }
        let st = (1*worldscaler)
        for(let t = 0;t<globsounds.length;t++){
            if(edgeLoop == 1){
            if(keysPressed['w']){
                globsounds[t].y-=smellScaler
            }
            if(keysPressed['s']){
                globsounds[t].y+=smellScaler
            }
            if(keysPressed['a']){
                globsounds[t].x-=smellScaler
            }
            if(keysPressed['d']){
                globsounds[t].x+=smellScaler
            }
        }
            // globsounds[t].draw()
            globsounds[t].strength-=((globsounds[t].radius/9)*worldscaler) 
            globsounds[t].radius+=st*2 
    
            ////console.log(soundColors[globsounds[t].type])
            let ripple = Math.max(1*((globsounds[t].strength+10)/200),.05)*1.4
    
            if(edgeLoop != 1){
            canvas_context.beginPath();
            canvas_context.lineWidth = ripple
            canvas_context.arc(globsounds[t].x, globsounds[t].y, globsounds[t].radius, 0, (Math.PI * 2), true)
            canvas_context.strokeStyle = soundColors[globsounds[t].type]
            canvas_context.stroke()
            canvas_context.closePath()
            }else{
    
            canvas_context.beginPath();
            canvas_context.lineWidth = ripple
            canvas_context.arc(globsounds[t].x, globsounds[t].y, globsounds[t].radius, 0, (Math.PI * 2), true)
            canvas_context.strokeStyle = soundColors[globsounds[t].type]
            canvas_context.stroke()
            canvas_context.closePath()
    
    
                ////////console.log(soundColors[globsounds[t].type], globsounds[t].radius)
                if(globsounds[t].x<globsounds[t].radius){
                    // canvas_context.beginPath();
                    // canvas_context.lineWidth = ripple
                    // canvas_context.arc(globsounds[t].x, globsounds[t].y, globsounds[t].radius, 0, (Math.PI * 2), true)
                    // canvas_context.strokeStyle = soundColors[globsounds[t].type]
                    // canvas_context.stroke()
                    // canvas_context.closePath()
    
                    if(edgeLoop == 1){
                        canvas_context.beginPath();
                    canvas_context.lineWidth = ripple
                    canvas_context.arc(globsounds[t].x+canvas.width, globsounds[t].y, globsounds[t].radius, 0, (Math.PI * 2), true)
                    canvas_context.strokeStyle = soundColors[globsounds[t].type]
                    canvas_context.stroke()
                    canvas_context.closePath()
                    }
                }
                if((canvas.width-globsounds[t].x)<globsounds[t].radius){
                    // canvas_context.beginPath();
                    // canvas_context.lineWidth = ripple
                    // canvas_context.arc(globsounds[t].x, globsounds[t].y, globsounds[t].radius, 0, (Math.PI * 2), true)
                    // canvas_context.strokeStyle = soundColors[globsounds[t].type]
                    // canvas_context.stroke()
                    // canvas_context.closePath()
    
                    if(edgeLoop == 1){
                canvas_context.beginPath();
                    canvas_context.lineWidth = ripple
                    canvas_context.arc(globsounds[t].x-canvas.width, globsounds[t].y, globsounds[t].radius, 0, (Math.PI * 2), true)
                    canvas_context.strokeStyle = soundColors[globsounds[t].type]
                    canvas_context.stroke()
                    canvas_context.closePath()
                    }
                }
                if(globsounds[t].y<globsounds[t].radius){
                    // canvas_context.beginPath();
                    // canvas_context.lineWidth = ripple
                    // canvas_context.arc(globsounds[t].x, globsounds[t].y, globsounds[t].radius, 0, (Math.PI * 2), true)
                    // canvas_context.strokeStyle = soundColors[globsounds[t].type]
                    // canvas_context.stroke()
                    // canvas_context.closePath()
    
                    if(edgeLoop == 1){
                canvas_context.beginPath();
                    canvas_context.lineWidth = ripple
                    canvas_context.arc(globsounds[t].x, globsounds[t].y+canvas.height, globsounds[t].radius, 0, (Math.PI * 2), true)
                    canvas_context.strokeStyle = soundColors[globsounds[t].type]
                    canvas_context.stroke()
                    canvas_context.closePath()
                    }
                }
                if((canvas.height-globsounds[t].y)<globsounds[t].radius){
                    // canvas_context.beginPath();
                    // canvas_context.lineWidth = ripple
                    // canvas_context.arc(globsounds[t].x, globsounds[t].y, globsounds[t].radius, 0, (Math.PI * 2), true)
                    // canvas_context.strokeStyle = soundColors[globsounds[t].type]
                    // canvas_context.stroke()
                    // canvas_context.closePath()
    
                    if(edgeLoop == 1){
    
                        canvas_context.beginPath();
                        canvas_context.lineWidth = ripple
                        canvas_context.arc(globsounds[t].x, globsounds[t].y-canvas.height, globsounds[t].radius, 0, (Math.PI * 2), true)
                        canvas_context.strokeStyle = soundColors[globsounds[t].type]
                        canvas_context.stroke()
                        canvas_context.closePath()
                    }
                }
    
    
            }
    
    
        }
    
    
        for(let t = 0;t<globsounds.length;t++){
            // globsounds[t].draw()
            if(globsounds[t].strength <=0){
                globsounds.splice(t,1)
            }
        }
    
    
    }
    
    
    let x1 = 0
    let x2 = 0
    let y1 = 0
    let y2 = 0
    
    function F18(){
    
    x1 = 0
    x2 = 0
    y1 = 0
    y2 = 0
    
        for (let t = 0; t < globalnodes.length; t++) {
            x1 = globalnodes[t].x
            y1 = globalnodes[t].y
            if (globalnodes[t].dead == 1) {
                continue
            }
    
            canvas_context.globalAlpha = 1
            if (globalnodes[t].relative > -1) {
    
                let outsumme = 255
    
                let a = Math.abs(globalnodes[t].r - globalnodes[globalnodes[t].relative].r)
                let b = Math.abs(globalnodes[t].b - globalnodes[globalnodes[t].relative].b)
                let c = Math.abs(globalnodes[t].g - globalnodes[globalnodes[t].relative].g)
                let d = Math.abs(globalnodes[t].p - globalnodes[globalnodes[t].relative].p)
                let e = Math.abs(globalnodes[t].m - globalnodes[globalnodes[t].relative].m)
                let f = Math.abs(globalnodes[t].q - globalnodes[globalnodes[t].relative].q)
                let g = Math.abs(globalnodes[t].z - globalnodes[globalnodes[t].relative].z)
    
                let w = vectorLength7D(a, b, c, d, e, f, g)
    
    
                let alpha = (674 - w) / 674
    
                outsumme = Math.max(0, outsumme)
                // ////////////////console.log(globalnodes[t])
                globalnodes[t].linkApha = alpha * alpha * alpha * alpha * alpha * alpha * alpha * alpha
                // canvas_context.globalAlpha = alpha*alpha* alpha*alpha* alpha*alpha* alpha*alpha
    
            } else {
    
                globalnodes[t].linkApha = 1
            }
    
            //relationview '7' "7"
            if (relationView) {
                globalnodes[t].drawBody(contextList[globalnodes[t].contextMarker])
            } else {
                globalnodes[t].drawBody(canvas_context)
            }
    
        }
    }
    function F19() {
        canvas_context.globalAlpha = 1;
        
        // //////console.log(globuckets)
        // Pre-calculate array size
        const bucketRows = globuckets.length;
        const bucketCols = globuckets[0].length;
        const totalBuckets = bucketRows * bucketCols;
        
        // Initialize global bucksnap array - maintain original variable
        bucksnap = new Array(totalBuckets).fill(null).map(() => []);
        
        // Avoid repeated length calculations in loops
        for (let b = 0; b < bucketRows; b++) {
          for (let g = 0; g < bucketCols; g++) {
            const snapIndex = (b * bucketCols) + g;
            
            // Cache the range2 array and its length
            const range2 = globuckets[b][g].range2;
            const range2Length = range2.length;
            
            const targetBucket = bucksnap[snapIndex];
            
            // Process each range entry
            for (let r = 0; r < range2Length; r++) {
              const [rb, rg] = range2[r];
              const guys = globuckets[rb][rg].guys;
              const guysLength = guys.length;
              
              // Add all items at once with a single memory allocation
              const startIdx = targetBucket.length;
              targetBucket.length += guysLength;
              
              for (let d = 0; d < guysLength; d++) {
                targetBucket[startIdx + d] = globalnodes[guys[d]];
              }
            }
          }
        }
      }
    
    function MagnetismOn(){
    
        if (magnetism > 0) {
    
            for (let t = mindead; t < globalnodes.length; t++) {
                globalnodes[t].smach = 0
            }
            for (let t = mindead; t < globalnodes.length; t++) {
                globalnodes[t].smach = 1
    
            x1 = globalnodes[t].x
            y1 = globalnodes[t].y
    
                if (globalnodes[t].dead == 1) {
                    continue
                }
                if (globalnodes[t].age < minage) {
                    // continue
                }
                if (globalnodes[t].dead == 1) {
                    continue
                }
    
                // let bucksnap[globalnodes[t].bucket] = bucksnap[globalnodes[t].bucket]
                for (let k = 0; k < bucksnap[globalnodes[t].bucket].length; k++) {
                    if(bucksnap[globalnodes[t].bucket][k].smach == 1){
                        continue
                    }
                    if(typeof  bucksnap[globalnodes[t].bucket][k]  == "undefined"){
                        //////console.log(bucksnap[globalnodes[t].bucket])
                    }
                    if(typeof bucksnap[globalnodes[t].bucket][k].x  == "undefined"){
                        //////console.log(bucksnap[globalnodes[t].bucket], bucksnap[globalnodes[t].bucket][k])
                    }
     
            x2 = bucksnap[globalnodes[t].bucket][k].x 
            y2 = bucksnap[globalnodes[t].bucket][k].y
            if(globalnodes[t] == bucksnap[globalnodes[t].bucket][k]){
                continue
            }
                    if (globalnodes[t].charge != 0) {
                        if (bucksnap[globalnodes[t].bucket][k].charge != 0) {
    
                            // let x = Math.abs(bucksnap[globalnodes[t].bucket][k].x - globalnodes[t].x) 
                            // let y = Math.abs(bucksnap[globalnodes[t].bucket][k].y - globalnodes[t].y) 
    
                            // let matta = (worldscale*1.25)-(worldscale*.05)
                            // if(x > matta || y> matta ){
                            //     continue
                            // }
    
    
                            globalnodes[t].link.target = bucksnap[globalnodes[t].bucket][k]
    
    
    
    
                            let trap = isNearEdge(globalnodes[t], globuckets.length, globuckets[0].length, 2)
                            let krap = isNearEdge(bucksnap[globalnodes[t].bucket][k], globuckets.length, globuckets[0].length, 2)
                            if(edgeLoop == 1 && (trap||krap)){
                                x1 = globalnodes[t].x
                                y1 = globalnodes[t].y
                                x2 = bucksnap[globalnodes[t].bucket][k].x
                                y2 = bucksnap[globalnodes[t].bucket][k].y
                                //////////////console.log('ys')
                                let ps = findClosestWrappedPair([globalnodes[t], bucksnap[globalnodes[t].bucket][k]], canvas.width, canvas.height)
                                globalnodes[t].link.target = ps.obj2
                            }
                    
    
    
                            let mes = globalnodes[t].link.hypotenuse()
    
    
                            // let d = globalnodes[t].magnet.radius+bucksnap[globalnodes[t].bucket][k].magnet.radius
     
    
                            let m = globalnodes[t].magnet.radius + bucksnap[globalnodes[t].bucket][k].magnet.radius
                            if (mes < m) {
    
                                if (globalnodes[t].charge != bucksnap[globalnodes[t].bucket][k].charge) {
    
                                    if (globalnodes[t].anchor != 1) {
                                        let a = globalnodes[t].link.angle()
                                        let cosa = Math.cos(a)
                                        let sina = Math.sin(a)
                                        let rat = ((m - (mes)) / ((m))) + magmax
    
                                        x1 -= cosa * .5 * rat * worldscaler
                                        y1 -= sina * .5 * rat * worldscaler
                                    }
    
                                    if (bucksnap[globalnodes[t].bucket][k].anchor != 1) {
                                        let a = globalnodes[t].link.angle()
                                        let cosa = Math.cos(a)
                                        let sina = Math.sin(a)
                                        let rat = ((m - (mes)) / ((m))) + magmax
    
                                        x2 += cosa * .5 * rat * worldscaler
                                        y2 += sina * .5 * rat * worldscaler
                                    }
    
    
                                } else {
    
                                    if (globalnodes[t].anchor != 1) {
                                        let a = globalnodes[t].link.angle()
                                        let cosa = Math.cos(a)
                                        let sina = Math.sin(a)
                                        let rat = ((m - (mes)) / ((m))) + magmax
                                        x1 += cosa * .5 * rat * worldscaler
                                        y1 += sina * .5 * rat * worldscaler
                                    }
    
    
                                    if (bucksnap[globalnodes[t].bucket][k].anchor != 1) {
                                        let a = globalnodes[t].link.angle()
                                        let cosa = Math.cos(a)
                                        let sina = Math.sin(a)
                                        let rat = ((m - (mes)) / ((m))) + magmax
                                        x2 -= cosa * .5 * rat * worldscaler
                                        y2 -= sina * .5 * rat * worldscaler
                                    }
                                }
                            }
    
    
    
                            globalnodes[t].x = x1
                            globalnodes[t].y = y1
    
                            bucksnap[globalnodes[t].bucket][k].x = x2
                            bucksnap[globalnodes[t].bucket][k].y = y2
    
    
                        }
    
                    }
                }
            }
    
        }
    }
    
    let matta = 0
    
    function F20() {
        // Calculate total buckets once
        const bucketRows = globuckets.length;
        const bucketCols = globuckets[0].length;
        const totalBuckets = bucketRows * bucketCols;
        
        // Pre-allocate result array
         bucksnap = Array(totalBuckets).fill().map(() => []);
        
        // Use more descriptive variable names and avoid unnecessary calculations in loops
        for (let rowIndex = 0; rowIndex < bucketRows; rowIndex++) {
          for (let colIndex = 0; colIndex < bucketCols; colIndex++) {
            const snapIndex = (rowIndex * bucketCols) + colIndex;
            const currentBucket = globuckets[rowIndex][colIndex];
            const ranges = currentBucket.range;
            
            // Process all ranges at once for this bucket
            if (!ranges || ranges.length === 0) continue;
            
            // Create a temporary array to collect all nodes before pushing
            const allNodes = [];
            
            for (let rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {
              const [targetRow, targetCol] = ranges[rangeIndex];
              const guyIndices = globuckets[targetRow][targetCol].guys;
              
              // Map directly from indices to nodes in one operation
              if (guyIndices && guyIndices.length) {
                for (let i = 0; i < guyIndices.length; i++) {
                  allNodes.push(globalnodes[guyIndices[i]]);
                }
              }
            }
            
            // Use a single push operation with spread to add all collected nodes
            if (allNodes.length) {
              bucksnap[snapIndex].push(...allNodes);
            }
          }
        }
        
      }
    function F21(){
        matta = (worldscale * 1.25) - (worldscale * .05)
        for (let t = mindead; t < globalnodes.length; t++) {
            globalnodes[t].smakk = 0
        }
    }
    function F22(){
    
    
    
    
        for (let t = mindead; t < globalnodes.length; t++) {
            globalnodes[t].smakk = 1
            x1 = globalnodes[t].x
            y1 = globalnodes[t].y
            if (globalnodes[t].dead == 1) {
                continue
            }
            // let bucksnap[globalnodes[t].bucket] = bucksnap[globalnodes[t].bucket]
            // //////////////console.log(bucksnap[globalnodes[t].bucket].length)
            for (let k = 0; k < bucksnap[globalnodes[t].bucket].length; k++) { 
                if(bucksnap[globalnodes[t].bucket][k].smakk == 1){
                    continue
                }
                x2 = bucksnap[globalnodes[t].bucket][k].x
                y2 = bucksnap[globalnodes[t].bucket][k].y
                if (bucksnap[globalnodes[t].bucket][k] == globalnodes[t]) { //new????
                    continue
                }
                if (bucksnap[globalnodes[t].bucket][k].dead == 1) {
                    continue
                }
                let x = Math.abs(bucksnap[globalnodes[t].bucket][k].x - globalnodes[t].x)
                let y = Math.abs(bucksnap[globalnodes[t].bucket][k].y - globalnodes[t].y)
    
                if (((x > matta || y > matta )) && (edgeLoop != 1  || ((x < canvas.width && x > matta) || (y < canvas.height && y > matta)))) {
                    // //////////////console.log
                    // continue
                }
    
                // let cachez = globalnodes[t].link.target.immune.includes(t) 
                // if(x > 10){
                if (x < (diffdist * worldscaler) && y < (diffdist * worldscaler)) {
                    let z = bucksnap[globalnodes[t].bucket][k].x - globalnodes[t].x
                    // if( (!(cachez))){ 
                    if (bucksnap[globalnodes[t].bucket][k].anchor != 1) {
                        bucksnap[globalnodes[t].bucket][k].x += ((z / diffdist) / driftconstant) * worldscaler
                    }
                    if (globalnodes[t].anchor != 1) {
                        globalnodes[t].x -= ((z / diffdist) / driftconstant) * worldscaler
                    }
                    // }
                }
    
                // if(Math.abs(bucksnap[globalnodes[t].bucket][k].y - globalnodes[t].y) > 10){
    
                if (x < (diffdist * worldscaler) && y < (diffdist * worldscaler)) {
                    let z = bucksnap[globalnodes[t].bucket][k].y - globalnodes[t].y
                    // if( (!(cachez))){
                    if (bucksnap[globalnodes[t].bucket][k].anchor != 1) {
                        bucksnap[globalnodes[t].bucket][k].y += ((z / diffdist) / driftconstant) * worldscaler
                    }
    
                    if (globalnodes[t].anchor != 1) {
                        globalnodes[t].y -= ((z / diffdist) / driftconstant) * worldscaler
                    }
                    // }
                }
                // continue
                // }
    
    
                if ((bucksnap[globalnodes[t].bucket][k].age < minage || globalnodes[t].age < minage) && bucksnap[globalnodes[t].bucket][k].age != globalnodes[t].age) {
    
                    globalnodes[t].link.target = bucksnap[globalnodes[t].bucket][k]
    
                    let j = 0
    
    
    
                    let trap = isNearEdge(globalnodes[t], globuckets.length, globuckets[0].length, 2)
                    let krap = isNearEdge(bucksnap[globalnodes[t].bucket][k], globuckets.length, globuckets[0].length, 2)
                    if(edgeLoop == 1 && (trap||krap)){
                    // let sqr = globalnodes[t].link.squareDistance() 
                    // if(sqr < (Math.min(canvas.width, canvas.height)*Math.min(canvas.width, canvas.height)/2)){
    
                    //     //////////////console.log('s')
                    // }else{
                        //////////////console.log('y')
                            x1 = globalnodes[t].x
                            y1 = globalnodes[t].y
                            x2 = bucksnap[globalnodes[t].bucket][k].x
                            y2 = bucksnap[globalnodes[t].bucket][k].y
                            let ps = findClosestWrappedPair([globalnodes[t], bucksnap[globalnodes[t].bucket][k]], canvas.width, canvas.height)
                            globalnodes[t].link.target = ps.obj2
                        }
                    // }
                    let mes = globalnodes[t].link.hypotenuse()
                    let a = globalnodes[t].link.angle()
                    let cosa = Math.cos(a)
                    let sina = Math.sin(a)
    
    
                    while (mes < (worldscale * 1.125) && !(globalnodes[t].link.target.stupidimmune[t] == 1)) {
                        j++
                        if (j > 20) { //16 //5  //10 //16
                            break
                        }
                        // let a = globalnodes[t].link.angle()
                        x1 += cosa * 2* worldscaler
                        y1 += sina * 2* worldscaler
                        x2 -= cosa * 2 * worldscaler
                        y2 -= sina * 2* worldscaler
                        mes += 4* worldscaler
                    }
    
    
                    globalnodes[t].x = x1
                    globalnodes[t].y = y1
    
                    bucksnap[globalnodes[t].bucket][k].x = x2
                    bucksnap[globalnodes[t].bucket][k].y = y2
    
    
                    continue
                }
    
                
    
                if (true) { //t!=k is nonesnesne
                    let packK = bucksnap[globalnodes[t].bucket][k]
                    let packT = globalnodes[t]
                    let j = 0
    
    
                    packT.link.target = packK
                    
    
    
                    let trap = isNearEdge(packT, globuckets.length, globuckets[0].length, 2)
                    let krap = isNearEdge(packK, globuckets.length, globuckets[0].length, 2)
                    if(edgeLoop == 1 && (trap||krap)){
                        x1 = packT.x 
                        y1 = packT.y
                        x2 = packK.x
                        y2 = packK.y
                        //////////////console.log('yss')
                        let ps = findClosestWrappedPair([packT, packK], canvas.width, canvas.height)
                        packT.link.target = ps.obj2
                    }
    
    
    
                // let p = new Circle(x1, y1, 2, "blue")
                // p.draw()
    
                
                    let mes = packT.link.hypotenuse()
                    let mez = mes*.9
                    let a = packT.link.angle()
                    let cosa = Math.cos(a)*1.05 //scale force
                    let sina = Math.sin(a)*1.05 //scale force
                    let cachek = (packT.stupidimmune[k] == 1)
                    let cachet = (packK.stupidneighbors[t] == 1)
                    let cachez = (packK.stupidimmune[t] == 1)
                    let cachen = (packT.stupidneighbors[k] == 1)
    
    
                    // ////////////////console.log(x1, x2, y1, y2)
    
    
                    let fertk = 0
    
    
                    let colorsmack = 0
                    colorsmack += Math.abs(globalnodes[packT.shead].r - globalnodes[packK.shead].r)
                    colorsmack += Math.abs(globalnodes[packT.shead].g - globalnodes[packK.shead].g)
                    colorsmack += Math.abs(globalnodes[packT.shead].b - globalnodes[packK.shead].b)
                    colorsmack += Math.abs(globalnodes[packT.shead].p - globalnodes[packK.shead].p)
                    colorsmack += Math.abs(globalnodes[packT.shead].z - globalnodes[packK.shead].q)
                    colorsmack += Math.abs(globalnodes[packT.shead].q - globalnodes[packK.shead].z)
                    colorsmack += Math.abs(globalnodes[packT.shead].m - globalnodes[packK.shead].m)
    
                    let soundlatch = 0

                    
                    while (mes <= worldscale) { //(Math.max(packK.lout,packT.lout))-1
                        j++
                        if (j > 20) { //16 //5 //10 //16
                            break
                        }
                         if(!cachen && !cachez){
                            soundlatch = 1
                        }
    
    
    
    
                        if (colorsmack < breedingdistance && (packK.mouth != 1 && packT.mouth != 1) && fertk == 0) {
                            fertk = 1
                            if (packT.fertile == 1) {
                                if (packT.male == 1) {
    
                                    for (let m = 0; m < packT.immune.length; m++) {
                                        let fr = packT.immune[m]
                                        if (packK.genebucket.includes(globalnodes[fr].genestring)) {} else {
                                            packK.genebucket.push(globalnodes[fr].genestring)
                                            for (let r = 0; r < packK.immune.length; r++) {
                                                if (globalnodes[packK.immune[r]].genebucket.includes(globalnodes[fr].genestring)) {} else {
                                                    globalnodes[packK.immune[r]].genebucket.push(globalnodes[fr].genestring)
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    for (let m = 0; m < packK.immune.length; m++) {
                                        let fr = packK.immune[m]
                                        if (packT.genebucket.includes(globalnodes[fr].genestring)) {} else {
                                            packT.genebucket.push(globalnodes[fr].genestring)
                                            for (let r = 0; r < packT.immune.length; r++) {
                                                if (globalnodes[packT.immune[r]].genebucket.includes(globalnodes[fr].genestring)) {} else {
                                                    globalnodes[packT.immune[r]].genebucket.push(globalnodes[fr].genestring)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else if (packK.fertile == 1) {
    
                                if (packK.male == 1) {
    
                                    for (let m = 0; m < packK.immune.length; m++) {
                                        let fr = packK.immune[m]
                                        if (packT.genebucket.includes(globalnodes[fr].genestring)) {} else {
                                            packT.genebucket.push(globalnodes[fr].genestring)
                                            for (let r = 0; r < packT.immune.length; r++) {
                                                if (globalnodes[packT.immune[r]].genebucket.includes(globalnodes[fr].genestring)) {} else {
                                                    globalnodes[packT.immune[r]].genebucket.push(globalnodes[fr].genestring)
                                                }
                                            }
                                        }
                                    }
                                } else {
    
                                    for (let m = 0; m < packT.immune.length; m++) {
                                        let fr = packT.immune[m]
                                        if (packK.genebucket.includes(globalnodes[fr].genestring)) {} else {
                                            packK.genebucket.push(globalnodes[fr].genestring)
                                            for (let r = 0; r < packK.immune.length; r++) {
                                                if (globalnodes[packK.immune[r]].genebucket.includes(globalnodes[fr].genestring)) {} else {
                                                    globalnodes[packK.immune[r]].genebucket.push(globalnodes[fr].genestring)
                                                }
                                            }
                                        }
                                    }
    
                                }
                            }
    
    
    
    
                        }
    
                        if (packT.mouth == 1 && colorsmack > speciesdistance && packK.armor != 1 && (!(cachez))) {
                            if (cachen) {
    
                            } else {
    
    
                                if ((packT.dead != 1 && packK.dead != 1) && (packT.trueage > minage && packK.trueage > minage)) {
    
                                    packT.energy += (packK.energy * (packK.immune.length / 2)) + predatorIncentive
                                    packT.age -= (packK.energy * (packK.immune.length / 2)) + predatorIncentive
                                    packK.energy = 0
                                    packT.age = Math.max(packT.age, minage)
                                    packT.energy = Math.min(packT.energy, packT.gencap)
                                    packK.dead = 1
                                    if (totalKill == 1) {
                                        for (let d = 0; d < packK.immune.length; d++) {
                                            globalnodes[packK.immune[d]].dead = 1
                                        }
                                    }
                                    for (let r = 0; r < packK.neighbors.length; r++) {
                                        // packK.disconnect(globalnodes[packK.neighbors[r]])
                                    }
                                }
                            }
                        }
                        if (packK.mouth == 1 && colorsmack > speciesdistance && packT.armor != 1 && (!(cachek))) {
                            if (cachet) {
    
                            } else {
                                if ((packT.dead != 1 && packK.dead != 1) && (packT.trueage > minage && packK.trueage > minage)) {
                                    packK.energy += (packT.energy * (packT.immune.length / 2)) + predatorIncentive
                                    packK.age -= (packT.energy * (packT.immune.length / 2)) + predatorIncentive
                                    packT.energy = 0
                                    packK.age = Math.max(packK.age, minage)
                                    packK.energy = Math.min(packK.energy, packK.gencap)
                                    packT.dead = 1
                                    if (totalKill == 1) {
                                        for (let d = 0; d < packT.immune.length; d++) {
                                            globalnodes[packT.immune[d]].dead = 1
                                        }
                                    }
                                    for (let r = 0; r < packT.neighbors.length; r++) {
                                        // packT.disconnect(globalnodes[packT.neighbors[r]])
                                    }
                                }
                            }
                        }
    
    
    
    
                        if (true) {
    
                            if (packT.suck == 1 && colorsmack > speciesdistance && packK.armor != 1 && (!(cachez))) {
                                if (cachen) {
    
                                } else {
                                    if ((packT.dead != 1 && packK.dead != 1) && (packT.trueage > minage && packK.trueage > minage)) {
                                        packT.energy += ((packK.energy * (1)) + predatorIncentive) / suckratio
                                        packT.age -= ((packK.energy * (1)) + predatorIncentive) / suckratio
                                        packK.energy -= ((packK.energy * (1)) + predatorIncentive) / suckratio
                                        packK.age += (((packK.energy * (1)) + predatorIncentive) / suckratio) / agesuckrat
                                        packT.age = Math.max(packT.age, minage)
                                        packT.energy = Math.min(packT.energy, packT.gencap)
                                    }
                                }
                            }
                            if (packK.suck == 1 && colorsmack > speciesdistance && packT.armor != 1 && (!(cachek))) {
                                if (cachet) {
    
                                } else {
                                    if ((packT.dead != 1 && packK.dead != 1) && (packT.trueage > minage && packK.trueage > minage)) {
                                        packK.energy += ((packT.energy * (1)) + predatorIncentive) / suckratio
                                        packK.age -= ((packT.energy * (1)) + predatorIncentive) / suckratio
                                        packT.energy -= ((packT.energy * (1)) + predatorIncentive) / suckratio
                                        packT.age += (((packT.energy * (1)) + predatorIncentive) / suckratio) / agesuckrat
                                        packK.age = Math.max(packK.age, minage)
                                        packK.energy = Math.min(packK.energy, packK.gencap)
                                    }
                                }
                            }
                        }
                        // let a = packT.link.angle()
    
                        if (true) {
    
                            let outs = 0
                            if (packT.anchor != 1 || packK.anchor == 1) {
                                x1 += cosa * .5 * worldscaler
                                y1 += sina * .5 * worldscaler
    
                                outs += .5 * worldscaler
                            } else {
                                x1 += cosa * .005 * worldscaler
                                y1 += sina * .005 * worldscaler
                                outs += .005 * worldscaler
                            }
                            if (packT.motor == 1) {
                                if (packK.anchor != 1 || packT.anchor == 1) {
                                    x2  -= cosa * 1 * worldscaler
                                    y2 -= sina * 1 * worldscaler
                                    outs += 1 * worldscaler
                                } else {
                                    x2 -= cosa * .01 * worldscaler
                                    y2 -= sina * .01 * worldscaler
                                    outs += .01 * worldscaler
                                }
                                mes += outs //1.5
                            } else {
                                if (packK.anchor != 1 || packT.anchor == 1) {
                                    x2  -= cosa * .5 * worldscaler
                                    y2 -= sina * .5 * worldscaler
                                    outs += .5 * worldscaler
                                } else {
                                    x2 -= cosa * .005 * worldscaler
                                    y2 -= sina * .005 * worldscaler
                                    outs += .005 * worldscaler
                                }
                                mes += outs
    
    
                            }
                        }
                        if (!cachek) {
                            // if( !packK.link.list.includes(t)){
                            let spin = (seedRandom() - .5) / 3
                            packT.pushout += spin 
                            packK.pushout -= spin
                            packT.pushoutsto = packT.pushout
                            packK.pushout = packK.pushout
                            packT.touchey = 1
                            packK.touchey = 1
                            // }
                        }
                    }
    
                    let wrt =  (worldscale * 1.25) - (worldscale * .05)
                    if (mes <= wrt) {
    
                         if(!cachen && !cachez){
                        soundlatch = 1
                        }
                        
    
                        // let colorsmack = 0
                        // // colorsmack  = colordistance(globalnodes[packT.shead], globalnodes[packK.shead])
                        // colorsmack += Math.abs(globalnodes[packT.shead].r - globalnodes[packK.shead].r)
                        // colorsmack += Math.abs(globalnodes[packT.shead].g - globalnodes[packK.shead].g)
                        // colorsmack += Math.abs(globalnodes[packT.shead].b - globalnodes[packK.shead].b)
                        // colorsmack += Math.abs(globalnodes[packT.shead].p - globalnodes[packK.shead].p)
                        // colorsmack += Math.abs(globalnodes[packT.shead].z - globalnodes[packK.shead].q)
                        // colorsmack += Math.abs(globalnodes[packT.shead].q - globalnodes[packK.shead].z)
                        // colorsmack += Math.abs(globalnodes[packT.shead].m - globalnodes[packK.shead].m)
    
    
                        if (packT.mouth == 1 && colorsmack > speciesdistance && packK.armor != 1 && (!(cachez))) {
                            if (cachen) {
    
                            } else {
    
    
                                if ((packT.dead != 1 && packK.dead != 1) && (packT.trueage > minage && packK.trueage > minage)) {
    
                                    packT.energy += (packK.energy * (packK.immune.length / 2)) + predatorIncentive
                                    packT.age -= (packK.energy * (packK.immune.length / 2)) + predatorIncentive
                                    packK.energy = 0
                                    packT.age = Math.max(packT.age, minage)
                                    packT.energy = Math.min(packT.energy, packT.gencap)
                                    packK.dead = 1
                                    if (totalKill == 1) {
                                        for (let d = 0; d < packK.immune.length; d++) {
                                            globalnodes[packK.immune[d]].dead = 1
                                        }
                                    }
                                    for (let r = 0; r < packK.neighbors.length; r++) {
                                        // packK.disconnect(globalnodes[packK.neighbors[r]])
                                    }
                                }
                            }
                        }
                        if (packK.mouth == 1 && colorsmack > speciesdistance && packT.armor != 1 && (!(cachek))) {
                            if (cachet) {
    
                            } else {
                                if ((packT.dead != 1 && packK.dead != 1) && (packT.trueage > minage && packK.trueage > minage)) {
                                    packK.energy += (packT.energy * (packT.immune.length / 2)) + predatorIncentive
                                    packK.age -= (packT.energy * (packT.immune.length / 2)) + predatorIncentive
                                    packT.energy = 0
                                    packK.age = Math.max(packK.age, minage)
                                    packK.energy = Math.min(packK.energy, packK.gencap)
                                    packT.dead = 1
                                    if (totalKill == 1) {
                                        for (let d = 0; d < packT.immune.length; d++) {
                                            globalnodes[packT.immune[d]].dead = 1
                                        }
                                    }
                                    for (let r = 0; r < packT.neighbors.length; r++) {
                                        // packT.disconnect(globalnodes[packT.neighbors[r]])
                                    }
                                }
                            }
                        }
    
                        if (true) {
    
                            if (packT.suck == 1 && colorsmack > speciesdistance && packK.armor != 1 && (!(cachez))) {
                                if (cachen) {
    
                                } else {
                                    if ((packT.dead != 1 && packK.dead != 1) && (packT.trueage > minage && packK.trueage > minage)) {
                                        packT.energy += ((packK.energy * (1)) + predatorIncentive) / suckratio
                                        packT.age -= ((packK.energy * (1)) + predatorIncentive) / suckratio
                                        packK.age += (((packK.energy * (1)) + predatorIncentive) / suckratio) / agesuckrat
                                        packK.energy -= ((packK.energy * (1)) + predatorIncentive) / suckratio
                                        packT.age = Math.max(packT.age, minage)
                                        packT.energy = Math.min(packT.energy, packT.gencap)
                                    }
                                }
                            }
                            if (packK.suck == 1 && colorsmack > speciesdistance && packT.armor != 1 && (!(cachek))) {
                                if (cachet) {
    
                                } else {
                                    if ((packT.dead != 1 && packK.dead != 1) && (packT.trueage > minage && packK.trueage > minage)) {
                                        packK.energy += ((packT.energy * (1)) + predatorIncentive) / suckratio
                                        packK.age -= ((packT.energy * (1)) + predatorIncentive) / suckratio
                                        packT.energy -= ((packT.energy * (1)) + predatorIncentive) / suckratio
                                        packT.age += (((packT.energy * (1)) + predatorIncentive) / suckratio) / agesuckrat
                                        packK.age = Math.max(packK.age, minage)
                                        packK.energy = Math.min(packK.energy, packK.gencap)
                                    }
                                }
                            }
                        }
    
    
                        // let a = packT.link.angle()
    
                        if (true) {
    
                            let outs = 0
                            if (packT.anchor != 1 || packK.anchor == 1) {
                                x1 += cosa * .5 * worldscaler
                                y1 += sina * .5 * worldscaler
    
                                outs += .5 * worldscaler
                            } else {
                                x1 += cosa * .005 * worldscaler
                                y1 += sina * .005 * worldscaler
                                outs += .005 * worldscaler
                            }
                            if (packT.motor == 1) {
                                if (packK.anchor != 1 || packT.anchor == 1) {
                                    x2 -= cosa * 1 * worldscaler
                                    y2 -= sina * 1 * worldscaler
                                    outs += 1 * worldscaler
                                } else {
                                    x2 -= cosa * .01 * worldscaler
                                    y2 -= sina * .01 * worldscaler
                                    outs += .01 * worldscaler
                                }
                                mes += outs // 1.5
                            } else {
                                if (packK.anchor != 1 || packT.anchor == 1) {
                                    x2 -= cosa * .5 * worldscaler
                                    y2 -= sina * .5 * worldscaler
                                    outs += .5 * worldscaler
                                } else {
                                    x2 -= cosa * .005 * worldscaler
                                    y2 -= sina * .005 * worldscaler
                                    outs += .005 * worldscaler
                                }
                                mes += outs
    
    
                            }
                        }
    
                        if (true) {
    
                            let outs = 0
                            if (packT.anchor != 1 || packK.anchor == 1) {
                                packT.x += cosa * .5 * worldscaler
                                packT.y += sina * .5 * worldscaler
    
                                outs += .5 * worldscaler
                            } else {
                                packT.x += cosa * .005 * worldscaler
                                packT.y += sina * .005 * worldscaler
                                outs += .005 * worldscaler
                            }
                            if (packT.motor == 1) {
                                if (packK.anchor != 1 || packT.anchor == 1) {
                                    x2 -= cosa * 1 * worldscaler
                                    y2 -= sina * 1 * worldscaler
                                    outs += 1 * worldscaler
                                } else {
                                    x2 -= cosa * .01 * worldscaler
                                    y2 -= sina * .01 * worldscaler
                                    outs += .01 * worldscaler
                                }
                                mes += outs // 1.5
                            } else {
                                if (packK.anchor != 1 || packT.anchor == 1) {
                                    x2 -= cosa * .5 * worldscaler
                                    y2 -= sina * .5 * worldscaler
                                    outs += .5 * worldscaler
                                } else {
                                    x2 -= cosa * .005 * worldscaler
                                    y2 -= sina * .005 * worldscaler
                                    outs += .005 * worldscaler
                                }
                                mes += outs
    
    
                            }
                        }
    
    
                        //here
    
                    
    
                        if (!cachek) {
                            // if( !packK.link.list.includes(t)){
                            let spin = (seedRandom() - .5) / 3
                            packT.pushout += spin
                            packK.pushout -= spin
                            packT.pushoutsto = packT.pushout
                            packK.pushout = packK.pushout
                            packT.touchey = 1
                            packK.touchey = 1
                            // }
                        }
    
    
    
    
                    }
    
    
                     if(!cachen && !cachez){
                      soundlatch = 1
                      }else{
                        soundlatch = 0
                      }
    
                      if (mez <= wrt*.88) {
                    if(soundFlip == 1 && soundlatch == 1 && packT.soundCD<=0&& packK.soundCD<=0){

                    if( packT.soundCD<=0&& packK.soundCD<=0){
                      packT.soundCD = 20
                      packK.soundCD = 20
                    if(audioPing==1){
                      synth.triggerAttackRelease(soundtable[packT.prime*packK.prime][0], soundtable[packT.prime*packK.prime][1]);
                    }
                  }
                        packT.soundCD = 20
                        packK.soundCD = 20
                        
                        let sound = {}
                        sound.radius = wrt
                        sound.strength = 450
                        sound.x = (packT.x-(cosa*wrt*.5))
                        sound.y = (packT.y-(sina*wrt*.5))
                        sound.type = (packT.prime*packK.prime)
                        ////console.log(packT.prime, packK.prime )
                        globsounds.push(sound)
                      }

                      if( soundlatch == 1 && packT.soundCD<=0&& packK.soundCD<=0){

                      packT.soundCD = 20
                      packK.soundCD = 20
                    if(audioPing==1){
                      synth.triggerAttackRelease(soundtable[packT.prime*packK.prime][0], soundtable[packT.prime*packK.prime][1]);
                    }
                  }
                }else  if (false) { //mez <= wrt*.85
    
                    if(soundFlip == 1 && soundlatch == 1 && packT.soundCD<=0&& packK.soundCD<=0){

                    if( packT.soundCD<=0&& packK.soundCD<=0){
                      packT.soundCD = 20
                      packK.soundCD = 20
                    if(audioPing==1){
                      synth.triggerAttackRelease(soundtable[packT.prime*packK.prime][0], soundtable[packT.prime*packK.prime][1]);
                    }
                  }
                        packT.soundCD = 20
                        packK.soundCD = 20
                        
                        let sound = {}
                        sound.radius = wrt
                        sound.strength = 450
                        sound.x = (packT.x-(cosa*wrt*.5))
                        sound.y = (packT.y-(sina*wrt*.5))
                        sound.type = (packT.prime*packK.prime)
                        ////console.log(packT.prime, packK.prime )
                        globsounds.push(sound)
                      }

                      if( soundlatch == 1 && packT.soundCD<=0&& packK.soundCD<=0){

                      packT.soundCD = 20
                      packK.soundCD = 20
                    if(audioPing==1){
                      synth.triggerAttackRelease(soundtable[packT.prime*packK.prime][0], soundtable[packT.prime*packK.prime][1]);
                    }
                  }

                }
                    packT.lastx -= packT.x-x1
                    packT.lasty -= packT.y-y1
    
                    packK.lastx -= packK.x - x2 
                    packK.lasty -= packK.y - y2
    
                    packT.x = x1
                    packT.y = y1
    
                    packK.x = x2 
                    packK.y = y2
    
    

                    


    
                }
            }
        }
    }
    
    
    function F23(){
        alldead = 0
        for (let t = 0; t < globalnodes.length; t++) {
            if (globalnodes[t].dead == 1) {
                alldead++
            }
        }
        for (let t = 0; t < globalnodes.length; t++) {
            if (globalnodes[t].dead == 1) {
                continue
            }
            if (globalnodes[t].trueage > 5) {
                if(globalnodes[t].dying(alldead)){
                    alldead+=1 //3 too much //not sure what's up  10 too much
                }
            }
        }
    }
    
    function F24(){
    
    
    
    
        if (particletoggle == 1 || (particletoggle == 1 && (viewStyle == 6 || viewStyle == 7) && rotatick < (rotaspeed - 14))) {
    
            for (let t = 0; t < globalnodes.length; t++) {
                if (globalnodes[t].dead == 1) {
                    if (globalnodes[t].ultradead != 1) {
                        globalnodes[t].ultradead = 1
                        let spin = 5
                        for (let r = 0; r < spin; r++) {
                            let a = (r * ((Math.PI / (spin / 2))))
                            let cosa = Math.cos(a)
                            let sina = Math.sin(a)
                            let p = new Circle(globalnodes[t].x, globalnodes[t].y, 3.5 * worldscaler, globalnodes[t].body.color, cosa * .4 * worldscaler, sina * .4 * worldscaler)
                            p.shrink = 1
                            p.alpha = globalnodes[t].linkApha
                            p.type = globalnodes[t].type
                            // if(viewStyle == 5 || viewStyle == 7 || viewStyle == 4 || viewStyle == 6){
                            p.subcolor = globalnodes[t].subcolor
                            // }
                            particles.push(p)
                        }
    
                    }
                }
            }
    
    
            for (let t = particles.length - 1; t >= 0; t--) {
                particles[t].move()
                if (magnetonly == 1) {
    
                } else {
                    if (!keysPressed['7']) {
                        canvas_context.globalAlpha = particles[t].alpha
                        
            if(edgeLoop == 1){
    
                if(keysPressed['d']){
                    particles[t].x+=worldscale
                }
                if(keysPressed['a']){
                    particles[t].x-=worldscale
                }
                if(keysPressed['s']){
                    particles[t].y+=worldscale
                }
                if(keysPressed['w']){
                    particles[t].y-=worldscale
                }
            }
                        particles[t].draw(canvas_context)
                    }
                }
                particles[t].radius -= .25 * worldscaler
            }
    
            canvas_context.globalAlpha = 1
            for (let t = particles.length - 1; t >= 0; t--) {
                if (particles[t].radius <= 0) {
                    particles.splice(t, 1)
                }
            }
        }
        
    }
    
    function F25(){
    
        for (let t = 0; t < globalnodes.length; t++) {
            globalnodes[t].superhead = 0
            globalnodes[t].finalhead = 0
        }
        
    }
    
    function F26(){
    
        for (let t = 0; t < globalnodes.length; t++) {
    
            // if(globalnodes[t].dead == 1){
            //     continue
            // }
            if (globalnodes[t].head == 1 && globalnodes[t].trueage > 2) {
                // ////////////console.log(worldtime)
                // ////////////console.log(globalnodes[t].energy)
                globalnodes[t].energyBalance()
                globalnodes[t].superhead = 1
                for (let f = 0; f < globalnodes.length; f++) {
                    if (globalnodes[f].link.list.includes(t) == 1) {
                        if (t != f) {
                            globalnodes[f].head = 0
                            globalnodes[f].headkill = 1 ////??
                        }
                    }
                }
    
    
            }
    
    
        }
        if(seedRandom() < .02){
            for (let t = 0; t < globalnodes.length; t++) {
                if(globalnodes[t].finalhead != 1){
                    globalnodes[t].head = 1
                    break
                }
            }
        }
        
    }
    
    function F27(){
        for (let t = 0; t < globalnodes.length; t++) {
            // if (globalnodes[t].head == 1 && globalnodes[t].trueage > 2) {
                let x = 0
                let y = 0
                for(let g = 0;g<globalnodes[t].immune.length;g++){
                    if(globalnodes[globalnodes[t].immune[g]]){
                        x+=  globalnodes[globalnodes[t].immune[g]].x 
                        y+=  globalnodes[globalnodes[t].immune[g]].y
                    }
                }
                x/=Math.floor(globalnodes[t].immune.length*1)
                y/=Math.floor(globalnodes[t].immune.length*1)
    
                for(let g = 0;g<globalnodes[t].immune.length;g++){
                    if(globalnodes[globalnodes[t].immune[g]]){
                globalnodes[globalnodes[t].immune[g]].xavg = x
                globalnodes[globalnodes[t].immune[g]].yavg = y
                    }
                }
                globalnodes[t].xavg = x
                globalnodes[t].yavg = y
            // }
        }
    }
    
    
    function F28(){
    
    
        if (relationView) {
    
            let bucketOseen = {}
            for (let t = 0; t < globalnodes.length; t++) {
    
                if (bucketOseen[globalnodes[t].contextMarker] == 1) {
    
                } else {
                    bucketOseen[globalnodes[t].contextMarker] = 1
                    let cn = canvasList[globalnodes[t].contextMarker]
                    let x = mappingArt[globalnodes[t].contextMarker].x
                    let y = mappingArt[globalnodes[t].contextMarker].y
                    let width = mappingArt[globalnodes[t].contextMarker].width
                    let height = mappingArt[globalnodes[t].contextMarker].height
                    let ws = (worldscale * 1.1)
                    if (globalnodes[t].magnet) {
                        ws += globalnodes[t].magnet.radius
                    }
                    // ////////////////console.log(mappingArt)
                    canvas_context.globalAlpha = Math.min(globalnodes[t].bet, 1)
                    canvas_context.imageSmoothingEnabled = false
                    canvas_context.drawImage(cn, x - ws, y - ws, width + (ws * 2), height + (ws * 2), x - ws, y - ws, width + (ws * 2), height + (ws * 2))
                }
    
            }
            canvas_context.globalAlpha = 1
        }
    }
    
    function F29(){
    
        if (viewStyle != 3) {
    
            let link = new LineOP(new Point(TIP_engine.x / zoom, TIP_engine.y / zoom), TIP_engine)
            let min = 9999999999
            let inder = -1
            for (let t = mindead; t < globalnodes.length; t++) {
                link.target = globalnodes[t]
                globalnodes[t].talk = 0
                globalnodes[t].nearestmouse = 0
                if (!keysPressed['6'] && pu.grab == -1) {
                    globlock = 0
                    globalnodes[t].lockon = 0
                }
                if (!relationView) {
                    rellock = 0
                    globalnodes[t].relative = -1
                }
                let h = link.hypotenuse()
                if (h < min) {
                    min = h
                    inder = t
                }
            }
    
            if (inder != -1) {
                for (let t = 0; t < globalnodes[inder].immune.length; t++) {
                    globalnodes[globalnodes[inder].immune[t]].nearestmouse = 1
                    globalnodes[globalnodes[inder].immune[t]].talk = 1
    
                }
            }
    
    
    
            for (let t = mindead; t < globalnodes.length; t++) {
                if (globalnodes[t].dead == 1) {
                    continue
                }
    
    
                if (keysPressed['7'] || pu.seebets == 1) {
                    globalnodes[t].textbet()
                }
    
    
    
                if (globalnodes[t].talk == 1 || !keysPressed['4']) {
                    globalnodes[t].text(alldead)
                    if (pu.potential < .25 * (runcount / 10)) {
                        if (pu.freemove == 1) {
    
                        } else {
                            keysPressed['6'] = false
                        }
                    }
                    if ((keysPressed['6']  || ((pu.grab == 1 && pu.grab2 == 1) && pu.worldtouch != 1)) && (pu.potential > .1 || pu.freemove == 1)) {
                        if (pu.freemove == 1) {} else {
                            if (pu.potential <= 0) {
                                keysPressed['6'] = false
                            }
                        }
                        if (globalnodes[t].talk) {
                            if (globlock == 0) {
    
                                globlock = 1
                                globalnodes[t].lockon = 1
                                // globalnodes[t].pushoutsto+=.1
    
                                for (let f = 0; f < globalnodes[t].immune.length; f++) {
                                    globalnodes[globalnodes[t].immune[f]].lockon = 1
                                    // globalnodes[globalnodes[t].immune[f]].pushout+=.1
                                }
                            }
                        }
                    }
    
                    if (globalnodes[t].talk == 1) {
    
                        if (relationView) {
                            rellock = 1
                            for (let kr = mindead; kr < globalnodes.length; kr++) {
                                globalnodes[kr].relative = t
    
                            }
    
                        }
    
    
                    }
                }
                if (keysPressed['3']) {
                    if (globalnodes[t].talk == 1 && globalnodes[t].age > 5 && deadwash > 3 && deadwash < deadmax - 3) {
                        if (globalnodes[t].head == 1) {
                            if (globalnodes[t].dead != 1) {
                                if(globalnodes[t].xavg + globalnodes[t].yavg != 0){
                                DupeNoRef(globalnodes[t], TIP_engine)
                                keysPressed['3'] = false
                                }
                            }
                        }
                    }
                }
                // if(globalnodes[t].die == 1){
                //     ////////////////////////////////console.log("hd")
                //     // globalnodes[t].dead = 1
                // }
            }
    
        }
    }
    
    
    function F30(){
    
    
        for (let t = mindead; t < globalnodes.length; t++) {
            if (globalnodes[t].dmark == 1) {
                globalnodes[t].superdead = 1
            }
        }
    
    
    
    
        if (dorecon == 1) {
            reconstitute(reconflag)
            dorecon = 0
    
        }
    
    
        if (keysPressed['[']) {
            keysPressed['['] = false
            for (let t = 0; t < worldsave.guys.length; t++) {
                reconstitute(worldsave.guys[t])
                // repconstant = 99999999999999
            }
        }
    
    
    
    
        if (viewStyle == 3) {
    
        } else {
    
            if (slide == 1) {
                // ////////////////console.log("wej")
    
                if (canvas.width > 0) {
    
                    pix = canvas_context.getImageData(0, 0, canvas.width, canvas.height)
                }
                canvas_context.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, canvas.width * 2, canvas.height * 2)
    
            } else {
                if (magnetzoom == 1) {
    
                    // ////////////////console.log("wej")
                    if (canvas.width > 0) {
    
                        pix = canvas_context.getImageData(0, 0, canvas.width / zoom, canvas.height / zoom)
    
                    }
                    let d = pix.data
    
                    let sampler = []
                    let link = new LineOP(new Point(0, 0), new Point(0, 0))
    
    
                    let tess = []
                    for (let t = 0; t < d.length; t += 4) {
                        tess.push(t)
    
                    }
    
                    tess.sort((a, b) => Math.random() > .5 ? -1 : 1)
    
                    for (let w = 0; w < d.length; w++) {
                        let t = tess[w]
                        let rsum = 0
                        let gsum = 0
                        let bsum = 0
    
    
                        //    if(seedRandom()<.1){
                        //     sampler = {}
                        //    }
                        //    if(seedRandom()<.2){
                        let p = indexer(t, canvas.width / zoom)
                        link.object = p
    
                        for (let k = 0; k < globalnodes.length; k++) {
                            // if(sampler[k]){
                            //     continue
                            // }
                            link.target = globalnodes[k]
                            if (globalnodes[k].charge == -1) {
                                let h = link.squareDistance()
                                h /= Math.max(((globalnodes[k].magratio) * 20) - 1, 1)
                                bsum += 100 / (h + 1)
                                // rsum+= 100/(h+1)
                                // gsum-= 100/(h+1)
    
                                if (gsum > 0) {
                                    rsum += Math.min(100 / Math.max(h + .5, 1), gsum) * 1.55
                                    gsum -= Math.min(100 / Math.max(h + 1, 1), gsum)
                                }
    
    
                            }
                            if (globalnodes[k].charge == 1) {
                                let h = link.squareDistance()
                                h /= Math.max((((globalnodes[k].magratio)) * 20) - 1, 1)
    
                                if (bsum > 0) {
                                    rsum += Math.min(100 / Math.max(h + .5, 1), bsum) * 1.55
                                    bsum -= Math.min(100 / Math.max(h + 1, 1), bsum)
                                }
    
    
                                gsum += 100 / (h + 1)
                                // bsum-= 100/(h+1)
                            }
                            // if(h > 3600){
                            //     // sampler[k] = true
                            //     continue
                            // }
                            // rsum += Math.max((globalnodes[k].subr/(((h/65)+.1)/2)/2)-h,0)
                            // gsum +=  Math.max((globalnodes[k].subg/(((h/65)+.1)/2)/2)-h,0)
                            // bsum +=  Math.max((globalnodes[k].subb/(((h/65)+.1)/2)/2)-h,0)
                        }
                        //    }
                        d[t] = rsum
                        d[t + 1] = gsum
                        d[t + 2] = bsum
                        d[t + 3] = 255
                    }
    
                    canvas_context.putImageData(pix, 0, 0)
                } else {
    
    
                }
                canvas_context.imageSmoothingEnabled = false
                // canvas_context.drawImage(canvas,0,0,canvas.width, canvas.height, 0,0, canvas.width*2, canvas.height*2)
    
    
            }
    
    
        }
    }
    
    let alldead = 0
    
    function view3(){
    
    
        if (viewStyle == 3) {
            // canvas_context.drawImage(canvas,0,0,canvas.width, canvas.height, 0,0, canvas.width/zoom, canvas.height/zoom)
    
            let d = pix.data
    
    
            let sampler = []
            let link = new LineOP(new Point(0, 0), new Point(0, 0))
    
    
            let tess = []
            for (let t = 0; t < d.length; t += 4) {
                tess.push(t)
    
            }
    
            tess.sort((a, b) => Math.random() > .5 ? -1 : 1)
    
            for (let w = 0; w < d.length; w += 4) {
                let t = tess[w]
                let rsum = 0
                let gsum = 0
                let bsum = 0
    
    
                //    if(seedRandom()<.1){
                //     sampler = {}
                //    }
                if (Math.random() < .2) {
                    let p = indexer(t, canvas.width / zoom)
                    link.object = p
    
                    for (let k = 0; k < globalnodes.length; k++) {
                        // if(sampler[k]){
                        //     continue
                        // }
                        link.target = globalnodes[k]
                        let h = link.squareDistance()
                        if (h > 3600) {
                            // sampler[k] = true
                            continue
                        }
                        rsum += Math.max((globalnodes[k].subr / (((h / 65) + .1) / 2) / 2) - h, 0)
                        gsum += Math.max((globalnodes[k].subg / (((h / 65) + .1) / 2) / 2) - h, 0)
                        bsum += Math.max((globalnodes[k].subb / (((h / 65) + .1) / 2) / 2) - h, 0)
                    }
                }
                d[t] = ((d[t] * 12) + rsum) / 13
                d[t + 1] = ((d[t + 1] * 12) + gsum) / 13
                d[t + 2] = ((d[t + 2] * 12) + bsum) / 13
                d[t + 3] = 255
            }
    
            canvas_context.putImageData(pix, 0, 0)
            for (let t = mindead; t < globalnodes.length; t++) {
                if (globalnodes[t].dead == 1) {
                    continue
                }
                globalnodes[t].text(alldead)
                // if(globalnodes[t].die == 1){
                //     ////////////////////////////////console.log("hd")
                //     // globalnodes[t].dead = 1
                // }
            }
            canvas_context.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, canvas.width * 2, canvas.height * 2)
    
        }
    }
    
    function F31(){
        fded = lsstbodc
        fded2 = lasfgl
        lsstbodc = bodc
        lasfgl = globalnodes.length
    
        for (let t = 0; t < globalnodes.length; t++) {
            globalnodes[t].aged()
        }
    }
    function F32(){
    
    }
    function metricz(){
    
        if (metricsON == 1) {
            metrics.time++
        }
        let buckets = {}
        if (metrics.time == metrics.tick) {
            metrics.time = 0
            let comp = 0
            let compm = 0
            let min = 999999999999
            let max = 0
    
            for (let t = 0; t < globalnodes.length; t++) {
                // ////////////////////console.log(globalnodes[t].runprod)
                if (globalnodes[t].head == 1 && globalnodes[t].dead != 1 && globalnodes[t].runprod > 0) {
                    comp += globalnodes[t].ll
                    min = Math.min(globalnodes[t].ll, min)
                    max = Math.max(globalnodes[t].ll, max)
                    compm++
                    if (buckets[globalnodes[t].runsum + ',' + globalnodes[t].runprod]) {
                        buckets[globalnodes[t].runsum + ',' + globalnodes[t].runprod]++
                    } else {
                        buckets[globalnodes[t].runsum + ',' + globalnodes[t].runprod] = 1
                    }
                }
            }
    
            comp /= compm
            if (true) {
                let alldead = 0
                for (let t = 0; t < globalnodes.length; t++) {
                    if (globalnodes[t].dead == 1) {
                        alldead++
                    }
                }
                metrics.nodepopulation.push(globalnodes.length - alldead)
            }
            metrics.complexity.push(comp)
            metrics.mincomplexity.push(min)
            metrics.maxcomplexity.push(max)
            metrics.population.push(compm)
            metrics.species.push(buckets)
    
            // let outdiv = 0
            // let divsum = 0
            // let divtotsum = 0
            // let keys = Object.keys(buckets)
            // for(let r = 0;r<keys.length;r++){
            //     divsum++
            //     divtotsum+=buckets[keys[r]]
            // }
    
    
            // outdiv = divsum/divtotsum
    
    
            metrics.diversity.push(dindex(buckets))
    
    
    
    
        }
        if (keysPressed['q']) {
            console.log(metrics)
        }
    }
    
    let soundColors = []
    
    let primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83]
    
    const rgbColors = [
        { r: 255, g: 255, b: 255 },  // #FFFFFF
        { r: 170, g: 0, b: 85 },     // #AA0055
        { r: 255, g: 204, b: 0 },    // #FFCC00
        { r: 136, g: 0, b: 255 },    // #8800FF
        { r: 0, g: 255, b: 0 },      // #00FF00
        { r: 255, g: 0, b: 0 },      // #FF0000
        { r: 255, g: 136, b: 0 },    // #FF8800
        { r: 0, g: 255, b: 255 },    // #00FFFF
        { r: 34, g: 136, b: 68 },    // #228844
        { r: 68, g: 153, b: 255 },   // #4499FF
        { r: 170, g: 86, b: 120 },   // #AA5678
        { r: 170, g: 255, b: 170 },  // #AAFFAA
        { r: 170, g: 136, b: 136 },  // #AA8888
        { r: 255, g: 68, b: 187 },   // #FF44BB
        { r: 136, g: 153, b: 0 },    // #889900
        { r: 221, g: 221, b: 102 },  // #DDDD66
        { r: 136, g: 0, b: 0 },      // #880000
        { r: 85, g: 85, b: 85 },     // #555555
        { r: 34, g: 51, b: 204 },    // #2233CC
        { r: 255, g: 170, b: 170 },  // #FFAAAA
        { r: (9*16)+8, g: (2*16)+7, b: (5*16)+4 },    // #982754
        { r: 170, g: 136, b: 255 },  // #AA88FF
        { r: 84, g: 50, b: 16 }      // #543210
      ];
    
    
    
      function averageColors(c1,c2){
    
        return `rgb(${((c1.r+c2.r)/2)},${((c1.g+c2.g)/2)},${((c1.b+c2.b)/2)})`
      }
    
    for(let t = 0;t<primes.length;t++){
        for(let k = 0;k<primes.length;k++){
            let pr = primes[t]*primes[k]
            let c = averageColors(rgbColors[t],rgbColors[k])
            // //////console.log(c, pr, t,k)
            soundColors[pr]  = c 
        }
    }
    
    
    
    let icons = new Image()
    icons.src = "icons.png"
let    notes = [
"C2","D2","E2","F2","G2","A2","B2",
"C1","D1","E1","F1","G1","A1","B1",
"C3","D3","E3","F3","G3","A3","B3",
"C4","D4","E4","F4","G4","A4","B4"
];
const durations = ["32n"];

let soundtable = {};
for (let i = 0; i < primes.length; i++) {
  for (let j = 0; j < primes.length; j++) {
    let product = primes[i] * primes[j];
    let note = notes[(i + j) % notes.length];
    let duration = durations[(i * j) % durations.length];
    soundtable[product] = [note, duration];
  }
}



    
    function main() {
        if(F1()){
            return
        }
        F2()
        F3()
        F4()
        F5()
        F6()
        if (fded != fded2 && fded2 < 0) { 
            if (signal == 1) {
                return
            }
        }
        F7()
        if(soundFlip ==1){
            drawSound()
        }
        if(F8()){
            return
        }
        F9()
        F10()
        F11()
        F12()
        F13()
        F14()
        cleanDeadOut()
        MakeUp()
        clearBucket()
        F15()
        F16()
    
    
        F18()
        F19()
        MagnetismOn()
        F20()
        F21()
        F22()
        F23()
        F24()
        F25()
        F26()
        F27()
        F28()
        F29()
        F30()
        view3()
        F31()
        F32()
        metricz()
        pu.draw()
    }
    
    // })
    
    
    function dindex(speciesCounts) {
        const species = Object.keys(speciesCounts);
        const N = species.reduce((sum, key) => sum + speciesCounts[key], 0);
        if (N <= 1) return 0;
        let sum = 0;
        for (const key of species) {
            const n = speciesCounts[key];
            sum += (n * (n - 1));
        }
        const D = sum / (N * (N - 1));
        const simpsonsIndex = 1 - D;
        return simpsonsIndex;
    }
    
    
    function indexer(index, width) {
    
        // if(edgeLoop == 1){
        const pixelIndex = index / 4; 
        const x = pixelIndex % width;
        const y = Math.floor(pixelIndex / width);
        return {
            x,
            y
        };
        // }else{
    
        //     const pixelIndex = index / 4; 
        //     const x = pixelIndex % width;
        //     const y = Math.floor(pixelIndex / width);
        //     return { x, y };
        // }
    }
    
    function deindexer(x, y, width) {
        if (edgeLoop == 1) {
    
            x = (x + Math.floor(width)) % Math.floor(width)
            if (width <= Math.floor(canvas.width / smellScaler)) {
    
                y = (y + Math.floor(canvas.height / smellScaler)) % Math.floor(canvas.height / smellScaler)
            } else {
    
                y = (y + Math.floor(canvas.height / zoom)) % Math.floor(canvas.height / zoom)
            }
            const pixelIndex = (y * width + x);
            return pixelIndex * 4;
        } else {
    
            x = Math.min(Math.max(x, 0), width)
            const pixelIndex = (y * width + x);
            return pixelIndex * 4;
        }
    }
    
    
    let odds = 0
    
    let total = 0
    let found = 0
    let given = 10000000
    
    // function generateGene() {
    
    //     let g = ''
    //     for (let t = 0; t < genelength; t++) {
    //         g += geneChars[Math.floor(seedRandom() * geneChars.length)]
    //     }
    
    //     // ////////////////console.log(g)
    //     return g
    // }
    
    //   for(let t = 0;t<given;t++){
    
    //     if(geneToType(generateGene()) == 22){
    
    //         found++
    
    //     }
    //   }
    //   odds = found/given
    //   console.log(odds)
    
    function vectorLength7D(a, b, c, d, e, f, g) {
        return Math.sqrt(a ** 2 + b ** 2 + c ** 2 + d ** 2 + e ** 2 + f ** 2 + g ** 2);
    }
    function alphaToHex(alpha) {
        const clampedAlpha = Math.max(0, Math.min(1, alpha));
        const intValue = Math.round(clampedAlpha * 255);
        return intValue.toString(16).padStart(2, '0');
    }
    
    function getUniqueValues(x) {
        if (x > 20) throw new Error("Cannot generate more than 16 unique values between 0 and 20");
        const pool = Array.from({
            length: 20
        }, (_, i) => i);
        for (let i = pool.length - 1; i > 0; i--) {
            const j = Math.floor(seedRandom() * (i + 1));
            [pool[i], pool[j]] = [pool[j], pool[i]];
        }
        return pool.slice(0, x);
    }
    
    function rotateToward(current, target, maxStep = Math.PI) {
        let delta = ((target - current + Math.PI) % (2 * Math.PI)) - Math.PI;
        if (Math.abs(delta) <= maxStep) {
            return target;
        }
        return current + Math.sign(delta) * maxStep;
    }
    
    
    
    
    // let fcount = 0
    // let gcount = 0
    // let cards = []
    
    // for(let t =0;t<13;t++){
    //     cards.push(1)
    // }
    
    // for(let t =0;t<47;t++){
    //     cards.push(0)
    // }
    
    
    // let counr = 1000000
    
    // for(let d = 0;d<counr;d++){
    
    //     let deck = []
    //     for(let t= 0;t<cards.length;t++){
    //         deck[t] = cards[t]
    //     }
    
    //     let hand = []
    
    //     for(let t = 0;t<9;t++){
    //         let card = Math.floor(seedRandom()*deck.length)
    //         hand.push(deck[card])
    //         deck.splice(card,1)
    //     }
    
    //     let v = 0
    //     for(let r = 0;r<hand.length;r++){
    //         v+=hand[r]
    //     }
    //     if(v == 4){
    //         fcount++
    //     }
    //     if(v >= 5){
    //         gcount++
    //     }
    
    
    
    
    // }
    
    
    
    // let rat1 = fcount/counr
    // let rat2 = gcount/counr
    
    // ////////////////console.log("Flush: "+rat2)
    
    function findMinimumWrappedDistance(obj1, obj2, width, height, capp = ((worldscale * 1.25) - (worldscale * .05))) {
     const result = {
      obj1: { ...obj1 },
      obj2: { ...obj2 }
    };
    result.obj2.x = ((obj2.x % width) + width) % width;
    result.obj2.y = ((obj2.y % height) + height) % height;
    const possibleX2 = [result.obj2.x, result.obj2.x - width, result.obj2.x + width];
    const possibleY2 = [result.obj2.y, result.obj2.y - height, result.obj2.y + height];
    let minDistance = Infinity;
    for (const wrapX2 of possibleX2) {
      for (const wrapY2 of possibleY2) {
        const dx = result.obj1.x - wrapX2;
        const dy = result.obj1.y - wrapY2;
        // let c = new Circle(wrapX2, wrapY2, 2, "red")
        // c.draw()
        // let link = new LineOP(c, result.obj1, "white", 1)
        // link.draw()
        const distance = (dx * dx + dy * dy);
        
        if (distance < minDistance) {
          minDistance = distance;
          result.obj2.x = wrapX2;
          result.obj2.y = wrapY2;
          result.distance = minDistance
          if(minDistance <= capp){
            return result
          }
        }
      }
    }
    result.distance = minDistance;
    
    return result;
    }
    function findClosestWrappedPair(objects, width, height) {
    let minDistance = 99999999;
    let closestPair = null;
    for (let i = 0; i < objects.length; i++) {
      for (let j = i + 1; j < objects.length; j++) {
        if(i != j){
            const obj1 = objects[i];
            const obj2 = objects[j];
            const result = findMinimumWrappedDistance(obj1, obj2, width, height);
            if (result.distance < minDistance) {
              minDistance = result.distance;
              closestPair = {
                obj1Index: i,
                obj2Index: j,
                obj1: result.obj1,
                obj2: result.obj2,
                distance: result.distance
              };
        }
        }
      }
    }
    return closestPair;
    }
    
    
    
    function isNearEdge(node, bucketsX, bucketsY, margin = 5) {
    return (
        node.idt <= margin ||
        node.idk <= margin ||
        node.idt >= (bucketsX - margin) ||
        node.idk >= (bucketsY - margin)
    );
    }
    
    function shiftPixels(imageData, width, height) {
    const srcCanvas = document.createElement('canvas');
    const dstCanvas = document.createElement('canvas');
    srcCanvas.width = dstCanvas.width = width;
    srcCanvas.height = dstCanvas.height = height;
    const srcCtx = srcCanvas.getContext("2d", { willReadFrequently: true })
    const dstCtx = dstCanvas.getContext("2d", { willReadFrequently: true })
    srcCtx.putImageData(imageData, 0, 0);
    let dx = 0, dy = 0;
    if (keysPressed['w']) dy -= 1;
    if (keysPressed['s']) dy += 1;
    if (keysPressed['a']) dx -= 1;
    if (keysPressed['d']) dx += 1;
    const srcData = srcCtx.getImageData(0, 0, width, height).data;
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const sx = (x - dx + width) % width;
            const sy = (y - dy + height) % height;
            const srcIndex = (sy * width + sx) * 4;
    
            const r = srcData[srcIndex];
            const g = srcData[srcIndex + 1];
            const b = srcData[srcIndex + 2];
            const a = srcData[srcIndex + 3];
    
            dstCtx.fillStyle = `rgba(${r},${g},${b},${a / 255})`;
            dstCtx.fillRect(x, y, 1, 1);
        }
    }
    return dstCtx.getImageData(0, 0, width, height);
    }
    
    
    
    
    
    
    // let potentialX = 0
    // let roundcap = 100000
    // let table = []
    // let tableOther = []
    // let rolledA = []
    // let rolledB = []
    // for(let k = 0;k<100;k++){
    //     rolledA[k] = 0
    //     rolledB[k] = 0
    // }
    // for(let t =0;t<roundcap;t++){
    //     let sum = 0
    //     let rolls = []
    //     for(let k = 0;k<3;k++){
    //         let roll = Math.floor(Math.random()*8)+1
    //         sum+=(roll)*2
    //         rolls.push(roll)
    //     }
    //     table.push([sum, rolls])
    //         sum = 0
    //         rolls = []
    //         potentialX = 12
    //     for(let r = 0;r<3;r++){
    //         let roll = Math.floor(Math.random()*8)+1
    //         sum+=(roll)
    //         rolls.push(roll)
    //     }
    //     sum+=potentialX
    //     tableOther.push([sum, rolls])
    // }
    // let xsum = 0
    // let ysum = 0
    // for(let t =0;t<roundcap;t++){
    //     rolledA[table[t][0]]++
    //     rolledB[tableOther[t][0]]++
    // }
    // ////////console.log(rolledA, rolledB)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    
      
    


    </script>
  </div>
</ul>
</div>

 

</html>
